<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《第二周单元测验》</title>
      <link href="/exam//675812a8/"/>
      <url>/exam//675812a8/</url>
      
        <content type="html"><![CDATA[<h1 id="《第二周单元测验》"><a href="#《第二周单元测验》" class="headerlink" title="《第二周单元测验》"></a>《第二周单元测验》</h1><h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>下列哪个不是单字符正则表达式？</p><ul><li>A. <code>.</code> </li><li>B. <code>[i-k]</code></li><li>C. <code>@</code></li><li>D. <code>$</code><br>正确答案：D你错选为C</li></ul><h2 id="2单选-3分"><a href="#2单选-3分" class="headerlink" title="2单选(3分)"></a>2单选(3分)</h2><p>可以与正则表达式<code>A[i-k]*b[i]*c</code>匹配的最短字符串长度为：</p><ul><li>A. 6</li><li>B. 4</li><li>C. 3</li><li>D. 5<br>正确答案：C你选对了</li></ul><h2 id="3单选-3分"><a href="#3单选-3分" class="headerlink" title="3单选(3分)"></a>3单选(3分)</h2><p>能与正则表达式<code>a.x[i-j]*b[i-j]</code>匹配的字符串为：</p><a id="more"></a><ul><li>A. <code>a.x[i-j]*b[i-j]</code></li><li>B. <code>a*xbj</code></li><li>C. <code>a-x[i]*b[j]</code></li><li>D. <code>axibj</code><br>正确答案：B你选对了</li></ul><h2 id="4单选-3分"><a href="#4单选-3分" class="headerlink" title="4单选(3分)"></a>4单选(3分)</h2><p>与字符串<code>A1234</code>不匹配的正则表达式有：</p><ul><li>A. <code>A.*</code></li><li>B. <code>A12345*</code></li><li>C. <code>[A-Z][0-9]*</code></li><li>D. <code>A*4</code><br>正确答案：D你选对了</li></ul><h2 id="5判断-2分"><a href="#5判断-2分" class="headerlink" title="5判断(2分)"></a>5判断(2分)</h2><p>grep和fgrep都可以从一个文本文件中搜索出指定的字符串。<br>A. 错<br>B. 对<br>正确答案：B你选对了</p><h2 id="6判断-2分"><a href="#6判断-2分" class="headerlink" title="6判断(2分)"></a>6判断(2分)</h2><p>fgrep，grep，egrep三个命令在指定待查找字符串的模式方面，依次越来越灵活，后面的命令可以覆盖前面命令的功能，并且模式描述的语法也是完全兼容的。<br>A. 对<br>B. 错<br>正确答案：B你错选为A</p><h2 id="7判断-2分"><a href="#7判断-2分" class="headerlink" title="7判断(2分)"></a>7判断(2分)</h2><p>命令<code>cat pm.txt | sed &#39;s/\[[^][]*]//g&#39;</code>可以把pm.txt中所有用方括号括起来的内容（包括方括号自身）类似“ [参考文献23] ”这样的字符串片段删除。<br>A. 错<br>B. 对<br>正确答案：B你选对了</p><h2 id="8判断-2分"><a href="#8判断-2分" class="headerlink" title="8判断(2分)"></a>8判断(2分)</h2><p>grep可以筛选出包括某些特定模式的文本行，awk不仅可以筛出指定模式的行，还可以筛掉文本型表格中的部分列。<br>A. 对<br>B. 错<br>正确答案：A你选对了</p><h2 id="9判断-2分"><a href="#9判断-2分" class="headerlink" title="9判断(2分)"></a>9判断(2分)</h2><p>正则表达式<code>&lt;[^&lt;&gt;]*&gt;</code>可以匹配一个HTML格式数据中的诸如<code>&lt;span class=&quot;src-time&quot;&gt;</code>这样的用尖括号包裹起来的标签信息。<br>A. 对<br>B. 错<br>正确答案：A你没选择任何选项</p><h2 id="10判断-2分-awk描述"><a href="#10判断-2分-awk描述" class="headerlink" title="10判断(2分) awk描述"></a>10判断(2分) awk描述</h2><p>awk是一门小型的文本数据处理语言，有类似C语言一样的语法，可以使用自定义的变量，变量之间可以进行算术运算、关系运算和逻辑运算，还可以进行正则表达式匹配运算，支持条件、循环等流程控制。<br>A. 对<br>B. 错<br>正确答案：A你选对了</p>]]></content>
      
      
      <categories>
          
          <category> 网课习题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《第一周单元测验》(二）</title>
      <link href="/exam//59d45d43/"/>
      <url>/exam//59d45d43/</url>
      
        <content type="html"><![CDATA[<h1 id="《第一周单元测验》-二）"><a href="#《第一周单元测验》-二）" class="headerlink" title="《第一周单元测验》(二）"></a>《第一周单元测验》(二）</h1><h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>使用more命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？</p><ul><li>A. 向下的箭头键</li><li>B. 空格</li><li>C. 回车 </li><li>D. Esc键</li></ul><p>正确答案：C你选对了</p><h2 id="2单选"><a href="#2单选" class="headerlink" title="2单选"></a>2单选</h2><p>使用less命令逐屏显示文本文件时，使得显示内容上滚一行而不是滚动一屏，应按下哪个键？</p><ul><li>A. 回车</li><li>B. 空格键</li><li>C. Ctrl-L</li><li>D.  Esc键</li></ul><a id="more"></a><p>正确答案：A你选对了</p><h2 id="3单选"><a href="#3单选" class="headerlink" title="3单选"></a>3单选</h2><p>Linux中用来实现计数功能，比如：统计系统有多少个登录用户，实现计数功能的命令是：</p><ul><li>A. sort -n</li><li>B. wc -l</li><li>C. cnt -s</li><li>D. uniq -c</li></ul><p>正确答案：B你选对了</p><h2 id="4判断"><a href="#4判断" class="headerlink" title="4判断"></a>4判断</h2><p>uniq命令可以通过它的选项，选择打印所有只出现一次的行，或者打印出现不只一次的行，或者两种都选。但无论哪种情况，重复出现的行最多只能打印一次。</p><ul><li>A. 对</li><li>B. 错</li></ul><p>正确答案：A你错选为B</p><h2 id="5判断"><a href="#5判断" class="headerlink" title="5判断"></a>5判断</h2><p>一个应用程序的C语言源程序通过printf语句在标准输出输出信息，运行时只要使用输出重定向机制，不需要修改原先的程序加入文件操作的代码，就可以把输出结果存入指定名字的文件。</p><ul><li>A. 错</li><li>B. 对</li></ul><p>正确答案：B你选对了</p><h2 id="6判断"><a href="#6判断" class="headerlink" title="6判断"></a>6判断</h2><p>less命令时more命令的一个简化版本，精简后功能比more弱，但更节约内存和CPU</p><ul><li>A. 错</li><li>B. 对</li></ul><p>正确答案：A你选对了</p><h2 id="7判断"><a href="#7判断" class="headerlink" title="7判断"></a>7判断</h2><p>od命令可以实现用16进制方式逐字节打印一个文件内容的功能，但要求文件的每个字节必须是可打印字符。</p><ul><li>A. 错</li><li>B. 对</li></ul><p>正确答案：A你选对了</p><h2 id="8判断"><a href="#8判断" class="headerlink" title="8判断"></a>8判断</h2><p>信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的255种取值“翻译”为另一个字节值，唯有字节值为0时无法转译，因为一个字节的8个比特全为零被用作字符串结尾。</p><ul><li>A. 错</li><li>B. 对</li></ul><p>正确答案：A你没选择任何选项</p><h2 id="9判断"><a href="#9判断" class="headerlink" title="9判断"></a>9判断</h2><p>不带任何选项的uniq命令消除数据中重复的行。一旦某一行出现过，uniq会记录下来，以后无论这一行在以后什么地方再次出现，输出时都会被忽略，保证数据的唯一行。</p><ul><li>A. 错</li><li>B. 对</li></ul><p>正确答案：A你选对了</p><h2 id="10判断"><a href="#10判断" class="headerlink" title="10判断"></a>10判断</h2><p>信息由一个个字节组成，tr命令处理这些信息时，可以将256种字节值中的任何一种取值“翻译”为另一个字节值，并且不限于可打印字符之间的转译，比如把换行符替换为斜线。</p><ul><li>A. 对</li><li>B. 错</li></ul><p>正确答案：A你选对了<br><!-- https://www.icourse163.org/learn/BUPT-1003557006?tid=1450758476#/learn/quizscore?id=1223003562&aid=2303098948 --></p>]]></content>
      
      
      <categories>
          
          <category> 网课习题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《第一周单元测验》(一)</title>
      <link href="/exam//5cba7af/"/>
      <url>/exam//5cba7af/</url>
      
        <content type="html"><![CDATA[<h2 id="1单选-3分"><a href="#1单选-3分" class="headerlink" title="1单选(3分)"></a>1单选(3分)</h2><p>C语言编写的应用程序，通过printf打印一个换行符\n，但在终端上执行的是回车加换行\r\n，把换行符替换为回车换行是由下面哪个软件模块完成的？<br>A. C语言实现printf功能的动态链接库<br>B. Linux的串口驱动程序<br>C. 应用程序中的C语言函数库<br>D. Linux内核中的行律模块</p><p>正确答案：D你选对了</p><a id="more"></a><h2 id="2单选-3分"><a href="#2单选-3分" class="headerlink" title="2单选(3分)"></a>2单选(3分)</h2><p>Linux超级用户的用户名为：<br>A. supervisor<br>B. admin<br>C. administrator<br>D. root</p><p>正确答案：D你选对了</p><h2 id="3单选-3分"><a href="#3单选-3分" class="headerlink" title="3单选(3分)"></a>3单选(3分)</h2><p>下面哪个命令可以获得某进程占用的逻辑内存大小？<br>A. uptime<br>B. vmstat<br>C. free<br>D. ps</p><p>正确答案：D你错选为B</p><h2 id="4单选-3分"><a href="#4单选-3分" class="headerlink" title="4单选(3分)"></a>4单选(3分)</h2><p>下面哪个命令可以了解目前系统CPU的空闲情况？</p><p>A. who<br>B. free<br>C. ps<br>D. uptime</p><p>3.00/3.00<br>正确答案：D你选对了</p><h2 id="5判断-2分"><a href="#5判断-2分" class="headerlink" title="5判断(2分)"></a>5判断(2分)</h2><p>终端仅仅是Linux主机的一个外部设备，不分担存储和计算工作。<br>A. 对<br>B. 错</p><p>正确答案：A你选对了</p><h2 id="6判断-2分"><a href="#6判断-2分" class="headerlink" title="6判断(2分)"></a>6判断(2分)</h2><p>传统的终端与Linux主机之间传输的是字节流。<br>A. 错<br>B. 对</p><p>正确答案：B你选对了</p><h2 id="7判断-2分"><a href="#7判断-2分" class="headerlink" title="7判断(2分)"></a>7判断(2分)</h2><p>终端转义序列的意义在于终端收到某一特定字符序列后执行一些约定好的控制功能，而不是把这些字符显示在显示器上。<br>A. 对<br>B. 错</p><p>正确答案：A你选对了</p><h2 id="8判断-2分"><a href="#8判断-2分" class="headerlink" title="8判断(2分)"></a>8判断(2分)</h2><p>直接执行bc命令，后面不带任何选项，除法计算时保留小数点后20个有效数字。<br>A. 对<br>B. 错</p><p>正确答案：B你选对了</p><h2 id="9判断-2分"><a href="#9判断-2分" class="headerlink" title="9判断(2分)"></a>9判断(2分)</h2><p>Linux中超级用户的权限很大，可以读取普通用户的口令值。</p><p>A. 错<br>B. 对<br>正确答案：A你选对了</p><h2 id="10判断-2分"><a href="#10判断-2分" class="headerlink" title="10判断(2分)"></a>10判断(2分)</h2><p>ps命令显示进程占用内存的大小SZ，这表示该进程占用了多少物理内存。<br>A. 对<br>B. 错</p><p>正确答案：B你没选择任何选项</p><!-- https://www.icourse163.org/learn/BUPT-1003557006?tid=1450758476#/learn/quizscore?id=1223003561&aid=2303013359 -->]]></content>
      
      
      <categories>
          
          <category> 网课习题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月17日Linux专项联系1</title>
      <link href="/exam//15ad9369/"/>
      <url>/exam//15ad9369/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/15ad9369/#考点1-DHCP分配固定IP地址" class="header_1">考点1:DHCP分配固定IP地址</a>&nbsp;<br><a href="/exam/15ad9369/#考点2-切换超级用户" class="header_1">考点2:切换超级用户</a>&nbsp;<br><a href="/exam/15ad9369/#考点3-路由设置-route-add-net-目的网络-gw-网关地址" class="header_1">考点3:路由设置:route add -net 目的网络 gw 网关地址</a>&nbsp;<br><a href="/exam/15ad9369/#考点4-UNIX在退出系统账户后继续运行进程" class="header_1">考点4:UNIX在退出系统账户后继续运行进程</a>&nbsp;<br><a href="/exam/15ad9369/#考点5-vi编辑器命令模式复制当前行快捷键" class="header_1">考点5:vi编辑器命令模式复制当前行快捷键</a>&nbsp;<br><a href="/exam/15ad9369/#考点6-Linux环境变量配置文件" class="header_1">考点6:Linux环境变量配置文件</a>&nbsp;<br><a href="/exam/15ad9369/#考点7-Linux可执行文件开头的特征字符" class="header_1">考点7:Linux可执行文件开头的特征字符</a>&nbsp;<br><a href="/exam/15ad9369/#考点8-etc-sysctl-conf开启流量转发功能的参数" class="header_1">考点8:/etc/sysctl.conf开启流量转发功能的参数</a>&nbsp;<br><a href="/exam/15ad9369/#考点9-线程" class="header_1">考点9:线程</a>&nbsp;<br><a href="/exam/15ad9369/#考点10-Linux创建文件的命令" class="header_1">考点10:Linux创建文件的命令</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-DHCP分配固定IP地址"><a href="#考点1-DHCP分配固定IP地址" class="headerlink" title="考点1:DHCP分配固定IP地址"></a>考点1:DHCP分配固定IP地址</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p><ul><li>A <code>server-name</code></li><li>B <code>fixed-address</code></li><li>C <code>filename</code></li><li>D <code>hardware</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>fixed是固定的意思 address是地址的意思</p><h1 id="考点2-切换超级用户"><a href="#考点2-切换超级用户" class="headerlink" title="考点2:切换超级用户"></a>考点2:切换超级用户</h1><p>linux中哪个命令可以将普通用户转换成超级用户？()</p><ul><li>A <code>super</code></li><li>B <code>passwd</code></li><li>C <code>tar</code></li><li>D <code>su</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点3-路由设置-route-add-net-目的网络-gw-网关地址"><a href="#考点3-路由设置-route-add-net-目的网络-gw-网关地址" class="headerlink" title="考点3:路由设置:route add -net 目的网络 gw 网关地址"></a>考点3:路由设置:route add -net 目的网络 gw 网关地址</h1><p>局域网的网络地址192.168.1.0/24,局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0/24网络时,其路由设置正确的是？</p><ul><li>A <code>route add</code> –<code>net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</code></li><li>B <code>route add</code> –<code>net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</code></li><li>C <code>route add</code> –<code>net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1</code></li><li>D <code>route add default 192.168.1.0 netmask 172.168.1.1 metric 1</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络。明白这两项这题就能选了。</p><h1 id="考点4-UNIX在退出系统账户后继续运行进程"><a href="#考点4-UNIX在退出系统账户后继续运行进程" class="headerlink" title="考点4:UNIX在退出系统账户后继续运行进程"></a>考点4:UNIX在退出系统账户后继续运行进程</h1><p>在退出unix系统账户之后还需要继续运行某个进程,那么可用()</p><ul><li>A <code>awk</code></li><li>B <code>sed</code></li><li>C <code>crontab</code></li><li>D <code>nohup</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思<br>awk 对数据分析的</p><p>sed  编辑文件的</p><p>crontab<br>用于设置周期性被执行的指令</p><p> nohup</p><p>在注销后使用<br>nohup<br> 命令运行后台中的程序。</p><h1 id="考点5-vi编辑器命令模式复制当前行快捷键"><a href="#考点5-vi编辑器命令模式复制当前行快捷键" class="headerlink" title="考点5:vi编辑器命令模式复制当前行快捷键"></a>考点5:vi编辑器命令模式复制当前行快捷键</h1><p>在命令行下使用 vi 编辑一个文件时, 如何复制当前行？(最佳选项)</p><ul><li>A <code>cc</code></li><li>B <code>dd</code></li><li>C <code>yy</code></li><li>D <code>Ctrl + c</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>cc 多数unix通过此调用它们的C编译程序<br>dd  删除光标所在的一整行<br>yy 复制光标所在的一整行<br>p 将已复制的数据在光标的下一行粘贴<br>P 将已复制的数据在光标的上一行粘贴</p><p>yy复制当前行 nyy复制从当前行开始的n行。 pp是对应的粘贴操作，与yy对应，</p><h1 id="考点6-Linux环境变量配置文件"><a href="#考点6-Linux环境变量配置文件" class="headerlink" title="考点6:Linux环境变量配置文件"></a>考点6:Linux环境变量配置文件</h1><p>使用shell时,默认的环境变量放在哪里？</p><ul><li>A ~/.<code>bash_profile</code></li><li>B ~/.<code>bash</code></li><li>C <code>/etc/profile.d</code></li><li>D ~<code>/bash</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>/etc/profile:<br>此文件为系统的为每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.</p><p>/etc/bashrc<br>:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p><p>~/.bash_profile<br>:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</p><p>~/.bashrc<br>:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.</p><p>~/.bash_logout :<br>当每次退出系统(退出bash shell)时,执行该文件. </p><p>.bash_profile、.bashrc、和.bash_logout</p><p>上面这三个文件是bash shell的用户环境配置文件，位于用户的主目录下。</p><p>.bash_profile是最重要的一个配置文件，它在用户每次登录系统时被读取，里面的所有<br>命令都会被bash执行。.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。<br>在Debian中使用.profile文件代替.bash_profile文件。</p><p>.bashrc<br>文件会在bash shell调用另一个bash<br>shell时读取，也就是在shell中再键入bash命令启动一个新shell时就会去读该文件。这样可有效分离登录和子shell所需的环境。但一般 来说都会在.bash_profile里调用.bashrc脚本以便统一配置用户环境。</p><p>.bash_logout<br>在退出shell时被读取。所以我们可把一些清理工作的命令放到这文件中。</p><p>登录Linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、<br>~/.bash_login或<br>~/.profile文件中的其中一个(根据不同的linux操作系统的不同，命名不一样)，执行的顺序为：~/.bash_profile、<br>~/.bash_login、 ~/.profile。</p><p>如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。</p><h1 id="考点7-Linux可执行文件开头的特征字符"><a href="#考点7-Linux可执行文件开头的特征字符" class="headerlink" title="考点7:Linux可执行文件开头的特征字符"></a>考点7:Linux可执行文件开头的特征字符</h1><p>Linux的可执行文件开头的特征字符串是什么</p><ul><li>A <code>PE</code></li><li>B <code>MZ</code></li><li>C <code>ELF</code></li><li>D <code>LNX</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Executable Linkable File 可执行可链接文件<br>可移植可执行文件（Portable Executable，PE）是一种用于可执行、目标文件和动态链接库的文件格式，主要用于Windows，<br>而使用于Linux和多数Unix系统中的是可执行与可链接格式（ELF），Mac OS中则主要使用Mach-O；</p><h1 id="考点8-etc-sysctl-conf开启流量转发功能的参数"><a href="#考点8-etc-sysctl-conf开启流量转发功能的参数" class="headerlink" title="考点8:/etc/sysctl.conf开启流量转发功能的参数"></a>考点8:/etc/sysctl.conf开启流量转发功能的参数</h1><p>修改/etc/sysctl.conf如下哪项参数可以开启Linux流量转发功能()</p><ul><li>A <code>net.ipv4.conf.all.rp_filter = 0</code></li><li>B <code>net.ipv4.conf.default.rp_filter = 0</code></li><li>C <code>net.ipv4.ip_forward = 1</code></li><li>D <code>net.ipv4.conf.all.rp_filter = 1</code></li><li>E <code>net.ipv4.conf.default.rp_filter = 1</code></li><li>F <code>net.ipv4.ip_forward = 0</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>可以通过命令：cat /proc/sys/net/ipv4/ip_forward查看，1为开启Linux流量转发，0为禁止使用。<br>rp_filter参数有三个值，0、1、2，具体含义：</p><p>0：不开启源地址校验。</p><p>1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。</p><p>2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不同，则直接丢弃该数据包。</p><h1 id="考点9-线程"><a href="#考点9-线程" class="headerlink" title="考点9:线程"></a>考点9:线程</h1><p>有关线程说法正确的是( )</p><ul><li>A 线程是程序的多个顺序的流动态执行</li><li>B 线程有自己独立的地址空间</li><li>C 线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制</li><li>D 线程是系统进行资源分配和调度的一个独立单位</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是<strong>操作系统进行资源分配和调度的一个独立单位</strong>；</p><p>线程是进程的一个实体，一个进程中包含多个线程。是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位</p><p>进程有独立的地址空间，线程没有。<br><strong>线程是共享进程的地址空间</strong>，因此B错误</p><p><strong>进程是操作系统进行资源分配和调度的一个独立单位</strong>，而<strong>线程只是CPU调度和分派的基本单位</strong>，因此D错误</p><p>进程有独立的地址空间，线程没有。线程是共享进程的地址空间</p><h1 id="考点10-Linux创建文件的命令"><a href="#考点10-Linux创建文件的命令" class="headerlink" title="考点10:Linux创建文件的命令"></a>考点10:Linux创建文件的命令</h1><p>linux 创建文件的命令有()</p><ul><li>A <code>ls</code></li><li>B <code>touch</code></li><li>C <code>cat</code></li><li>D <code>vi/vim</code></li><li>E <code>&gt;</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details><p>touch filename 新建文件<br>将几个文件合并为一个文件 ——-cat file1 file2 &gt; file</p><p>vi/vim filename 表示用vi或vim打开文件，如果不存在该文件则新建文</p><p>ls -查看当前目录下的文件<br>touch filename 新建文件<br>cat : 三个功能：<br>  1.一次显示整个文件：cat filename<br>  2.创建新文件，不能 编辑已有文件：cat &gt; filename<br>  3.将几个文件合并为一个文件：cat file1 file2 &gt; file<br><code>vi/vim filename</code>表示用vi或vim打开文件，如果不存在该文件则新建文件<br><code>&gt;</code> 是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空；<br><code>&gt;</code> firename 将空装入文件firename，如果没有会自动创建</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月18日Linux专项练习2</title>
      <link href="/exam//b7729f1c/"/>
      <url>/exam//b7729f1c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/b7729f1c/#考点1-vi保存并退出" class="header_1">考点1:vi保存并退出</a>&nbsp;<br><a href="/exam/b7729f1c/#考点2-文件操作的唯一依据" class="header_1">考点2:文件操作的唯一依据</a>&nbsp;<br><a href="/exam/b7729f1c/#考点3-Linux查看物理内存的大小" class="header_1">考点3:Linux查看物理内存的大小</a>&nbsp;<br><a href="/exam/b7729f1c/#考点4-sed命令" class="header_1">考点4:sed命令</a>&nbsp;<br><a href="/exam/b7729f1c/#考点5-死锁的必要条件" class="header_1">考点5:死锁的必要条件</a>&nbsp;<br><a href="/exam/b7729f1c/#考点6-移位运算-十六进制数-幂运算" class="header_1">考点6:移位运算 十六进制数 幂运算</a>&nbsp;<br><a href="/exam/b7729f1c/#考点7-vi保存并退出方法" class="header_1">考点7:vi保存并退出方法</a>&nbsp;<br><a href="/exam/b7729f1c/#考点8-shell系统调用-ls系统调用" class="header_1">考点8:shell系统调用 ls系统调用</a>&nbsp;<br><a href="/exam/b7729f1c/#考点9-firmware分析相关命令" class="header_1">考点9:firmware分析相关命令</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-vi保存并退出"><a href="#考点1-vi保存并退出" class="headerlink" title="考点1:vi保存并退出"></a>考点1:vi保存并退出</h1><p>在Linux系统的vi编辑器中,如果不保存对文件进行的修改,应使用(  )命令强制退出vi编辑器</p><ul><li>A :q</li><li>B :<code>wq</code></li><li>C :q!</li><li>D :!q</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点2-文件操作的唯一依据"><a href="#考点2-文件操作的唯一依据" class="headerlink" title="考点2:文件操作的唯一依据"></a>考点2:文件操作的唯一依据</h1><p>文件操作的唯一依据是？</p><ul><li>A 文件名</li><li>B 文件句柄</li><li>C 物理地址</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>在文件I/O中，要从一个文件读取数据，应用程序首先要调用操作系统函数并传送文件名，并选一个到该文件的路径来打开文件。该函数取回一个顺序号，即文件句柄（file handle），该文件句柄对于打开的文件是唯一的识别依据。要从文件中读取一块数据，应用程序需要调用函数ReadFile，并将文件句柄在内存中的地址和要拷贝的字节数传送给操作系统。当完成任务后，再通过调用系统函数来关闭该文件。</p><p>文件句柄应该是windows的叫法，linux叫文件描述符。</p><h1 id="考点3-Linux查看物理内存的大小"><a href="#考点3-Linux查看物理内存的大小" class="headerlink" title="考点3:Linux查看物理内存的大小"></a>考点3:Linux查看物理内存的大小</h1><p>在 linux 下,如何查看物理内存的大小？ ()</p><ul><li>A <code>cat /dev/mem</code></li><li>B <code>cat /proc/meminfo</code></li><li>C <code>mem</code></li><li>D <code>ps -ef</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>方式一：free<br>直观的展示linux系统内存使用及交换区的容量大小等<br>方式二：top<br>动态实时查看系统中每一个进程的资源使用情况<br>方式三：cat /proc/meminfo<br>方式四：gnome-system-monitor 一个显示最近一段时间内的CPU、内存、交换区及网络使用情况的视图工具。<br>方式五：ps aux –sort -rss<br>各个线程的资源使用情况<br>方式六：vmstat -s<br>vmstat命令显示实时的和平均的统计，覆盖CPU、内存、I/O等内容。</p><h1 id="考点4-sed命令"><a href="#考点4-sed命令" class="headerlink" title="考点4:sed命令"></a>考点4:sed命令</h1><p>以下哪些命令可以打印文件(demo.log)中包含ERP的行到标准输出()</p><ul><li>A <code>sed</code> ‘<code>/ERR/a</code>\’ <code>demo.log</code></li><li>B <code>sed</code> ‘<code>/ERP/p</code>‘ <code>demo.log</code></li><li>C <code>sed</code> ‘<code>/ERP/d</code>‘ <code>demo.log</code></li><li>D <code>sed -n</code> ‘<code>/ERP/p</code>‘ <code>demo.log</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>sed命令用于行的新增/删除, 行的替换/显示, 搜寻并替换, 直接修改文件。<br>-n：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。但如果加上 -n<br>参数后，则只有经过 sed 特殊处理的那一行才会被列出来。<br>p：打印，将某个选择的数据印出来。通常 p 会与参数 sed -n 一起用<br>d:删除<br>a：新增<br>sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。默认情况下，所有的输出行都被打印到屏幕上</p><p>sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。</p><p>然后回到本题中，</p><p> -n 取消默认的输出，从而重定向为ERP输出</p><p>-p 打印行</p><p>最后是filename文件名<br>打印文件（demo.log）中包含ERP的行到标准输出。<br>sed -n ‘/ERP/p’ demo.log<br>sed是非交互式的编辑器。它不会修改文件，除非使用shell重定向来保存结果。<br>-n：使用安静(silent)模式。默认情况下，所有的输出行都被打印到屏幕上。<br>-p：打印，将某个选择的数据印出来。通常 p 会与参数 sed -n 一起用。<br>-d：删除<br>-a：新增</p><p>Vi编辑器中,怎样将字符AAA全部替换成yyy?<br>s/AAA/yyy/g<br>s：取代，通常 s 动作可以搭配正规表示式。例如 1,20s/old/new/g！<br>g：是行内进行全局替换。</p><p>示例：<br>sed ‘s/aaa/bbb/‘  filea   将filea中的第一个aaa替换为bbb；<br>sed ‘s/aaa/bbb/g’  filea  将filea中的所有的aaa替换为bbb。</p><h1 id="考点5-死锁的必要条件"><a href="#考点5-死锁的必要条件" class="headerlink" title="考点5:死锁的必要条件"></a>考点5:死锁的必要条件</h1><p>下面哪些是死锁发生的必要条件？</p><ul><li>A 互斥条件</li><li>B 请求和保持</li><li>C 不可剥夺</li><li>D 循环等待</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>产生死锁的四个必要条件：<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><h1 id="考点6-移位运算-十六进制数-幂运算"><a href="#考点6-移位运算-十六进制数-幂运算" class="headerlink" title="考点6:移位运算 十六进制数 幂运算"></a>考点6:移位运算 十六进制数 幂运算</h1><p>下列表达式值相同的是哪几项()</p><ul><li>A 1<code>&lt;&lt;3</code></li><li>B 0<code>x0F</code> &amp; 0<code>x08</code></li><li>C 2^3(^是幂运算)</li><li>D 3^2(^是幂运算)</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>A. 1左移3位  即1000<br>B. 0000 1111 &amp; 0000 1000  即0000 1000<br>C. 2^3   即8  即1000<br>D. 3^2   即9  即1001<br> ABC值相同</p><h1 id="考点7-vi保存并退出方法"><a href="#考点7-vi保存并退出方法" class="headerlink" title="考点7:vi保存并退出方法"></a>考点7:vi保存并退出方法</h1><p>在Linux系统下,你用vi编辑器对文本文件test.txt进行了修改,想保存对该文件所做的修改并正常退出vi编辑器,可以(   )。</p><ul><li>A 在命令模式下执行<code>ZZ</code>命令</li><li>B 在命令模式下执行<code>WQ</code>命令</li><li>C 在末行模式下执行:q!</li><li>D 在末行模式下执行:<code>wq</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><h1 id="考点8-shell系统调用-ls系统调用"><a href="#考点8-shell系统调用-ls系统调用" class="headerlink" title="考点8:shell系统调用 ls系统调用"></a>考点8:shell系统调用 ls系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p><ul><li>A <code>nmap</code></li><li>B <code>read</code></li><li>C <code>execve</code></li><li>D <code>fork</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>任何shell都会执行 exec 和 fork<br>而    ls会执行read<br>三个加起来</p><h1 id="考点9-firmware分析相关命令"><a href="#考点9-firmware分析相关命令" class="headerlink" title="考点9:firmware分析相关命令"></a>考点9:firmware分析相关命令</h1><p>下面哪些命令和工具对 firmware 分析有帮助？</p><ul><li>A <code>binwalk</code></li><li>B <code>file</code></li><li>C <code>firmware-mod-kit</code></li><li>D <code>netstat</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>Binwalk是用于搜索给定二进制镜像文件以获取嵌入的文件和代码的工具，具体来说，它被设计用于识别嵌入固件镜像内的文件和代码。<br>file命令用来探测给定文件的类型，file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。<br>firmware-mod-kit工具的功能和binwalk工具的类似，其实firmware-mod-kit工具在功能上有调用binwalk工具提供的功能以及其他的固件解包工具的整合。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月18日Linux专项练习4</title>
      <link href="/exam//8e2081b4/"/>
      <url>/exam//8e2081b4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/8e2081b4/#考点1-vi打开文件" class="header_1">考点1:vi打开文件</a>&nbsp;<br><a href="/exam/8e2081b4/#考点2-shell编程if语句" class="header_1">考点2:shell编程if语句</a>&nbsp;<br><a href="/exam/8e2081b4/#考点3-shell脚本变量含义" class="header_1">考点3:shell脚本变量含义</a>&nbsp;<br><a href="/exam/8e2081b4/#考点4" class="header_1">考点4:</a>&nbsp;<br><a href="/exam/8e2081b4/#考点5" class="header_1">考点5:</a>&nbsp;<br><a href="/exam/8e2081b4/#考点6" class="header_1">考点6:</a>&nbsp;<br><a href="/exam/8e2081b4/#考点7" class="header_1">考点7:</a>&nbsp;<br><a href="/exam/8e2081b4/#考点8" class="header_1">考点8:</a>&nbsp;<br><a href="/exam/8e2081b4/#考点9" class="header_1">考点9:</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-vi打开文件"><a href="#考点1-vi打开文件" class="headerlink" title="考点1:vi打开文件"></a>考点1:vi打开文件</h1><p>有一台系统为Linux的计算机,在其当前目录下有一个名为test的文本文件,管理员小张要用vi编辑器打开该文档以查看其中的内容,应使用()命令.</p><ul><li>A <code>opentest</code></li><li>B <code>vi read test</code></li><li>C <code>vi test</code></li><li>D <code>open vi</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点2-shell编程if语句"><a href="#考点2-shell编程if语句" class="headerlink" title="考点2:shell编程if语句"></a>考点2:shell编程if语句</h1><p><code>if [ $2 -a $2 = &quot;test&quot; ]</code>中 -a是什么意思 </p><ul><li>A 大于</li><li>B 减</li><li>C 全部</li><li>D 并且</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>-a 是shell中的布尔运算符，表示与运算</p><h1 id="考点3-shell脚本变量含义"><a href="#考点3-shell脚本变量含义" class="headerlink" title="考点3:shell脚本变量含义"></a>考点3:shell脚本变量含义</h1><p>在RHEL5统中,”run.sh”是Shell执行脚本,在执行<code>./run.sh file1 file2 file3</code>命令的过程中,变量$1的值为(   )</p><ul><li>A <code>run.sh</code></li><li>B <code>file1</code></li><li>C <code>file2</code></li><li>D <code>file3</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">linux中shell变量$#,$@,$0,$1,$2的含义解释: </span><br><span class="line">变量说明: </span><br><span class="line">$$ </span><br><span class="line">Shell本身的PID（ProcessID） </span><br><span class="line">$! </span><br><span class="line">Shell最后运行的后台Process的PID </span><br><span class="line">$? </span><br><span class="line">最后运行的命令的结束代码（返回值） </span><br><span class="line">$- </span><br><span class="line">使用Set命令设定的Flag一览 </span><br><span class="line">$* </span><br><span class="line">所有参数列表。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。 </span><br><span class="line">$@ </span><br><span class="line">所有参数列表。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。 </span><br><span class="line">$# </span><br><span class="line">添加到Shell的参数个数 </span><br><span class="line">$0 </span><br><span class="line">Shell本身的文件名 </span><br><span class="line">$1～$n </span><br><span class="line">添加到Shell的各参数值。$1是第1参数、$2是第2参数…</span><br></pre></td></tr></table></figure><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4:"></a>考点4:</h1><p>采用多路复用I/O监听3个套接字的数据时,如果套接字描述符分别是:5,17,19,则<br>select(int maxfd,struct fd_set* rdset,NULL,NULL)<br>中的maxfd应取为()</p><ul><li>A 4</li><li>B 20</li><li>C 5</li><li>D 9</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>Maxfd是三个套接字描述符中最大数字加上1</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>具有很多C语言的功能,又称过滤器的是？</p><ul><li>A <code>Csh</code></li><li>B <code>tcsh</code></li><li>C <code>awk</code></li><li>D <code>sed</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>在OSI模型中,HTTP协议工作在第()层,交换机工作在第()层。</p><ul><li>A 7/1</li><li>B 7/2</li><li>C 6/3</li><li>D 6/2</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><a href="https://m.nowcoder.com/questions?tagId=43719192&amp;type=1&amp;source=intelli&amp;pos=1" target="_blank" rel="noopener">https://m.nowcoder.com/questions?tagId=43719192&amp;type=1&amp;source=intelli&amp;pos=1</a></p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7:"></a>考点7:</h1><p>查看TCP连接的命令是什么？</p><ul><li>A <code>tcpdump</code></li><li>B <code>top</code></li><li>C <code>netstat</code></li><li>D <code>ifconfig</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>netstat -at    #列出所有tcp端口<br>netstat -lt    #只列出所有监听 tcp 端口<br>netstat -st    #显示TCP端口的统计信息</p><p>ifconfig是linux中用于显示或配置网络设备(网络接口卡)的命令，英文全称是network interfaces<br>configuring。配置网卡的IP地址语法例:ifconfig eth0 192.168.0.1 netmask<br>255.255.255.0.ifconfig可设置网络设备的状态，或是显示当前的设置。</p><p>tcpdump是网络监控工具<br>tcpdump：<br>将网络中传送的数据包完全截获下来以供分析。<br>它支持针对网络层、协议、主机、网络或端口的过滤；并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8:"></a>考点8:</h1><p>在重新启动Linux系统的同时把内存中的信息写入硬盘,应使用()命令实现</p><ul><li>A #<code>shutdown -r now</code></li><li>B #<code>halt</code></li><li>C #<code>reboot</code></li><li>D #<code>init3</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>在linux命令中reboot是重新启动，shutdown -r<br>now是立即停止然后重新启动，都说他们两个是一样的，其实是有一定的区别的。<br>shutdown命令可以安全地关闭或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。<br>精确时间的格式是hh:mm，表示小时和分钟，时间段由+ 和分钟数表示。系统执行该命令后会自动进行数据同步的工作。<br>该命令的一般格式: shutdown [选项] [时间] [警告信息]<br>命令中各选项的含义为:</p><ul><li>k 并不真正关机而只是发出警告信息给所有用户</li><li>r 关机后立即重新启动</li><li>h 关机后不重新启动</li><li>f 快速关机重启动时跳过fsck</li><li>n 快速关机不经过init 程序</li><li>c 取消一个已经运行的shutdown<br>需要特别说明的是该命令只能由超级用户使用。<br>例1，系统在十分钟后关机并且马上重新启动: # shutdown –r +10<br>例2，系统马上关机并且不重新启动:# shutdown –h now<br>halt是最简单的关机命令，其实际上是调用shutdown<br>-h命令。halt执行时，杀死应用进程，文件系统写操作完成后就会停止内核。<br>halt命令的部分参数如下：<br>[-f] 没有调用shutdown而强制关机或重启<br>[-i] 关机或重新启动之前，关掉所有的网络接口<br>[-p] 关机时调用poweroff，此选项为缺省选项<br>reboot的工作过程与halt类似，其作用是重新启动，而halt是关机。其参数也与halt类似。reboot命令重启动系统时是删除所有的进程，而不是平稳地终止它们。因此，使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的丢失。所以使用reboot命令的场合主要是在单用户模式。<br>init是所有进程的祖先，其进程号始终为1。init用于切换系统的运行级别，切换的工作是立即完成的。init<br>0命令用于立即将系统运行级别切换为0，即关机；init 6命令用于将系统运行级别切换为6，即重新启动</li></ul><p>shutdown：  这个命令会通知系统内的各个进程，并通知关闭一些服务。<br>shutdown -h now 立刻关机                      常用<br>shutdown -h 20:25 指定关机的时间<br>shutdown -h +10  10分钟后关机<br>shutdown -r now 系统立刻重启<br>shutdown -r +30 ‘the system will reboot’  显示题是信息给所有在线用户<br>shutdown -k now ‘system will reboot’  仅仅发出要重新启动的信息，而不会关机或者重启</p><p>reboot ： 删除所有进程，不平稳终止。 ‘sync；sync；sync；reboot’  </p><p>halt： 不理会目前系统状态，执行硬件关机。</p><p>init： 用于切换系统的运行级别，切换的工作是立即完成的。<br>init 0 关机<br>init 3 命令行模式<br>Init5 含有图形界面<br>init 4重启</p><p>理论上reboot适合于单用户的时候也是对的<br>init0 = 关机<br>init6= 重启</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>Linux的可执行文件开头的特征字符串是什么</p><ul><li>A <code>PE</code></li><li>B <code>MZ</code></li><li>C <code>ELF</code></li><li>D <code>LNX</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Executable Linkable File 可执行可链接文件</p><p>vi编辑器里面如何删除最后一行？<br>A<br>G;d<br>B<br>G;dd<br>C<br>A;dd<br>D<br>A;d<br>正确答案: B</p><p>gg到顶部；G = shift + g到底部。</p><p>vi编辑器一般模式下：<br>G：光标移到最后一行<br>dd：删除一行<br>shift+G 到底部，dd删除行</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月18日Linux专项练习5</title>
      <link href="/exam//f927b122/"/>
      <url>/exam//f927b122/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f927b122/#考点1-Linux开发者" class="header_1">考点1:Linux开发者</a>&nbsp;<br><a href="/exam/f927b122/#考点2-Linux-pagefault" class="header_1">考点2:Linux pagefault</a>&nbsp;<br><a href="/exam/f927b122/#考点3-Linux文件去重并排序" class="header_1">考点3:Linux文件去重并排序</a>&nbsp;<br><a href="/exam/f927b122/#考点4-自定义DNS解析" class="header_1">考点4:自定义DNS解析</a>&nbsp;<br><a href="/exam/f927b122/#考点5-tar解压缩到指定目录：tar-xvzf-压缩包-C-目的目录" class="header_1">考点5:tar解压缩到指定目录：tar -xvzf 压缩包 -C 目的目录</a>&nbsp;<br><a href="/exam/f927b122/#考点6" class="header_1">考点6:</a>&nbsp;<br><a href="/exam/f927b122/#考点7-chmod修改文件权限" class="header_1">考点7:chmod修改文件权限</a>&nbsp;<br><a href="/exam/f927b122/#考点8-chmod修改文件权限" class="header_1">考点8:chmod修改文件权限</a>&nbsp;<br><a href="/exam/f927b122/#考点9-删除非目录的方法" class="header_1">考点9:删除非目录的方法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux开发者"><a href="#考点1-Linux开发者" class="headerlink" title="考点1:Linux开发者"></a>考点1:Linux开发者</h1><p>Linux 最早是由一位名叫( )的计算机爱好者开放。</p><ul><li>A <code>Richard Petersen</code></li><li>B <code>Linus Torvalds</code></li><li>C <code>Rob Pike</code></li><li>D <code>Linus Sarwar</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>李纳斯·脱袜子</p><h1 id="考点2-Linux-pagefault"><a href="#考点2-Linux-pagefault" class="headerlink" title="考点2:Linux pagefault"></a>考点2:Linux pagefault</h1><p>Linux什么情况下回发生page fault;</p><ul><li>A 系统可用内存不够时</li><li>B 所需访问虚拟内存未被装载</li><li>C 当开始进行<code>swap</code>交换时</li><li>D 当进程被挂起时</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>影响一个应用程序性能的因素有很多，这次说说page fault。</p><ol><li>为什么会存在page fault问题？<br>计算机的物理内存（看看你的内存条）有限，一般现在都是几个GB的容量了，BTW，我的笔记本有8GB，:-)。<br>但应用程序的需求是无限的，操作系统为了解决这个矛盾，使用了虚拟内存的设计。简单的描述就是，给应用程序<br>一个与物理内存无关的虚拟地址空间，并提供一套映射机制，将虚拟地址映射到物理内存。当然应用程序是不知道<br>有这个映射机制存在的，他唯一需要做的就是尽情的使用自己的虚拟地址空间。操作系统提供的映射机制是<br>运行时动态进行虚拟地址和物理地址之间的映射的，当一个虚拟地址没有对应的物理内存时候，<br>映射机制就分配物理内存，构建映射表，满足应用程序的需求，这个过程就叫page fault。<br>与直接访问物理内存不同，page fault过程大部分是由软件完成的，消耗时间比较久，所以是影响性能的一个关键指标。<br>Linux把page fault又进一步分为minor page fault和major page<br>fault。前面提到的分配物理内存，构建映射表过程可以看做是<br>minor page fault。major page<br>fault是由swap机制引入的，对于swap情况，地址映射好了后，还需要从外部存储读取数据，这个<br>过程涉及到IO操作，耗时更久。</li><li>如何查看应用程序的page fault指标呢？<br>1） 可以使用time命令：<br>  比如我想看看svm-train的情况（模型训练很耗资源）\time svm-train<br>age_train_equal.txt（前面的斜杠表示不使用shell的内嵌time命令）<br>输出是：7.68user 0.02system 0:07.71elapsed 99%CPU (0avgtext+0avgdata<br>42768maxresident)k<pre><code>       0inputs+6696outputs (0major+15445minor)pagefaults</code></pre>0swaps<br>可以看到只有minor page fault，没有major。<br>time命令的实现是用到了Linux提供的rusage机制。Linux的wait API可以返回一个应用程序的运行过程的资源消耗情况。<br>如果你想在自己的代码中获取资源利用情况，可以使用libc的getrusage函数，这个函数也是内核的API。<br>2） proc文件系统<br>Linux系统下的/proc/PID/stat文件，也提供了相关统计数据。<br>转自： <a href="http://www.cnblogs.com/cornsea/archive/2012/12/17/2821429.html" target="_blank" rel="noopener">http://www.cnblogs.com/cornsea/archive/2012/12/17/2821429.html</a></li></ol><h1 id="考点3-Linux文件去重并排序"><a href="#考点3-Linux文件去重并排序" class="headerlink" title="考点3:Linux文件去重并排序"></a>考点3:Linux文件去重并排序</h1><p>以下哪个命令可实现文件去重并排序:</p><ul><li>A <code>uniq demo.txt</code></li><li>B <code>sort demo.txt</code></li><li>C <code>uniq demo.txt|sort</code></li><li>D <code>sort demo.txt|uniq</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点4-自定义DNS解析"><a href="#考点4-自定义DNS解析" class="headerlink" title="考点4:自定义DNS解析"></a>考点4:自定义DNS解析</h1><p>当内网内没有条件建立dns服务器,又不想用IP访问网站,应配置什么文件</p><ul><li>A <code>hosts</code></li><li>B <code>sysconfig</code></li><li>C <code>network</code></li><li>D <code>hostname</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。</p><p>hosts文件在/etc/hosts下。<br>既然看到/etc/了，兄弟萌一起来回顾下/etc/目录下的一些文件的作用吧！！！<br>/etc/resolv.conf 是DNS配置文件。在网卡配置文件中进行配置，默认情况下 网卡配置文件DNS优先于/etc/resolv.conf。<br>/etc/hostname 在Centos 7，配置主机名，查看修改。<br>/etc/hosts ip与域名对应关系 ，解析域名（主机名），用/etc/hosts搭建网站的测试环境 (虚拟机)。不同服务器之间相互访问。<br>/etc/gateways 设置路由器<br>/etc/fstab file system table ：文件系统挂载表，开机的时候设备与入口对应关系 开机自动挂载列表。<br>/etc/rc.local 开机自启<br>/etc/inittab（centos 6）运行级别的配置文件<br>/etc/profile 环境变量配置文件<br>/etc/bashrc 命令别名<br>/etc/motd 文件中的内容 会在用户登录系统之后显示出来<br>/etc/issue /etc/issue.net 文件中的内容 会在用户登录系统之前显示出来</p><h1 id="考点5-tar解压缩到指定目录：tar-xvzf-压缩包-C-目的目录"><a href="#考点5-tar解压缩到指定目录：tar-xvzf-压缩包-C-目的目录" class="headerlink" title="考点5:tar解压缩到指定目录：tar -xvzf 压缩包 -C 目的目录"></a>考点5:tar解压缩到指定目录：tar -xvzf 压缩包 -C 目的目录</h1><p>为了将当前目录下的归档文件myftp. tgz解压缩到/tmp目录下,用户可以使用命令</p><ul><li>A <code>tar xvzf myftp. tgz</code> –<code>C /tmp</code></li><li>B <code>tar  xvzf  myftp. tgz</code> –<code>R /tmp</code></li><li>C <code>tar vzf myftp. tgz</code> –<code>X /tmp</code></li><li>D <code>tar xvzf myftp. tgz /tmp</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>tar命令中<br>-x：extract files from an archive即从归档文件中释放文件；<br>-v：verbosely list files processed即详细列出要处理的文件；<br>-z：filter the archive through gzip即通过gzip解压文件；<br>-f：use archive file or device ARCHIVE即使用档案文件或设备；<br>通常情况下解压.tar.gz和.tgz等格式的归档文件就可以直接使用tar xvzf；<br>因为要解压到指定目录下，所以还应在待解压文件名后加上-C（change to directory）参数</p><p>tar 配合压缩解压缩常用用法</p><h3 id="tar压缩"><a href="#tar压缩" class="headerlink" title="tar压缩"></a>tar压缩</h3><p>tar -cvzf 打包文件名 打包文件集</p><h3 id="tar解压缩"><a href="#tar解压缩" class="headerlink" title="tar解压缩"></a>tar解压缩</h3><p>tar -xvzf 需要解包的文件名 -C 解压路径.</p><p>x解压<br>z表示gz压缩文件<br>v显示过程<br>f指定的文件</p><p>-C指定位置</p><p>-c: 建立新的备份文件<br>-t:列出备份文件的内容<br>-x:从备份文件中还原文件<br>-z:通过gzip指令处理备份文件<br>-v:显示指令执行过程<br>-f:指定压缩或解压文件</p><pre>touch a.c  &#35; 压缩 a.c文件为test.tar.gz a.ctar -czvf test.tar.gz a.c   &#35; 列出压缩文件内容tar -tzvf test.tar.gz&#35; 解压文件tar -xzvf test.tar.gz-C（change to directory）参数</pre><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6:"></a>考点6:</h1><p>设定linux系统默认为字符模式,需要修改的配置文件是( )</p><ul><li>A <code>/etc/fstab</code></li><li>B <code>/etc/inittab</code></li><li>C <code>/etc/boot</code></li><li>D <code>/etc/inittab.conf</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>etc/inittab 最后一行是运行等级，我的是centos6.5，默认是5，即图形化界面，将5修改为3后，则默认的启动模式将由图形化界面变为纯字符的命令行模式。两者之间也可以通过键盘组合键来转换，ctrl+alt+F2切换到纯字符，alt+F2切换成图形化界面。</p><p>把id:5:initdefault中5修改3， </p><h3 id="Linux下有7个运行级别"><a href="#Linux下有7个运行级别" class="headerlink" title="Linux下有7个运行级别"></a>Linux下有7个运行级别</h3><p>0系统停机模式，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。<br>1单用户模式，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br>2多用户模式，没有NFS网络支持。<br>3完整的多用户文本模式，有NFS，登陆后进入控制台命令行模式。<br>4系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。 5图形化模式，登陆后进入图形GUI模式，X Window系统。<br>6重启模式，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。</p><h1 id="考点7-chmod修改文件权限"><a href="#考点7-chmod修改文件权限" class="headerlink" title="考点7:chmod修改文件权限"></a>考点7:chmod修改文件权限</h1><p>文件目录data当前权限为<code>rwx------</code>,只需要增加用户组可读可执行权限,但不允许写操作,具体方法为:</p><ul><li>A <code>chmod +050 data</code></li><li>B <code>chmod +040 data</code></li><li>C <code>chmod +005 data</code></li><li>D <code>chmod +004 data</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>对目录来说只有（r）权限是无法进入的，还要赋予执行权限（x）</p><h1 id="考点8-chmod修改文件权限"><a href="#考点8-chmod修改文件权限" class="headerlink" title="考点8:chmod修改文件权限"></a>考点8:chmod修改文件权限</h1><p>文件exer1的访问权限为<code>rw-r--r--</code> ,现要增加所有用户的执行权限和同组用户的写权限,下列命令正确的是</p><ul><li>A <code>chmod a+x,g+w exer1</code></li><li>B <code>chmod 775 exer1</code></li><li>C <code>chmod o+x exer1</code></li><li>D <code>chmod g+w exer1</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details><p>u-g-o：表示用户-用户组-其他用户。<br>a : 表示所有 用户，<br>x : 执行权限，r：读权限，w：写权限。<br>A： a+x = 增加所有用户的执行权限；g+w = 同组用户的写权限，正确；<br>B：由于文件exer1 刚开始的访问权限为<br>rw-  r—  r—，<br>所有用户加上执行权限变为：rwx   r-x  r-x<br>同组用户加上写权限变为：rwx rwx r-x = 775（4-2-1表示r-w-x）。正确。</p><h1 id="考点9-删除非目录的方法"><a href="#考点9-删除非目录的方法" class="headerlink" title="考点9:删除非目录的方法"></a>考点9:删除非目录的方法</h1><p>Linux的非root用户,在自己的目录中,不可以删除非空目录dirs的方法是:</p><ul><li>A <code>rm dir dirs</code></li><li>B <code>rm -r dirs</code></li><li>C <code>mv dirs /dev/null</code></li><li>D <code>destroy dirs</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月18日Linux专项练习1</title>
      <link href="/exam//fe4a753b/"/>
      <url>/exam//fe4a753b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/fe4a753b/#考点1-Linux文件权限" class="header_1">考点1:Linux文件权限</a>&nbsp;<br><a href="/exam/fe4a753b/#考点2-cp-f命令" class="header_1">考点2:cp -f命令</a>&nbsp;<br><a href="/exam/fe4a753b/#考点3-Vsftpd配置" class="header_1">考点3:Vsftpd配置</a>&nbsp;<br><a href="/exam/fe4a753b/#考点4-Linux命令返回直含义" class="header_1">考点4:Linux命令返回直含义</a>&nbsp;<br><a href="/exam/fe4a753b/#考点5" class="header_1">考点5:</a>&nbsp;<br><a href="/exam/fe4a753b/#考点6-UNIX系统代码段和数据段分开的目的" class="header_1">考点6:UNIX系统代码段和数据段分开的目的</a>&nbsp;<br><a href="/exam/fe4a753b/#考点7-dvm进程和Linux进程" class="header_1">考点7:dvm进程和Linux进程</a>&nbsp;<br><a href="/exam/fe4a753b/#考点8-线程" class="header_1">考点8:线程</a>&nbsp;<br><a href="/exam/fe4a753b/#考点9-进程通讯方式" class="header_1">考点9:进程通讯方式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux文件权限"><a href="#考点1-Linux文件权限" class="headerlink" title="考点1:Linux文件权限"></a>考点1:Linux文件权限</h1><p>在linux文件系统权限中(rwx),只读权限对应的数值为()</p><ul><li>A 4</li><li>B 2</li><li>C 1</li><li>D 选项均不正确</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>“4=r,2=w,1=x”<br>r 代表读，w 代表写，x 代表执行，<br>如果可读，权限是二进制的100，十进制是4；<br>如果可写，权限是二进制的010，十进制是2；<br>如果可运行，权限是二进制的001，十进制是1</p><h1 id="考点2-cp-f命令"><a href="#考点2-cp-f命令" class="headerlink" title="考点2:cp -f命令"></a>考点2:cp -f命令</h1><p>cp拷贝命令的-f参数含义为?</p><ul><li>A 拷贝目录</li><li>B 递归处理</li><li>C 显示执行过程</li><li>D 强制进行拷贝</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>-r ：recursive，递归处理<br>-v ：verbose，显示详细过程<br>-f ：force，强制执行，多用于覆盖拷贝。无论目的目录是否有同名文件，强制复制</p><p>cp：将一个或多个源文件或者目录复制到指定的文件或目录。<br>选项：<br>-a：与”-dpR”相同<br>-d：当复制符号链接时，把目标文件或目录也建立为符号链接，并指向与源文件或目录连接的原始文件或目录<br>-f：强行复制文件或目录，不论是否存在<br>-i：覆盖既有文件前先询问用户<br>-l：对源文件建立硬链接，而非复制文件<br>-p：保留源文件或目录的属性<br>-R/r：递归处理指定目录与子目录<br>-s：对源文件建立符号链接，而非复制文件<br>-u：只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在才复制文件<br>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件默认后缀<br>-b：覆盖已经存在的文件目标前将目标文件备份<br>-v：详细显示命令执行的操作</p><p>举个栗子：<br>将文件jieni复制到usr/tmp下，并改名为pika<br>cp jieni /usr/tmp/pika</p><p>将目标/usr/jieni下所有文件复制到/usr/pika<br>cp /usr/jieni /usr/pika</p><p>交互式方式（询问）将目录/usr/jieni中a开头的所有.c文件复制到/usr/pika中<br>cp -i /usr/jieni a*.c /usr/pika</p><h1 id="考点3-Vsftpd配置"><a href="#考点3-Vsftpd配置" class="headerlink" title="考点3:Vsftpd配置"></a>考点3:Vsftpd配置</h1><p>Vsftpd 配置本地用户传输速率的参数？</p><ul><li>A <code>Local _max_rate</code></li><li>B <code>anon _max_rate</code></li><li>C <code>user _max_rate</code></li><li>D <code>max_user</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。<br>local_max_rate=0 实体用户的传输速度限制，单位为bytes/second， 0 为不限制。</p><h3 id="Vsftpd-配置"><a href="#Vsftpd-配置" class="headerlink" title="Vsftpd 配置"></a>Vsftpd 配置</h3><h4 id="local-max-rate-0："><a href="#local-max-rate-0：" class="headerlink" title="local_max_rate=0："></a>local_max_rate=0：</h4><p>本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0。</p><h4 id="anon-max-rate-0"><a href="#anon-max-rate-0" class="headerlink" title="anon_max_rate=0"></a>anon_max_rate=0</h4><p>：<br>设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。</p><h1 id="考点4-Linux命令返回直含义"><a href="#考点4-Linux命令返回直含义" class="headerlink" title="考点4:Linux命令返回直含义"></a>考点4:Linux命令返回直含义</h1><p>linux命令执行成功后会返回</p><ul><li>A 0</li><li>B 1</li><li>C 2</li><li>D -1</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5:"></a>考点5:</h1><p>你在一台Windows 2000 Server 上部署了几个web 站点,这些Web 站点都已启用了日志。你用一个第三方的报表工具来分析web站点产生的日志文件,你发现所有从上午7:00到午夜的数据都被包含在第二天的日志文件中。你希望这些数据包含在当天的日志文件中,你该怎么做？</p><ul><li>A 确保日志类型被设置为<code>W3C</code></li><li>B 在<code>web</code>站点的日志属性中修改日志翻转属性</li><li>C 在<code>web</code>服务器的时间属性中修改时间区域设置</li><li>D 在<code>web</code>服务器上配置时间服务器使用<code>LocalSystem</code>账户</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点6-UNIX系统代码段和数据段分开的目的"><a href="#考点6-UNIX系统代码段和数据段分开的目的" class="headerlink" title="考点6:UNIX系统代码段和数据段分开的目的"></a>考点6:UNIX系统代码段和数据段分开的目的</h1><p>关于UNIX系统代码段和数据段分开的目的,错误的说法有()。</p><ul><li>A 可共享正文</li><li>B 可共享数据</li><li>C 可重入</li><li>D 可保护代码为只读</li><li>E 方便编程</li><li>F 更好支持内存回收策略</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: E</details>1）防止程序指令被修改，设置代码段权限为只读，设置数据段权限为可读写  2）代码段和数据段分开有利于提高程序的局部性，现代CPU缓存一般设计为数据缓存和指令缓存分离，指令和数据分开存放可以提高CPU缓存命中率。3）共享指令，当系统运行多个程序的副本时，它们指令时一样的，因此内存只需保存一份程序的指令代码。每个副本进程的数据区是进程私有，可以节省内存。1）代码段：代码段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。2）数据段：数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。3）BSS段：BSS段包含了程序中未初始化的全局变量，在内存中 bss段全部置零。4）堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）它的物理内存空间是由程序申请的，并由程序负责释放。5）栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。实际上,在Linux系统下并没有强调分段,每个进程缺省情况下“数据段”，“堆栈段”和“代码段”都使用等价的段描述,映射到相同的线性地址空间,除非你个别设置LDT.# 考点7:dvm进程和Linux进程下面关于andriod dvm的进程和Linux的进程,应用程序的进程说法正确的是- A `DVM`指`dalivk`的虚拟机,每一个`Andriod`应用程序都在它自己的进程中运行,都拥有一个独立的`Dalivk`虚拟机实例,而每一个`DVM`不一定都是在`Linux`中的一个进程,所以说不是一个概念- B `DVM`指`dalivk`的虚拟机,每一个`Andriod`应用系统程序都在它自己的进程中运行,不一定拥有一个独立的`Dalivk`虚拟机实例,而每一个`DVM`都是在`Linux`中的一个进程,所以说可以认为是同一个概念- C `DVM`指`dalivk`的虚拟机,每一个`Andriod`应用系统程序都在它自己的进程中运行,不一定拥有一个独立的`Dalivk`虚拟机实例,而每一个`DVM`不一定都是在`Linux`中的一个进程,所以说不是一个概念- D `DVM`指`dalivk`的虚拟机,每一个`Andriod`应用程序都在它自己的进程中运行,都拥有一个独立的`Dalivk`虚拟机实例,而每一个`DVM`都是在`Linux`中的一个进程,所以说可以认为是同一个概念## 解析<details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Android系统用的就是Linux的内核，DVM可以理解成在Linux上跑的程序，每个应用程序运行时，都会启动一个DVM实例，也就是一个Linux的进程，因此DVM进程和Linux进程实际上是一回事。</p><h1 id="考点8-线程"><a href="#考点8-线程" class="headerlink" title="考点8:线程"></a>考点8:线程</h1><p>下面说法哪个正确的:</p><ul><li>A 各个线程拥有相同的堆栈</li><li>B i++是线程安全的,不需要同步</li><li>C <code>x=y</code>是线程安全的,不需要同步</li><li>D 对进程来说,其虚拟内存的大小不受物理内存大小的限制</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>线程有自己的栈，但没有堆所以A错。普通整数的一般赋值、增量和减量语句会产生多条机器指令，操作均不具有原子性，需要同步，BC错。虚拟存储器具有请求调入和置换功能，所以虚拟内存的大小不受物理内存大小的限制。D对。</p><h1 id="考点9-进程通讯方式"><a href="#考点9-进程通讯方式" class="headerlink" title="考点9:进程通讯方式"></a>考点9:进程通讯方式</h1><p>进程之间通信都有哪些方式？</p><ul><li>A 共享内存</li><li>B 消息传递</li><li>C 系统管道</li><li>D 临界区</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月18日Linux专项练习3</title>
      <link href="/exam//c075af8a/"/>
      <url>/exam//c075af8a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c075af8a/#考点1-八进制文件权限" class="header_1">考点1:八进制文件权限</a>&nbsp;<br><a href="/exam/c075af8a/#考点2-具有c语言功能的过滤器" class="header_1">考点2:具有c语言功能的过滤器</a>&nbsp;<br><a href="/exam/c075af8a/#考点3-shell编程赋值语句" class="header_1">考点3:shell编程赋值语句</a>&nbsp;<br><a href="/exam/c075af8a/#考点4-gcc生成调试信息" class="header_1">考点4:gcc生成调试信息</a>&nbsp;<br><a href="/exam/c075af8a/#考点5-useradd创建用户时不指定用户主目录" class="header_1">考点5:useradd创建用户时不指定用户主目录</a>&nbsp;<br><a href="/exam/c075af8a/#考点6-POSIX线程同步方式" class="header_1">考点6:POSIX线程同步方式</a>&nbsp;<br><a href="/exam/c075af8a/#考点7-subnet命令" class="header_1">考点7:subnet命令</a>&nbsp;<br><a href="/exam/c075af8a/#考点8-subnet命令" class="header_1">考点8:subnet命令</a>&nbsp;<br><a href="/exam/c075af8a/#考点9-vsftpd服务流量控制的参数" class="header_1">考点9:vsftpd服务流量控制的参数</a>&nbsp;<br><a href="/exam/c075af8a/#考点10" class="header_1">考点10:</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-八进制文件权限"><a href="#考点1-八进制文件权限" class="headerlink" title="考点1:八进制文件权限"></a>考点1:八进制文件权限</h1><p>在Linux中,file.sh文件的权限为<code>-rw-r--r-x</code>,其对应权限用数值形式表示为()</p><ul><li>A 775</li><li>B 745</li><li>C 645</li><li>D 643</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Linux权限中，第一个指是否是目录，后面根据rwx形式对拥有者，所属组，其他分别授权，-rw-r—r-x即为110,100,101，转换成十进制就是645</p><h1 id="考点2-具有c语言功能的过滤器"><a href="#考点2-具有c语言功能的过滤器" class="headerlink" title="考点2:具有c语言功能的过滤器"></a>考点2:具有c语言功能的过滤器</h1><p>具有很多C语言的功能,又称过滤器的是？</p><ul><li>A <code>Csh</code></li><li>B <code>tcsh</code></li><li>C <code>awk</code></li><li>D <code>sed</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>sed awk grep ,linux文本处理三剑客<br>csh:调用 C shell。<br>Tcsh是csh的增强版，并且完全兼容csh。它不但具有csh的全部功能，还具有命令行编辑、拼写校正、可编程字符集、历史纪录、作业控制等功能，以及C语言风格的语法结构。<br>AWK是一种优良的文本处理工具，Linux及Unix环境中现有的功能最强大的数据处理引擎之一,AWK 提供了极其强大的功能：可以进行样式装入、流控制、数学运算符、进程控制语句甚至于内置的变量和函数。<br>sed:Stream EDitor</p><h1 id="考点3-shell编程赋值语句"><a href="#考点3-shell编程赋值语句" class="headerlink" title="考点3:shell编程赋值语句"></a>考点3:shell编程赋值语句</h1><p>在bash中,下列哪些语句是赋值语句？()</p><ul><li>A <code>a$=&quot;test&quot;</code></li><li>B <code>$a$=&quot;test&quot;</code></li><li>C <code>a=&quot;test&quot;</code></li><li>D <code>$a=&quot;test&quot;</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>bash中有两个内置的命令declare 和 typeset 可用于创建变量。除了使用内置命令来创建和设置变量外，还可以直接赋值，格式为：变量名=变量值<br> 注意：变量名前面不应加美元“$”符号。（和PHP不同）<br> 等号“=”前后不可以有空格。<br> Shell中不需要显式的语法来声明变量。<br> 变量名不可以直接和其他字符相连，如果想相连，必须用括号： echo “this is $(he)llo!”</p><h1 id="考点4-gcc生成调试信息"><a href="#考点4-gcc生成调试信息" class="headerlink" title="考点4:gcc生成调试信息"></a>考点4:gcc生成调试信息</h1><p>若基于Linux操作系统所开发的ARM应用程序源文件名为test.c,那么要生成该程序代码的调试信息,编译时使用的GCC命令正确的是?</p><ul><li>A <code>arm-linux-gcc -c -o test.o test.c</code></li><li>B <code>arm-linux-gcc -S -o test.o test.c</code></li><li>C <code>arm-linux-gcc -o test test.c</code></li><li>D <code>arm-linux-gcc -g -o test test.c</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>-o参数用于指定输出的文本，如果不指定输出文件则默认输出.out文件<br>-c参数将对源程序test.c进行预处理、编译、汇编操作，生成test.o文件<br>-S参数将对源程序test.c进行预处理、编译，生成test.s文件<br>-g选项，加入GDB能够使用的调试信息,使用GDB调试时比较方便</p><h1 id="考点5-useradd创建用户时不指定用户主目录"><a href="#考点5-useradd创建用户时不指定用户主目录" class="headerlink" title="考点5:useradd创建用户时不指定用户主目录"></a>考点5:useradd创建用户时不指定用户主目录</h1><p>创建用户时不指定用户主目录的参数(      )</p><ul><li>A <code>useradd -o</code></li><li>B <code>useradd -m</code></li><li>C <code>useradd -M</code></li><li>D <code>useradd -d</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点6-POSIX线程同步方式"><a href="#考点6-POSIX线程同步方式" class="headerlink" title="考点6:POSIX线程同步方式"></a>考点6:POSIX线程同步方式</h1><p>POSIX线程同步方式包括:(      )</p><ul><li>A <code>POSIX</code>信号量</li><li>B 互斥锁</li><li>C 条件变量</li><li>D 临界区</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。</p><p>首先说POSIX：可移植操作系统接口，就是定义了一些操作系统该为程序提供的接口标准。<br>再然后说线程同步方式：</p><ul><li>互斥锁</li><li>条件变量</li><li>读写锁</li><li>信号</li><li></li></ul><h1 id="考点7-subnet命令"><a href="#考点7-subnet命令" class="headerlink" title="考点7:subnet命令"></a>考点7:subnet命令</h1><p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnet 166.173.197.131 netmask 255.255.255.192&#123;</span><br><span class="line">range 166.173.197.10 166.173.197.107;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>表示？()</p><ul><li>A 向166.173.197.10网络分配从166.173.197.133到166.173.197.255</li><li>B 一个两小时的最大租用时间</li><li>C 指定了一个十分钟的缺省租用时间</li><li>D 网络地址166.173.197.0</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><h1 id="考点8-subnet命令"><a href="#考点8-subnet命令" class="headerlink" title="考点8:subnet命令"></a>考点8:subnet命令</h1><p>Linux 系统中DHCP 服务器的服务程序是dhcpd,配置文件是dhcpd.conf,如果在该配置文件中包括如下配置内容:<br>Subnet 192.168.2.0 netmask 255.255.255.0 {<br>range 192.168.2.100 192.168.2.200 ;<br>}<br>关于以上配置内容,说法正确的是( )多选</p><ul><li>A 对子网”192.168.2.0/16”中的主机进行动态地址分配</li><li>B 对子网”192.168.2.0/24”中的主机进行动态地址分配</li><li>C 在子网中用于动态分配的<code>IP</code> 地址数量为100 个</li><li>D 在子网中用于动态分配的<code>IP</code> 地址数量为101 个</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details><p>A类的默认子网掩码 255.0.0.0<br>B类的默认子网掩码 255.255.0.0<br>C类的默认子网掩码 255.255.255.0</p><p>16位是B类，B类IP地址的前面6位表示网络地址，后16位表示主机地址，B类IP地址前面开头的数字范围是128—191</p><p>24位是C类，标准的C类地址的确是24位的子网掩码，但是为了更好的饿使用IP地址，采用了一种技术叫VLSM的。<br>题目的前面开头是192，所以是C类地址，所以24位表示主机地址。所以是／24</p><h1 id="考点9-vsftpd服务流量控制的参数"><a href="#考点9-vsftpd服务流量控制的参数" class="headerlink" title="考点9:vsftpd服务流量控制的参数"></a>考点9:vsftpd服务流量控制的参数</h1><p>vsftpd服务流量控制的参数( )</p><ul><li>A <code>system_max_rate</code></li><li>B <code>local_max_rate</code></li><li>C <code>anon_max_rate</code></li><li>D <code>guest_max_rate</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>访问速率设置：<br>anon_max_rate=0<br>设置匿名登入者使用的最大传输速度，单位为B/s，0 表示不限制速度。默认值为0。<br>local_max_rate=0<br>本地用户使用的最大传输速度，单位为B/s，0 表示不限制速度。预设值为0</p><p>vsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、 HP-UNIX等系统上面，是一个完全免费的、开放源代码的ftp服务器软件，支持很多其他的 FTP 服务器所不支持的特征。比如：非常高的安全性需求、带宽限制、良好的可伸缩性、可创建虚拟用户、支持IPv6、速率高等。<br>anon_max_rate:匿名访问最大传输速率，anon是anonymous(匿名的)的缩写</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>邮件服务器为每个用户限制磁盘存储空间上限,执行<code>checkquota -cug /var/mail</code>指令后, 在/var/mail目录自动创建的配置文件是(      )</p><ul><li>A <code>quota.user</code></li><li>B <code>aquota.user</code></li><li>C <code>aquota.group</code></li><li>D <code>quota.group</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>aquota.group与aqouta.user分别是组以及用户磁盘配额需要的配置文件。<br>如果没有这两个文件，则磁盘配额是不会生效的。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月12日Linux专项练习3</title>
      <link href="/exam//5766400a/"/>
      <url>/exam//5766400a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/5766400a/#考点1-find查找更改时间比一个文件新但比另一个文件旧的文件" class="header_1">考点1:find查找更改时间比一个文件新但比另一个文件旧的文件</a>&nbsp;<br><a href="/exam/5766400a/#考点2-etc-passwd中用户组ID与etc-group中的用户组ID不匹配导致用户无法登录的问题" class="header_1">考点2:/etc/passwd中用户组ID与etc/group中的用户组ID不匹配导致用户无法登录的问题</a>&nbsp;<br><a href="/exam/5766400a/#考点3-硬链接和符号连接" class="header_1">考点3:硬链接和符号连接</a>&nbsp;<br><a href="/exam/5766400a/#考点4-vi编辑器全部替换" class="header_1">考点4:vi编辑器全部替换</a>&nbsp;<br><a href="/exam/5766400a/#考点5-recv方法" class="header_1">考点5:recv方法</a>&nbsp;<br><a href="/exam/5766400a/#考点6-Linux卸载设备umount" class="header_1">考点6:Linux卸载设备umount</a>&nbsp;<br><a href="/exam/5766400a/#考点7-Linux多线程编程-pthread库-函数名和意义" class="header_1">考点7:Linux多线程编程 pthread库 函数名和意义</a>&nbsp;<br><a href="/exam/5766400a/#考点8-chmod授权" class="header_1">考点8:chmod授权</a>&nbsp;<br><a href="/exam/5766400a/#考点9-与用户管理相关的配置文件" class="header_1">考点9:与用户管理相关的配置文件</a>&nbsp;<br><a href="/exam/5766400a/#考点10-Linux多种复制文件方法" class="header_1">考点10:Linux多种复制文件方法</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-find查找更改时间比一个文件新但比另一个文件旧的文件"><a href="#考点1-find查找更改时间比一个文件新但比另一个文件旧的文件" class="headerlink" title="考点1:find查找更改时间比一个文件新但比另一个文件旧的文件"></a>考点1:find查找更改时间比一个文件新但比另一个文件旧的文件</h1><p><code>find . -newer file1 \! \( -newer file2 \)</code>命令的意思是？</p><ul><li>A 查找更改时间比文件<code>file1</code>新但比文件<code>file2</code>旧的文件</li><li>B 查找更改时间比文件<code>file1</code>旧但比文件<code>file2</code>新的文件</li><li>C 查找更改时间比文件<code>file1</code>旧且比文件<code>file2</code>旧的文件</li><li>D 查找更改时间比文件<code>file1</code>新且比文件<code>file2</code>新的文件</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost exam]# ls -ltr --full-time</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root     422 2021-03-19 21:12:12.566962591 +0800 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   2 root root    4096 2021-03-19 21:12:12.566962591 +0800 scaffolds</span><br><span class="line">-rw-r--r--.   1 root root     817 2021-03-19 21:12:12.566962591 +0800 package.json</span><br><span class="line">-rw-r--r--.   1 root root     376 2021-03-19 21:12:12.566962591 +0800 HexoSTest.bat</span><br><span class="line">-rw-r--r--.   1 root root     576 2021-03-19 21:12:12.566962591 +0800 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     158 2021-03-19 21:12:12.566962591 +0800 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root    3093 2021-03-19 21:12:12.566962591 +0800 _config.yml</span><br><span class="line">drwxr-xr-x.   3 root root    4096 2021-03-19 21:12:12.636962591 +0800 themes</span><br><span class="line">drwxr-xr-x.   9 root root    4096 2021-03-19 21:12:12.636962591 +0800 source</span><br><span class="line">-rwxr--r--.   1 root root     174 2021-03-19 21:16:37.816962490 +0800 hexos.sh</span><br><span class="line">drwxr-xr-x. 308 root root    8192 2021-03-19 21:19:12.036962431 +0800 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  170424 2021-03-19 21:19:12.746962431 +0800 package-lock.json</span><br><span class="line">-rw-r--r--.   1 root root 3498022 2021-03-22 20:29:10.927984900 +0800 db.json</span><br><span class="line">-rw-r--r--.   1 root root     431 2021-03-22 20:52:44.997984360 +0800 HexoS.bat</span><br><span class="line">[root@localhost exam]# find . -maxdepth 1 -newer StartWriting.bat \! \( -newer HexoS.bat \)</span><br><span class="line">.&#x2F;HexoS.bat</span><br><span class="line">.&#x2F;source</span><br><span class="line">.&#x2F;themes</span><br><span class="line">.&#x2F;hexos.sh</span><br><span class="line">.&#x2F;node_modules</span><br><span class="line">.&#x2F;db.json</span><br><span class="line">.&#x2F;package-lock.json</span><br><span class="line">[root@localhost exam]#</span><br></pre></td></tr></table></figure><h1 id="考点2-etc-passwd中用户组ID与etc-group中的用户组ID不匹配导致用户无法登录的问题"><a href="#考点2-etc-passwd中用户组ID与etc-group中的用户组ID不匹配导致用户无法登录的问题" class="headerlink" title="考点2:/etc/passwd中用户组ID与etc/group中的用户组ID不匹配导致用户无法登录的问题"></a>考点2:/etc/passwd中用户组ID与etc/group中的用户组ID不匹配导致用户无法登录的问题</h1><p>你通过编辑/etc/group文件来改变了sales group的GID,所有的组员都能成功的进行的转换,除了Jack,他甚至都无法登陆,其原因是什么？</p><ul><li>A <code>Jack</code>忘记了<code>group</code>密码</li><li>B <code>Jack</code>需要再次被加入到<code>group</code></li><li>C 在<code>/etc/passwd</code>里指明了<code>Jack</code>的<code>GID</code></li><li>D <code>Jack</code>的账号需要被删除然后新建</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>/etc/group是用户组信息文件，里面定义了<strong>用户组的ID</strong>, </li><li>/etc/passwd是用户基本信息文件，里面定义了<strong>用户的ID</strong>，<strong>用户组的ID</strong>等相关信息。</li></ul><p>所以因为两个文件中都定义了用户组的信息，所以两个文件应该都要改过来，否则会导致用户找不到所属组 </p><h1 id="考点3-硬链接和符号连接"><a href="#考点3-硬链接和符号连接" class="headerlink" title="考点3:硬链接和符号连接"></a>考点3:硬链接和符号连接</h1><p>下列关于链接描述,错误的是 。</p><ul><li>A 硬链接就是让链接文件的i节点号指向被链接文件的i节点</li><li>B 硬链接和符号连接都是产生一个新的i节点</li><li>C 链接分为硬链接和符号链接</li><li>D 硬连接不能链接目录文件</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>（1）软连接可以跨文件系统，硬连接不可以<br>（2）硬连接不管有多少个，都指向的是同一个I节点，会把结点连接数增加，只要结点的连接数不是0，文件就一直存在不管你删除的是源文件还是连接的文件。只要有一个存在文件就存在。当你修改源文件或者连接文件任何一个的时候，其他的文件都会做同步的修改。软链接不直接使用i节点号作为文件指针,<br>而是使用文件路径名作为指针。所以删除连接文件对源文件无影响，但是删除源文件，连接文件就会找不到要指向的文件。软链接有自己的inode, 并在磁盘上有一小片空间存放路径名。<br>（3）软连接可以对一个不存在的文件名进行连接 。<br>（4）软连接可以对目录进行连接。</p><p>硬连接不管有多少个，都指向的是同一个I节点，<br>只有符号链接才产生新的inode节点。<br><img src="https://uploadfiles.nowcoder.com/images/20190328/3472441_1553739357281_F960C6C562BF518E7DC94B8CA23A374F"><br>硬连接不能连接文件目录，软连接才可以。<br>硬连接不会产生新节点，硬连接指向同一节点inode。</p><p>Inode是UNIX中一种数据结构，包含了与文件系统中各个文件相关的一些重要信息，在文件系统创建时，同时会创建大量的inode。它用作数据索引的标识符，系统找到文件对应的inode，通过inode 号获取inode信息，再找到文件数据锁在的block读取。<br>硬链接，文件名和inode号对应，也可能多个文件名<b>指向同一个inode号</b>。硬链接实现不同的文件名访问同一个文件，对文件内容的修改会影响到所有的文件名，但删除一个文件名不影响其他文件名的访问。<br>软链接，也可以通过不同文件名访问同一块数据，但是<b>文件名的inode是不一样的</b>。A是B的软链接，A的内容存放的是B的路径名。<br><b>最后在回顾下硬软链接的不同：</b><br>本质不同：硬链接是指向同一个文件，软链接指向的不是同一个文件。<br>删除时：硬链接不受影响，软链接失效<br>创建链接时：创建硬链接链接数加1，创建软链接连接数不变<br><b>是否可以跨分区：硬链接不可以跨分区，软链接可以跨分区</b><br><b>目录是否可以创建链接：硬链接不可以对目录创建，软链接可以对目录创建</b><br>硬链接的inode号相同，软链接inode号不同 </p><h1 id="考点4-vi编辑器全部替换"><a href="#考点4-vi编辑器全部替换" class="headerlink" title="考点4:vi编辑器全部替换"></a>考点4:vi编辑器全部替换</h1><p>Vi编辑器中,怎样将字符AAA全部替换成yyy? </p><ul><li>A <code>p/AAA/yyy/</code></li><li>B <code>s/AAA/yyy/g</code></li><li>C <code>i/AAA/yyy/</code></li><li>D <code>p/AAA/yyy/h</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>全局替换命令为：<code>:s/源字符串/目的字符串/g</code></p><div class="table-container"><table><thead><tr><th style="text-align:left">vi末行模式命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">/pattern</td><td style="text-align:left">从光标开始处向文件尾搜索pattern</td></tr><tr><td style="text-align:left">?pattern</td><td style="text-align:left">从光标开始处向文件首搜索pattern</td></tr><tr><td style="text-align:left">n</td><td style="text-align:left">同一方向重复上一次搜索命令</td></tr><tr><td style="text-align:left">N</td><td style="text-align:left">在反方向上重复上一次搜索命令</td></tr><tr><td style="text-align:left">:s/p1/p2/g</td><td style="text-align:left">将当前行中所有p1均用p2替代</td></tr><tr><td style="text-align:left">:n1,n2s/p1/p2/g</td><td style="text-align:left">将第n1至n2行中所有p1均用p2替代</td></tr><tr><td style="text-align:left">:g/p1/s//p2/g</td><td style="text-align:left">将文件中所有p1均用p2替换</td></tr></tbody></table></div><p><img src="https://uploadfiles.nowcoder.com/images/20171115/8121647_1510750596579_185EADA507DBD588DFD475182F61A7B4"></p><h1 id="考点5-recv方法"><a href="#考点5-recv方法" class="headerlink" title="考点5:recv方法"></a>考点5:recv方法</h1><p>调用recv(int sockfd, void *buf, size_t len, int flags)的过程中,一共进行了几次内存复制操作？</p><ul><li>A 1</li><li>B 2</li><li>C 3</li><li>D 4</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>内核从对端接受数据，放在socket的缓存中，然后复制到应用层的buffer，所以一共两个buffer。<br>recv 接受对端socket数据，经过两次系统调用，首先在内核中将数据拷贝到自己的协议栈；然后recv返回将数据从内核缓冲区拷贝到用户buffer中。 内核从对端接受数据，放在socket的缓存中，然后复制到应用层的buffer，所以一共两个buffer。</p><h1 id="考点6-Linux卸载设备umount"><a href="#考点6-Linux卸载设备umount" class="headerlink" title="考点6:Linux卸载设备umount"></a>考点6:Linux卸载设备umount</h1><p>将光盘/dev/hdc卸载的命令是?</p><ul><li>A <code>umount /mnt/cdrom /dev/hdc</code></li><li>B <code>mount /dev/hdc</code></li><li>C <code>umount /dev/hdc</code></li><li>D <code>mount /mnt/cdrom /dev/hdc</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>题干没有说明，事先是把/dev/hdc挂载到/mnt/cdrom下。</p><p>挂载设备使用mount，<br>卸载设备使用umount，有三种方式，通过设备名，挂载点或者设备名和挂载点 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">umount &#x2F;dev&#x2F;hdc</span><br><span class="line">umount &#x2F;mnt&#x2F;cdrom</span><br><span class="line">umount &#x2F;mnt&#x2F;cdrom &#x2F;dev&#x2F;hdc</span><br></pre></td></tr></table></figure></p><h1 id="考点7-Linux多线程编程-pthread库-函数名和意义"><a href="#考点7-Linux多线程编程-pthread库-函数名和意义" class="headerlink" title="考点7:Linux多线程编程 pthread库 函数名和意义"></a>考点7:Linux多线程编程 pthread库 函数名和意义</h1><p>下述是Linux下多线程编程常用的pthread库提供的函数名和意义,说法正确的有？</p><ul><li>A <code>pthread_create</code> 创建一个线程</li><li>B <code>pthread_join</code> 用来等待一个线程的结束</li><li>C <code>pthread_mutex_init</code> 初始化一个线程互斥锁</li><li>D <code>pthread_exit</code> 结束一个线程</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h1 id="考点8-chmod授权"><a href="#考点8-chmod授权" class="headerlink" title="考点8:chmod授权"></a>考点8:chmod授权</h1><p>文件aaa的访问权限为rw-r—r—,现要增加所有用户的执行权限和同组用户的写权限,下列哪些命令是正确的？</p><ul><li>A <code>chmod a+x , g+w aaa</code></li><li>B <code>chmod 764 aaa</code></li><li>C <code>chmod 775 aaa</code></li><li>D <code>chmod o+x , g+w aaa</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><h1 id="考点9-与用户管理相关的配置文件"><a href="#考点9-与用户管理相关的配置文件" class="headerlink" title="考点9:与用户管理相关的配置文件"></a>考点9:与用户管理相关的配置文件</h1><p>Linux系统上,下面哪些文件是与用户管理相关的配置文件()</p><ul><li>A <code>/etc/passwd</code></li><li>B <code>/etc/shadow</code></li><li>C <code>/etc/group</code></li><li>D <code>/etc/password</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>/etc/passwd     存放用户的UID name 密码过期时间 修改时间等等<br>/etc/shadow     存放用户的密码密文<br>/etc/group      存放用户的所属组情况<br>/etc/password    是错误的，linux没有D 这个文件</p><h1 id="考点10-Linux多种复制文件方法"><a href="#考点10-Linux多种复制文件方法" class="headerlink" title="考点10:Linux多种复制文件方法"></a>考点10:Linux多种复制文件方法</h1><p>将文件file1复制为file2可以用下面哪些命令()</p><ul><li>A <code>cp file1 file2</code></li><li>B <code>cat file1 &gt;file2</code></li><li>C <code>cat &lt; file1 &gt;file2</code></li><li>D <code>dd if=file1 of=file2</code></li><li>E <code>cat file1 | cat &gt;file2</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCDE</details><h3 id="Linux复制cp命令"><a href="#Linux复制cp命令" class="headerlink" title="Linux复制cp命令"></a>Linux复制cp命令</h3><ul><li><code>cp命令</code>：cp指令用于复制文件或目录。 <ul><li>将文件file1复制成文件file2命令如下：cp file1 file2 </li></ul></li></ul><h3 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h3><ul><li><code>cat命令</code>：cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的。 <ul><li>一次显示整个文件命令如下： cat filename</li></ul></li></ul><p>输入输出重定向</p><ul><li><code>&gt;</code>: linux中的数据流重导向：输出导向，覆盖导向的文件内容。 </li><li><code>&lt;</code>: linux中的数据流重导向：输入导向，理解为原本由键盘输入改为文本输入 </li><li><code>|</code>：管道命令操作符，处理经由前面一个指令传出的正确输出信息，然后，传递给下一个命令，作为标准的输入</li></ul><h3 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h3><ul><li><code>dd命令</code>: 作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 <ul><li>参数：<ul><li>if  输入文件（或设备名称）</li><li>of  输出文件（或设备名称） </li></ul></li><li>将文件file1拷贝到文件file2中命令如下：<ul><li>dd if=file1 of=file2</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月12日Linux专项练习2</title>
      <link href="/exam//f050cb01/"/>
      <url>/exam//f050cb01/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f050cb01/#考点1-vi-末行模式相关命令" class="header_1">考点1:vi 末行模式相关命令</a>&nbsp;<br><a href="/exam/f050cb01/#考点2-Linux默认的Shell" class="header_1">考点2:Linux默认的Shell</a>&nbsp;<br><a href="/exam/f050cb01/#考点3-如何退出交互式Shell" class="header_1">考点3:如何退出交互式Shell</a>&nbsp;<br><a href="/exam/f050cb01/#考点4-Linux查找字符串grep" class="header_1">考点4:Linux查找字符串grep</a>&nbsp;<br><a href="/exam/f050cb01/#考点5-Linux任务计划" class="header_1">考点5:Linux任务计划</a>&nbsp;<br><a href="/exam/f050cb01/#考点6-导致进程从用户态切换到内核态的情况" class="header_1">考点6:导致进程从用户态切换到内核态的情况</a>&nbsp;<br><a href="/exam/f050cb01/#考点7-Linux统计重复行uniq-按行排序sort-查看文件头head" class="header_1">考点7:Linux统计重复行uniq 按行排序sort 查看文件头head</a>&nbsp;<br><a href="/exam/f050cb01/#考点8-授权-修改属主-修改属组" class="header_1">考点8:授权 修改属主 修改属组</a>&nbsp;<br><a href="/exam/f050cb01/#考点9-makefile" class="header_1">考点9:makefile</a>&nbsp;<br><a href="/exam/f050cb01/#考点10-硬链接" class="header_1">考点10:硬链接</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-vi-末行模式相关命令"><a href="#考点1-vi-末行模式相关命令" class="headerlink" title="考点1:vi 末行模式相关命令"></a>考点1:vi 末行模式相关命令</h1><p>你使用命令”vi/etc/inittab”查看该文件的内容,你不小心改动了一些内容,为了防止系统出为,你不想保存所修改的内容,你应该如何操作:</p><ul><li>A 在末行模式下,键入<code>:wq</code></li><li>B 在末行模式下,键入<code>:q!</code></li><li>C 在末行模式下,键入<code>:x!</code></li><li>D 在编辑模式下,键入”ESC”键直接退出vi</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><div class="table-container"><table><thead><tr><th style="text-align:left">vi末行模式命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">:wq</td><td style="text-align:left">强制性写入文件并退出。即使文件没有被修改也强制写入，并更新文件的修改时间。</td></tr><tr><td style="text-align:left">:q！</td><td style="text-align:left">直接强制退出</td></tr><tr><td style="text-align:left">:x！</td><td style="text-align:left">写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。</td></tr></tbody></table></div><p>在编辑模式下，键入”ESC”键不退出vi 直接进入命令模式</p><h1 id="考点2-Linux默认的Shell"><a href="#考点2-Linux默认的Shell" class="headerlink" title="考点2:Linux默认的Shell"></a>考点2:Linux默认的Shell</h1><p>shell不仅仅是用户命令解释器,同时一种强大的编程语言,linux缺省的shell是什么</p><ul><li>A <code>bash</code></li><li>B <code>ruby</code></li><li>C <code>PHP</code></li><li>D <code>perl</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点3-如何退出交互式Shell"><a href="#考点3-如何退出交互式Shell" class="headerlink" title="考点3:如何退出交互式Shell"></a>考点3:如何退出交互式Shell</h1><p>退出交互式的shell,应键入(    )</p><ul><li>A <code>Esc</code></li><li>B <code>q</code></li><li>C <code>exit</code></li><li>D <code>quit</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>esc，在vi的插入模式或者底行命令模式下进入命令模式 </li><li>q，用来退出 man 手册查看命令或者配置文件的状态，或者more、less等命令查看文件的状态 </li><li>exit，一般用于退出会话式程序或者交互式命令行，如ssh远程连接，切换 shell（Linux中） </li><li>quit，一般用于图形界面的退出 </li></ul><p>以上的exit和quit仅是个人总结，非权威，python中的exit()和quit()都可以用来退出python的交互式shell</p><h1 id="考点4-Linux查找字符串grep"><a href="#考点4-Linux查找字符串grep" class="headerlink" title="考点4:Linux查找字符串grep"></a>考点4:Linux查找字符串grep</h1><p>Linux系统中在给定文件中查找与设定条件相符字符串的命令为？</p><ul><li>A <code>grep</code></li><li>B <code>gzip</code></li><li>C <code>find</code></li><li>D <code>sort</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>grep：查找文件内的内容<br>gzip：压缩文件，文件经压缩后会增加.gz扩展名<br>find：在指定目录下查找文件<br>sort：排序</p><h1 id="考点5-Linux任务计划"><a href="#考点5-Linux任务计划" class="headerlink" title="考点5:Linux任务计划"></a>考点5:Linux任务计划</h1><p>假如你想计划让系统自动在每个月的第一天早上4点钟执行一个维护工作,以下哪个cron是正确的？</p><ul><li>A <code>00 4 1 1-12 * /maintenance.pl</code></li><li>B <code>4 1 * * ~/maintenance.pl</code></li><li>C <code>0 4 31 /1 * * ~/maintenance.pl</code></li><li>D <code>1 4 00 ~/maintenance.pl</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="Linux计划任务格式"><a href="#Linux计划任务格式" class="headerlink" title="Linux计划任务格式"></a>Linux计划任务格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分 时 日 月 周  命令&#x2F;脚本</span><br></pre></td></tr></table></figure><p>上面的周，1表示星期天，…6表示星期六，0，表示星期天</p><h3 id="如何查看任务计划表"><a href="#如何查看任务计划表" class="headerlink" title="如何查看任务计划表"></a>如何查看任务计划表</h3><p>你们可以打开 /etc/crontab 里面就是任务计划表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]&amp;#35; cat &#x2F;etc&#x2F;crontab</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"></span><br><span class="line">&amp;#35; For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line">&amp;#35; Example of job definition:</span><br><span class="line">&amp;#35; .---------------- minute (0 - 59)</span><br><span class="line">&amp;#35; |  .------------- hour (0 - 23)</span><br><span class="line">&amp;#35; |  |  .---------- day of month (1 - 31)</span><br><span class="line">&amp;#35; |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line">&amp;#35; |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line">&amp;#35; |  |  |  |  |</span><br><span class="line">&amp;#35; *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br><span class="line">[root@localhost ~]&amp;#35;</span><br></pre></td></tr></table></figure></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>每天04:00<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 4 * * * 要执行的命令</span><br></pre></td></tr></table></figure><br>周二和周五18:00<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 18 * * 2,5 要执行的命令</span><br></pre></td></tr></table></figure><br>1月到3月份， 周二和周五18:00<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 18 * 1-3 2,5 要执行的命令</span><br></pre></td></tr></table></figure><br>周一到周五17:30发广播，然后17:45分关机<br>写两条计划任务，不是只能写一条<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30 17 * * 1-5 &#x2F;usr&#x2F;bin&#x2F;wall &lt; &#x2F;root&#x2F;msg </span><br><span class="line">45 17 * * 1-5 &#x2F;sbin&#x2F;shutdown -h now</span><br></pre></td></tr></table></figure><br>中午12点到14点，每两分钟(偶数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;2 12-14 * * * 命令</span><br></pre></td></tr></table></figure></p><h1 id="考点6-导致进程从用户态切换到内核态的情况"><a href="#考点6-导致进程从用户态切换到内核态的情况" class="headerlink" title="考点6:导致进程从用户态切换到内核态的情况"></a>考点6:导致进程从用户态切换到内核态的情况</h1><p>下列选项中,会导致用户进程从用户态切换到内核的操作是?<br>I. 整数除以零<br>II. sin( )函数调用<br>III. read系统调用</p><ul><li>A 仅 I、II</li><li>B 仅 I、III</li><li>C 仅 II 、III</li><li>D I、II和III</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="用户态切换到内核态的3种方式"><a href="#用户态切换到内核态的3种方式" class="headerlink" title="用户态切换到内核态的3种方式"></a>用户态切换到内核态的3种方式</h3><p>a. 系统调用<br>b. 异常<br>c. 外围设备的中断</p><h1 id="考点7-Linux统计重复行uniq-按行排序sort-查看文件头head"><a href="#考点7-Linux统计重复行uniq-按行排序sort-查看文件头head" class="headerlink" title="考点7:Linux统计重复行uniq 按行排序sort 查看文件头head"></a>考点7:Linux统计重复行uniq 按行排序sort 查看文件头head</h1><p>有一个文件ip.txt,每行一条ip记录,共若干行,已排好序,下面哪个命令可以实现”统计出现次数最多的前3个ip及其次数”？( )</p><ul><li>A uniq -c ip.txt</li><li>B uniq -c ip.txt | sort -nr | head -n 3</li><li>C cat ip.txt | count -n | sort -rn | head -n 3</li><li>D cat ip.txt | count -n</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><code>uniq</code>命令：报告或删去重复行，加上<code>-n</code>参数可以统计重复行出现的次数（放在每行开头）。<br><code>sort</code>命令：对文本按行进行排序，<code>-n</code>参数表示根据数字大小排序；<code>-r</code>，对应英文单词是reverse，意思是反转排序结果，<code>sort</code>默认是从小到大排序，加上这个参数可以实现从大到小排序。<br><code>head</code>命令：取文件的前一部分（默认输出前10行）。加<code>-n [数字]</code>可以指定到底是前几行。<br>把这三个命令的作用都搞懂，再加上一点 <em>Linux管道符</em> 的知识，这道题目也就很容易解决了。最好是自己动手在命令行下实践几次，加深印象，容易记牢。</p><h1 id="考点8-授权-修改属主-修改属组"><a href="#考点8-授权-修改属主-修改属组" class="headerlink" title="考点8:授权 修改属主 修改属组"></a>考点8:授权 修改属主 修改属组</h1><p>软件项目存储于/ftproot,允许apache用户修改所有程序,设置访问权限的指令？</p><ul><li>A <code>chmod 777 /ftproot</code></li><li>B <code>chgrp apache /frproot</code></li><li>C <code>chown apache /ftproot</code></li><li>D <code>chmod apache /ftproot</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>chmod +权限 +文件或目录<br>chown +属主.属组+文件或目录<br>chgrp +属组 +目录<br>就本题目而言，设置目录的权限可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 &#x2F;ftproot</span><br></pre></td></tr></table></figure><br>但是这样做的话所有的用户都可以操作该目录，不是个很好的解决方案。</p><p>也可以直接设置目录的属主为apache：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown apache &#x2F;ftproot</span><br></pre></td></tr></table></figure><br>然后再加上权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 7xx &#x2F;ftproot</span><br></pre></td></tr></table></figure><br>把文件夹的属主改成了apache也不代表apache用户能修改所有程序，因为文件所有者权限有可能不可写。</p><blockquote><p>这个题目有问题，如果<code>/ftproot</code>是个目录，这样的话，<code>chmod 777 -r /ftproot</code>才能修改该目录下的所有程序。</p></blockquote><h1 id="考点9-makefile"><a href="#考点9-makefile" class="headerlink" title="考点9:makefile"></a>考点9:makefile</h1><p>下列关于makefile描述正确的有？</p><ul><li>A <code>makefile</code>文件保存了编译器和连接器的参数选项</li><li>B 主要包含了五个东西:显式规则、隐晦规则、变量定义、文件指示和注释</li><li>C 默认的情况下,<code>make</code>命令会在当前目录下按顺序找寻文件名为”<code>GNUmakefile</code>“、”<code>makefile</code>“、”<code>Makefile</code>“的文件, 找到了解释这个文件</li><li>D 在<code>Makefile</code>不可以使用<code>include</code>关键字把别的<code>Makefile</code>包含进来</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>makefile文件保存了编译器和连接器的参数选项,还表述了所有源文件之间的关系(源代码文件需要的特定的包含文件,可执行文件要求包含的目标文件模块及库等).创建程序(make程序)首先读取makefile文件,然后再激活编译器,汇编器,资源编译器和连接器以便产生最后的输出,最后输出并生成的通常是可执行文件.创建程序利用内置的推理规则来激活编译器,以便通过对特定CPP文件的编译来产生特定的OBJ文件.<br>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。<br>1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。<br>2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。<br>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。<br>4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。<br>5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。<br>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用 “GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。<br>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include &lt;filename&gt;;</span><br></pre></td></tr></table></figure><br>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p><h1 id="考点10-硬链接"><a href="#考点10-硬链接" class="headerlink" title="考点10:硬链接"></a>考点10:硬链接</h1><p>在Linux系统,关于硬链接的描述正确的是()</p><ul><li>A 跨文件系统</li><li>B 不可以跨文件系统</li><li>C 为链接文件创建新的i节点</li><li>D 链接文件的i节点与被链接文件的i节点相同</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details><h3 id="链接分硬链接和符号链接"><a href="#链接分硬链接和符号链接" class="headerlink" title="链接分硬链接和符号链接"></a>链接分硬链接和符号链接</h3><ul><li>符号链接可以建立对于文件和目录的链接。</li><li>符号链接可以跨文件系统，即可以跨磁盘分区。</li><li>符号链接的文件类型位是l，链接文件具有新的i节点。</li></ul><ul><li>硬链接不可以跨文件系统。它只能建立对文件的链接，</li><li>硬链接的文件类型位是－，且硬链接文件的i节点同被链接文件的i节点相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月12日Linux专项练习1</title>
      <link href="/exam//b9682126/"/>
      <url>/exam//b9682126/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/b9682126/#考点1-常见Linux命令" class="header_1">考点1:常见Linux命令</a>&nbsp;<br><a href="/exam/b9682126/#考点2-八进制权限" class="header_1">考点2:八进制权限</a>&nbsp;<br><a href="/exam/b9682126/#考点3-unix授权命令" class="header_1">考点3:unix授权命令</a>&nbsp;<br><a href="/exam/b9682126/#考点4-Linux终止前台进程" class="header_1">考点4:Linux终止前台进程</a>&nbsp;<br><a href="/exam/b9682126/#考点5-Linux内核子系统" class="header_1">考点5:Linux内核子系统</a>&nbsp;<br><a href="/exam/b9682126/#考点6-Linux查看系统负载命令" class="header_1">考点6:Linux查看系统负载命令</a>&nbsp;<br><a href="/exam/b9682126/#考点7-z-string-短路与-短路或" class="header_1">考点7:[-z string] 短路与 短路或</a>&nbsp;<br><a href="/exam/b9682126/#考点8-Redhat9安装方式" class="header_1">考点8:Redhat9安装方式</a>&nbsp;<br><a href="/exam/b9682126/#考点9-批量删除当前目录下的文件" class="header_1">考点9:批量删除当前目录下的文件</a>&nbsp;<br><a href="/exam/b9682126/#考点10-查看Linux主机的默认路由" class="header_1">考点10:查看Linux主机的默认路由</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-常见Linux命令"><a href="#考点1-常见Linux命令" class="headerlink" title="考点1:常见Linux命令"></a>考点1:常见Linux命令</h1><p>以下不属于Linux系统命令的是:</p><ul><li>A <code>kill</code></li><li>B <code>ifconfig</code></li><li>C <code>mv</code></li><li>D <code>remove</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Linux没有remove命令，但是有rm</p><h1 id="考点2-八进制权限"><a href="#考点2-八进制权限" class="headerlink" title="考点2:八进制权限"></a>考点2:八进制权限</h1><p>linux系统中某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为:</p><ul><li>A 753</li><li>B 763</li><li>C 754</li><li>D 764</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点3-unix授权命令"><a href="#考点3-unix授权命令" class="headerlink" title="考点3:unix授权命令"></a>考点3:unix授权命令</h1><p>在unix系统下执行chmod(“/usr/test/sample”,0753)之后该文件sample的访问权限为</p><ul><li>A 拥有者可读写执行,同组用户可写可执行,其他用户可读可执行</li><li>B 拥有者可读写执行,同组用户可读写,其他用户可读可执行</li><li>C 拥有者可读写执行,同组用户可读可执行,其他用户可写可执行</li><li>D 拥有者可读写执行,同组用户可读可执行,其他用户可读写</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点4-Linux终止前台进程"><a href="#考点4-Linux终止前台进程" class="headerlink" title="考点4:Linux终止前台进程"></a>考点4:Linux终止前台进程</h1><p>终止一个前台进程可能用到的命令和操作是？</p><ul><li>A <code>kill</code></li><li>B <code>ctrl+C</code></li><li>C <code>shut down</code></li><li>D <code>halt</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="Linux如何终止前台进程"><a href="#Linux如何终止前台进程" class="headerlink" title="Linux如何终止前台进程"></a>Linux如何终止前台进程</h3><p>终止一个前台进程用<br>ctrl+C；</p><h3 id="Linux如何终止后台进程"><a href="#Linux如何终止后台进程" class="headerlink" title="Linux如何终止后台进程"></a>Linux如何终止后台进程</h3><p>终止一个后台进程：<br>1、使用kill命令；<br>2、使用fg命令将后台进程变为前台进程，然后ctrl+C。</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">kill</td><td style="text-align:left">无参数表示向进程输入关闭的指令</td></tr><tr><td style="text-align:left">Ctrl+C</td><td style="text-align:left">关闭当前（前台）进程</td></tr><tr><td style="text-align:left">Chrl+Z</td><td style="text-align:left">暂停当前（前台）进程</td></tr><tr><td style="text-align:left">shutdown</td><td style="text-align:left">关机</td></tr><tr><td style="text-align:left">halt</td><td style="text-align:left">就是调用shutdown -h(立即关机)</td></tr></tbody></table></div><h1 id="考点5-Linux内核子系统"><a href="#考点5-Linux内核子系统" class="headerlink" title="考点5:Linux内核子系统"></a>考点5:Linux内核子系统</h1><p>内核不包括的子系统是 。</p><ul><li>A 进程管理系统</li><li>B 内存管理系统</li><li>C <code>I/O</code>管理系统</li><li>D 硬件管理系统</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>内核分为 <strong>进程管理系统 、 内存管理系统 、 I/O管理系统 和文件管理系统</strong>等四个子系统。<br>硬件管理系统一听就不切实际阿 因为内核是一串指令。</p><h1 id="考点6-Linux查看系统负载命令"><a href="#考点6-Linux查看系统负载命令" class="headerlink" title="考点6:Linux查看系统负载命令"></a>考点6:Linux查看系统负载命令</h1><p>下面有关linux查看系统负载的命令,说法错误的是？</p><ul><li>A <code>uptime</code>命令主要用于获取主机运行时间和查询<code>linux</code>系统负载等信息</li><li>B <code>vmstat</code>命令可以查看查看<code>cpu</code>负载</li><li>C <code>sar</code>命令可以查看网络接口信息</li><li>D <code>free</code>命令可以查看磁盘负载情况</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 01:17:27 up 2 days, 13:36,  1 user,  load average: 8.92, 8.93, 9.28</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 3  0      0 124912 116352 1516588    0    0    34    27   31   21 15  5 79  0  0</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="vmstat帮助文档"><a href="#vmstat帮助文档" class="headerlink" title="vmstat帮助文档"></a>vmstat帮助文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> vmstat [options] [delay [count]]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -a, --active           active&#x2F;inactive memory</span><br><span class="line"> -f, --forks            number of forks since boot</span><br><span class="line"> -m, --slabs            slabinfo</span><br><span class="line"> -n, --one-header       do not redisplay header</span><br><span class="line"> -s, --stats            event counter statistics</span><br><span class="line"> -d, --disk             disk statistics</span><br><span class="line"> -D, --disk-sum         summarize disk statistics</span><br><span class="line"> -p, --partition &lt;dev&gt;  partition specific statistics</span><br><span class="line"> -S, --unit &lt;char&gt;      define display unit</span><br><span class="line"> -w, --wide             wide output</span><br><span class="line"> -t, --timestamp        show timestamp</span><br><span class="line"></span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see vmstat(8).</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="uptime帮助文档"><a href="#uptime帮助文档" class="headerlink" title="uptime帮助文档"></a>uptime帮助文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime --help</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> uptime [options]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -p, --pretty   show uptime in pretty format</span><br><span class="line"> -h, --help     display this help and exit</span><br><span class="line"> -s, --since    system up since</span><br><span class="line"> -V, --version  output version information and exit</span><br><span class="line"></span><br><span class="line">For more details see uptime(1).</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:        3686064     1917344      154528        1508     1614192     1733323</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           3.5G        1.8G        151M        1.5M        1.5G        1.7G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>free描述的是内存使用情况，不是磁盘负载。<br>free查看内存使用情况，并非磁盘。磁盘可以使用df命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           3.5G        1.8G         92M        1.5M        1.6G        1.6G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><br>可以看到当前Linux的内存有3.5G,已经使用了1.8G内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;userdata   55G   14G   41G   26% &#x2F;</span><br><span class="line">tmpfs                                   1.8G  368K  1.8G    1% &#x2F;dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;data&#x2F;media                              55G   14G   41G   26% &#x2F;mnt&#x2F;files</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><br>可以看到磁盘容量为55G，已用14G，有41G可以用。</p><h1 id="考点7-z-string-短路与-短路或"><a href="#考点7-z-string-短路与-短路或" class="headerlink" title="考点7:[-z string] 短路与 短路或"></a>考点7:[-z string] 短路与 短路或</h1><p>命令:<code>[-z&quot;&quot;]&amp;&amp;echo 0 ||echo 1</code>的输出是什么</p><ul><li>A 1</li><li>B 0</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="z-STRING-命令-n-string-命令"><a href="#z-STRING-命令-n-string-命令" class="headerlink" title="[-z STRING]命令[-n string]命令"></a>[-z STRING]命令[-n string]命令</h3><p><code>[-z STRING]</code> “STRING” 的长度为零则为真<br><code>[-z &quot;&quot;]</code>长度为零，返回1，故执行&amp;&amp;后面的语句 echo 0显示“0”,返回1，故不执行echo 1 最终结果为0 </p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>[-z string]</code></td><td style="text-align:left">“<code>string</code>”的长度为零则为真。我的理解是<code>[-z string]</code>就是<code>[-zero string]</code></td></tr><tr><td style="text-align:left"><code>[-n string] or [string]</code></td><td style="text-align:left">“<code>string</code>”的长度为非零，则为真。<code>[-n string]</code>就是<code>[non-zero string]</code></td></tr></tbody></table></div><h1 id="考点8-Redhat9安装方式"><a href="#考点8-Redhat9安装方式" class="headerlink" title="考点8:Redhat9安装方式"></a>考点8:Redhat9安装方式</h1><p>Redhat9 所支持的安装方式有()</p><ul><li>A 从本地硬盘驱动器进行安装</li><li>B 通过<code>Telnet</code>进行网络安装</li><li>C 通过<code>NFS</code>进行网络安装</li><li>D 通过<code>HTTP</code>进行网络安装</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><p><strong>没用过红帽好伐，所以百度鸟解了一哈🤣</strong><br>从安装启动方式可以分为:软盘启动 光盘启动 U盘启动(红帽9还支持制作安装启动软盘的,只是软盘现在基本见不到了) 从软件安装来源可以分为:光盘、硬盘、nfs服务器、ftp服务器、http服务器<br>最简单的方式就是光盘引导，光盘安装。<br>其他安装方式还有KickStart无人值守安装等。</p><h1 id="考点9-批量删除当前目录下的文件"><a href="#考点9-批量删除当前目录下的文件" class="headerlink" title="考点9:批量删除当前目录下的文件"></a>考点9:批量删除当前目录下的文件</h1><p>批量删除当前目录下后缀名为.c的文件。如a.c、b.c。</p><ul><li>A rm *.c</li><li>B find . -name “*.c” -maxdepth 1 | xargs rm</li><li>C find . -name “*.c” | xargs rm</li><li>D 以上都不正确</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details><p>xargs是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。它能够捕获一个命令的输出，然后传递给另外一个命令，当你尝试用rm 由于题目中是说删除当前目录下后缀名为.c的文件，故需要加上-maxdepth 1，表示是当前目录，不包括其子目录。</p><p><code>find . -name &quot;*.c&quot; -maxdepth 1</code>表示找到.(当前目录下)名字为以“.c”为后缀的文件，-maxdepth 1表示目录深度为1，也就是寻找当前目录 </p><h1 id="考点10-查看Linux主机的默认路由"><a href="#考点10-查看Linux主机的默认路由" class="headerlink" title="考点10:查看Linux主机的默认路由"></a>考点10:查看Linux主机的默认路由</h1><p>下面那些命令可以用来查看Linux主机的默认路由()</p><ul><li>A <code>route</code></li><li>B <code>ifconfig</code></li><li>C <code>ping</code></li><li>D <code>netstat</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>直接route命令就可以显示默认路由，netstat命令需要加一个参数-route<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">young@young-Lenovo-G470:~$ route</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标 网关 子网掩码 标志 跃点 引用 使用 接口</span><br><span class="line">default 172.28.234.1 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line">172.28.234.0 * 255.255.254.0 U 9 0 0 wlan0</span><br><span class="line">young@young-Lenovo-G470:~$ netstat -route</span><br><span class="line">内核 IP 路由表</span><br><span class="line">目标 网关 子网掩码 标志 跃点 引用 使用 接口</span><br><span class="line">default 172.28.234.1 0.0.0.0 UG 0 0 0 wlan0</span><br><span class="line">172.28.234.0 * 255.255.254.0 U 9 0 0 wlan0</span><br><span class="line">young@young-Lenovo-G470:~$</span><br></pre></td></tr></table></figure></p><p>route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。<br>ifconfig命令用来来检测和设置本机的网络接口。<br>ping命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常<br>netstat命令用来查看主机的连接状态 </p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月11日Linux专项练习1</title>
      <link href="/exam//80108c66/"/>
      <url>/exam//80108c66/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/80108c66/#考点1-查看文件内容的命令" class="header_1">考点1:查看文件内容的命令</a>&nbsp;<br><a href="/exam/80108c66/#考点2-查看线程信息功能的gdb命令" class="header_1">考点2:查看线程信息功能的gdb命令</a>&nbsp;<br><a href="/exam/80108c66/#考点3-八进制文件权限授权命令" class="header_1">考点3:八进制文件权限授权命令</a>&nbsp;<br><a href="/exam/80108c66/#考点4-查看硬盘占用空间和剩余空间" class="header_1">考点4:查看硬盘占用空间和剩余空间</a>&nbsp;<br><a href="/exam/80108c66/#考点5-八进制文件权限" class="header_1">考点5:八进制文件权限</a>&nbsp;<br><a href="/exam/80108c66/#考点6-fork-方法短路或" class="header_1">考点6:fork()方法短路或</a>&nbsp;<br><a href="/exam/80108c66/#考点7-Linux守护进程" class="header_1">考点7:Linux守护进程</a>&nbsp;<br><a href="/exam/80108c66/#考点8-Linux多线程编程pthread库函数" class="header_1">考点8:Linux多线程编程pthread库函数</a>&nbsp;<br><a href="/exam/80108c66/#考点9-Nginx配置文件nginx-conf" class="header_1">考点9:Nginx配置文件nginx.conf</a>&nbsp;<br><a href="/exam/80108c66/#考点10-DNS服务主配置文件有哪些" class="header_1">考点10:DNS服务主配置文件有哪些</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-查看文件内容的命令"><a href="#考点1-查看文件内容的命令" class="headerlink" title="考点1:查看文件内容的命令"></a>考点1:查看文件内容的命令</h1><p>在Linux系统上,下面那个命令不可以用来查看文件内容()</p><ul><li>A <code>cat</code></li><li>B <code>ls</code></li><li>C <code>less</code></li><li>D <code>more</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点2-查看线程信息功能的gdb命令"><a href="#考点2-查看线程信息功能的gdb命令" class="headerlink" title="考点2:查看线程信息功能的gdb命令"></a>考点2:查看线程信息功能的gdb命令</h1><p>写出完成gdb查看线程信息功能的gdb命令。</p><ul><li>A <code>bt</code></li><li>B <code>info thread</code></li><li>C <code>set scheduler-locking off</code></li><li>D <code>info break</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>backtrace bt</strong></td><td style="text-align:left">打印当前的函数调用栈的所有信息。</td></tr><tr><td style="text-align:left"><strong>info threads</strong></td><td style="text-align:left">显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。前面有*的是当前调试的线程。</td></tr><tr><td style="text-align:left"><strong>set scheduler-locking</strong></td><td style="text-align:left">线程调试 显示线程状态,参数<strong>off</strong>表示不锁定任何线程</td></tr><tr><td style="text-align:left"><strong>info break</strong></td><td style="text-align:left">可列出所有断点信息，info break 后也可设置要查看的break num</td></tr></tbody></table></div><h1 id="考点3-八进制文件权限授权命令"><a href="#考点3-八进制文件权限授权命令" class="headerlink" title="考点3:八进制文件权限授权命令"></a>考点3:八进制文件权限授权命令</h1><p>在linux中,将文件属性设置为所有者只读,其余无任何权限的命令为(假设文件名为myfile)</p><ul><li>A <code>chown 400 myfile</code></li><li>B <code>chmod 750 myfile</code></li><li>C <code>chown u+r myfile</code></li><li>D <code>chmod 400 myfile</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点4-查看硬盘占用空间和剩余空间"><a href="#考点4-查看硬盘占用空间和剩余空间" class="headerlink" title="考点4:查看硬盘占用空间和剩余空间"></a>考点4:查看硬盘占用空间和剩余空间</h1><p>什么命令用来查看硬盘被占用了多少空间和剩余多少空间？</p><ul><li>A <code>du</code></li><li>B <code>df</code></li><li>C <code>free</code></li><li>D <code>vmstat</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="du-disk-usage"><a href="#du-disk-usage" class="headerlink" title="du(disk usage)"></a>du(disk usage)</h3><p>统计目录(或文件)所占磁盘空间的大小<br>查看/root目录占用磁盘空间的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 0 &#x2F;root</span><br><span class="line">45M    &#x2F;root</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><br>查看/root目录以及/root目录的一级子目录所占的磁盘空间大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 1 &#x2F;root</span><br><span class="line">8.0K    &#x2F;root&#x2F;.pki</span><br><span class="line">20K    &#x2F;root&#x2F;.ssh</span><br><span class="line">2.6M    &#x2F;root&#x2F;.nvm</span><br><span class="line">12K    &#x2F;root&#x2F;.config</span><br><span class="line">42M    &#x2F;root&#x2F;.npm</span><br><span class="line">84K    &#x2F;root&#x2F;C_Test</span><br><span class="line">45M    &#x2F;root</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="df-disk-free"><a href="#df-disk-free" class="headerlink" title="df(disk free)"></a>df(disk free)</h3><p>用于显示文件系统的磁盘使用情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df</span><br><span class="line">文件系统                                  1K-块     已用     可用 已用% 挂载点</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;userdata 56814352 14404892 42393076   26% &#x2F;</span><br><span class="line">tmpfs                                   1822552      368  1822184    1% &#x2F;dev</span><br><span class="line">tmpfs                                   1843032        0  1843032    0% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;data&#x2F;media                            56763152 14421276 42341876   26% &#x2F;mnt&#x2F;files</span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;userdata   55G   14G   41G   26% &#x2F;</span><br><span class="line">tmpfs                                   1.8G  368K  1.8G    1% &#x2F;dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;data&#x2F;media                              55G   14G   41G   26% &#x2F;mnt&#x2F;files</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:        3686064     1383564      673684        2108     1628816     2266427</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           3.5G        1.3G        657M        2.1M        1.6G        2.2G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>命令报告关于内核线程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 669372 164900 1529292    0    0    33    27    5   21 15  5 80  0  0</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="考点5-八进制文件权限"><a href="#考点5-八进制文件权限" class="headerlink" title="考点5:八进制文件权限"></a>考点5:八进制文件权限</h1><p>linux系统中某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为:</p><ul><li>A 753</li><li>B 763</li><li>C 754</li><li>D 764</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="ls-l第一列第1位含义"><a href="#ls-l第一列第1位含义" class="headerlink" title="ls -l第一列第1位含义"></a>ls -l第一列第1位含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost blog]# ls -l</span><br><span class="line">总用量 14056</span><br><span class="line">-rw-r--r--.   1 root root     3196 3月  18 14:47 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 14159968 3月  20 22:46 db.json</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x. 307 root root     8192 3月  18 14:49 node_modules</span><br><span class="line">-rw-r--r--.   1 root root      817 3月  18 14:49 package.json</span><br><span class="line">......</span><br><span class="line">drwxr-xr-x.   3 root root     4096 3月  18 14:47 themes</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">ls -l第一列第一位</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">l</td><td style="text-align:left">链接文件</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">目录</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">文件</td></tr></tbody></table></div><h3 id="ls-l第1列第2到10为含义"><a href="#ls-l第1列第2到10为含义" class="headerlink" title="ls -l第1列第2到10为含义"></a>ls -l第1列第2到10为含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量 4</span><br><span class="line">lrwxrwxrwx. 1 root root   15 3月  19 02:30 blog -&gt; &#x2F;opt&#x2F;hexo&#x2F;blog&#x2F;</span><br><span class="line">drwxr-xr-x. 2 root root 4096 4月   3 22:48 C_Test</span><br><span class="line">lrwxrwxrwx. 1 root root   14 3月  19 21:17 exam -&gt; &#x2F;opt&#x2F;hexo&#x2F;exam</span><br><span class="line">lrwxrwxrwx. 1 root root   11 3月  22 02:43 share -&gt; &#x2F;mnt&#x2F;files&#x2F;</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">ls -l第一列第2~10位</th><th style="text-align:left">含义</th><th style="text-align:left">二进制</th><th style="text-align:left">八进制</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">读</td><td style="text-align:left">100</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">写</td><td style="text-align:left">010</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">执行</td><td style="text-align:left">001</td><td style="text-align:left">1</td></tr></tbody></table></div><h3 id="chmod-八进制写法"><a href="#chmod-八进制写法" class="headerlink" title="chmod 八进制写法"></a>chmod 八进制写法</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">ls -l结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>chmod 777 _config.yml</code></td><td style="text-align:left"><code>-rwxrwxrwx.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 776 _config.yml</code></td><td style="text-align:left"><code>-rwxrwxrw-.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 775 _config.yml</code></td><td style="text-align:left"><code>-rwxrwxr-x.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 774 _config.yml</code></td><td style="text-align:left"><code>-rwxrwxr--.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 773 _config.yml</code></td><td style="text-align:left"><code>-rwxrwx-wx.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 772 _config.yml</code></td><td style="text-align:left"><code>-rwxrwx-w-.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 771 _config.yml</code></td><td style="text-align:left"><code>-rwxrwx--x.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr><tr><td style="text-align:left"><code>chmod 770 _config.yml</code></td><td style="text-align:left"><code>-rwxrwx---.   1 root root     3196 3月  18 14:47 _config.yml</code></td></tr></tbody></table></div><p>u-g-o：用户-组内用户-其他用户<br>r-w-x：用4-2-1表示。<br>所有者u有全部权限：rwx; = 7<br>组内g的权限为读与写:rw- = 6<br>组外成员o的权限为只读：r— = 4 </p><h1 id="考点6-fork-方法短路或"><a href="#考点6-fork-方法短路或" class="headerlink" title="考点6:fork()方法短路或"></a>考点6:fork()方法短路或</h1><p>int main(){fork()||fork();}共创建几个进程:<em>_</em></p><ul><li>A 1</li><li>B 2</li><li>C 3</li><li>D 4</li><li>E 5</li><li>F 6</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="fork-返回值"><a href="#fork-返回值" class="headerlink" title="fork()返回值"></a>fork()返回值</h3><p>fork()<strong>给子进程返回一个零值</strong>，而<strong>给父进程返回一个非零值</strong>；<br>在main这个主进程中，首先执行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fork()|| fork()</span><br></pre></td></tr></table></figure><br>左边的fork()会复制父进程得到一个子进程，然后左边这个fork()该子进程的ID，也就是返回一个非零值，根据||的短路原则，前面的表达式为真时，后面的表达式不执行，故包含main的这个主进程创建了一个子进程。 </p><p>由于子进程会复制父进程，而且子进程会根据fork()的返回值继续执行，就是说，在子进程中的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fork()||fork()</span><br></pre></td></tr></table></figure><br>这条语句左边表达式的返回值是0，所以||右边的表达式要执行，这时在子进程中又创建了一个进程， </p><p>即main进程-&gt;子进程-&gt;孙子进程，一共创建了3个进程。 </p><p><strong>fork函数在父进程中返回新创建子进程的进程ID</strong>，大于0，此时父进程根据左值优先原则，不在与后面进行异或；<br><strong>fork函数在子进程中返回0</strong>，此时子进程仍然需要进行下一个fork函数。</p><h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><figure class="highlight c"><figcaption><span>forkTest.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork()||fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num\n"</span>);</span><br><span class="line">    <span class="comment">// sleep(100);</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost C_Test]# ls</span><br><span class="line">a.out       file1.txt  file3.txt  forkTest.c      redCharacter.out  terminalColor.c</span><br><span class="line">command.sh  file2.txt  file4.txt  redCharacter.c  strerror.c        terminalColor.out</span><br><span class="line">[root@localhost C_Test]# gcc forkTest.c -o forkTest.o</span><br><span class="line">[root@localhost C_Test]# ls</span><br><span class="line">a.out       file1.txt  file3.txt  forkTest.c  redCharacter.c    strerror.c       terminalColor.out</span><br><span class="line">command.sh  file2.txt  file4.txt  forkTest.o  redCharacter.out  terminalColor.c</span><br><span class="line">[root@localhost C_Test]# .&#x2F;forkTest.o </span><br><span class="line">num</span><br><span class="line">num</span><br><span class="line">num</span><br><span class="line">[root@localhost C_Test]#</span><br></pre></td></tr></table></figure></p><h1 id="考点7-Linux守护进程"><a href="#考点7-Linux守护进程" class="headerlink" title="考点7:Linux守护进程"></a>考点7:Linux守护进程</h1><p>网络服务的daemon是:</p><ul><li>A <code>netd</code></li><li>B <code>httpd</code></li><li>C <code>inetd</code></li><li>D <code>lpd</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>1、 Service就是指常驻内存大一些程序，且可以提供一些系统或是网络功能。提供service的那个程序就成为daemon。Daemon和service可以视为等同，不必刻意去区分。</p><h3 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h3><p>2、 Daemon可以分为两类，一类是可独立启动的，成为stand alone；另一类是通过一支super daemon来统一管理的服务。</p><p>3、 Stand alone类型的daemon能够自动启动，常驻内存，对请求响应较快，如httpd、vsftpd等。<br>4、 Super daemon统一管理的是用户有请求，super daemon就唤醒响应daemon，如果用户请求结束，就kill掉该daemon。优点不用常驻内存，缺点装到内存需要时间。如telnet。这个super daemon早期是inetd，后来被xinetd取代。<br>这里说的是网络的daemon应该指的是network daemon，netd表示network的守护进程，netd主要负责一些网络的相关配置，操作，管理和查询功能的实现</p><p>关于netd的资料找到的很少，以下是唯一找到的一片文章介绍的 <a href="http://gaozhipeng.me/posts/netd-learn1/" target="_blank">http://gaozhipeng.me/posts/netd-learn1/</a> &lt;/pre&gt;</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><blockquote><p><a href="https://zh.wikipedia.org/zh-cn/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-cn/守护进程</a><br>在一个多任务的电脑操作系统中，守护进程（英语：daemon，/ˈdiːmən/或/ˈdeɪmən/）是一种在后台执行的电脑程序。此类程序会被以进程的形式初始化。守护进程程序的名称通常以字母“d”结尾：例如，syslogd就是指管理系统日志的守护进程。<br>通常，守护进程没有任何存在的父进程（即PPID=1），且在UNIX系统进程层级中直接位于init之下。守护进程程序通常通过如下方法使自己成为守护进程：对一个子进程运行fork，然后使其父进程立即终止，使得这个子进程能在init下运行。这种方法通常被称为“脱壳”。<br>系统通常在启动时一同引导守护进程。守护进程为对网络请求，硬件活动等进行响应，或其他通过某些任务对其他应用程序的请求进行回应提供支持。守护进程也能够对硬件进行配置（如在某些Linux系统上的devfsd），运行计划任务（例如cron），以及运行其他任务。<br>在DOS环境中，此类应用程序被称为驻留程序（TSR）。在Windows系统中，由称为Windows服务的应用程序来履行守护进程的职责。<br>在原本的Mac OS系统中，此类应用程序被称为“extensions”。而作为Unix-like的Mac OS X有守护进程。（在Mac OS X中也有“服务”，但他们与Windows中类似的程序在概念上完全不相同。）<br><a href="http://c.biancheng.net/view/5935.html" target="_blank" rel="noopener">http://c.biancheng.net/view/5935.html</a></p><p><a href="https://baike.baidu.com/item/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">https://baike.baidu.com/item/守护进程</a><br>按照服务类型分为如下几个。<br>系统守护进程：syslogd、login、crond、at等。<br>网络守护进程：sendmail、httpd、xinetd、等。<br>独立启动的守护进程：httpd、named、xinetd等。<br>被动守护进程（由xinetd启动）：telnet、finger、ktalk等。</p></blockquote><h1 id="考点8-Linux多线程编程pthread库函数"><a href="#考点8-Linux多线程编程pthread库函数" class="headerlink" title="考点8:Linux多线程编程pthread库函数"></a>考点8:Linux多线程编程pthread库函数</h1><p>下述是Linux下多线程编程常用的pthread库提供的函数名和意义,说法正确的有？</p><ul><li>A <code>pthread_create</code> 创建一个线程</li><li>B <code>pthread_join</code>用来等待一个线程的结束</li><li>C <code>pthread_mutex_init</code> 初始化一个线程互斥锁</li><li>D <code>pthread_exit</code>结束一个线程</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h1 id="考点9-Nginx配置文件nginx-conf"><a href="#考点9-Nginx配置文件nginx-conf" class="headerlink" title="考点9:Nginx配置文件nginx.conf"></a>考点9:Nginx配置文件nginx.conf</h1><p>下列有关Nginx配置文件nginx.conf的叙述正确的是()</p><ul><li>A <code>nginx</code>进程数设置为<code>CPU</code>总核心数最佳</li><li>B 虚拟主机配置多个域名时,各域名间应用逗号隔开</li><li>C <code>sendfile on;</code>表示为开启高效文件传输模式,对于执行下载操作等相关应用时,应设置为<code>on</code></li><li>D 设置工作模式与连接数上限时,应考虑单个进程最大连接数(最大连接数=连接数*进程数)</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><blockquote><p>参考网络上的一篇总结。  Nginx配置文件nginx.conf中文详解<br>详见：<a href="&gt;http://www.2cto.com/os/201212/176520.html">&gt;http://www.2cto.com/os/201212/176520.html</a><br>A. 进程数设置为CPU总核心数最佳。  (正确)<br>B. 配置虚拟主机，多个域名时，用 <strong>空格</strong> 分隔。 (错误)<br>C. 设定http服务器中 sendfile on;   #开启高效文件传输模式<br>    普通应用设置为on； 用于进行下载等应用磁盘IO重负载应用，设置为<strong>off</strong>，以平衡磁盘与网络I/O处理速度，降低系统的负载。(错误)<br>D. 工作模式与连接数上限 ：（最大连接数 = 连接数 * 进程数）(正确) </p></blockquote><h1 id="考点10-DNS服务主配置文件有哪些"><a href="#考点10-DNS服务主配置文件有哪些" class="headerlink" title="考点10:DNS服务主配置文件有哪些"></a>考点10:DNS服务主配置文件有哪些</h1><p>下列不是dns服务主配置文件的是(      )。</p><ul><li>A <code>named.conf</code></li><li>B <code>dns.conf</code></li><li>C <code>name.conf</code></li><li>D <code>named.local</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年04月09日Linux专项练习1</title>
      <link href="/exam//a22040b2/"/>
      <url>/exam//a22040b2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/a22040b2/#考点1-测试网络是否连通的Linux命令" class="header_1">考点1:测试网络是否连通的Linux命令</a>&nbsp;<br><a href="/exam/a22040b2/#考点2-Samba服务器的配置文件" class="header_1">考点2:Samba服务器的配置文件</a>&nbsp;<br><a href="/exam/a22040b2/#考点3-Linux用户存放配置文件的目录" class="header_1">考点3:Linux用户存放配置文件的目录</a>&nbsp;<br><a href="/exam/a22040b2/#考点4-查看远程Linux运行了多少时间" class="header_1">考点4:查看远程Linux运行了多少时间</a>&nbsp;<br><a href="/exam/a22040b2/#考点5-计算机存储原理" class="header_1">考点5:计算机存储原理</a>&nbsp;<br><a href="/exam/a22040b2/#考点6-Linux日志-var-log-的子目录的用途" class="header_1">考点6:Linux日志/var/log/的子目录的用途</a>&nbsp;<br><a href="/exam/a22040b2/#考点7-tcpdump命令" class="header_1">考点7:tcpdump命令</a>&nbsp;<br><a href="/exam/a22040b2/#考点8-Redhat发布的Linux" class="header_1">考点8:Redhat发布的Linux</a>&nbsp;<br><a href="/exam/a22040b2/#考点9-常见Linux发行版本" class="header_1">考点9:常见Linux发行版本</a>&nbsp;<br><a href="/exam/a22040b2/#考点10-subnet命令" class="header_1">考点10:subnet命令</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-测试网络是否连通的Linux命令"><a href="#考点1-测试网络是否连通的Linux命令" class="headerlink" title="考点1:测试网络是否连通的Linux命令"></a>考点1:测试网络是否连通的Linux命令</h1><p>下列哪些命令可以测试网络通不通？</p><ul><li>A <code>ping</code></li><li>B <code>traceroute</code></li><li>C <code>netstat</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p> A，ping命令常用来查看网络连接是否相通，底层是ICMP协议。如<code>ping www.baidu.com</code><br> B, traceroute是常用的路由查看命令，用来<strong>查看数据到达某个主机经过的路由地址</strong><br> C，netstat命令用来<strong>查看本机的传输层连接状态</strong>，如TCP连接，端口等信息</p><h1 id="考点2-Samba服务器的配置文件"><a href="#考点2-Samba服务器的配置文件" class="headerlink" title="考点2:Samba服务器的配置文件"></a>考点2:Samba服务器的配置文件</h1><p>Samba 服务器的配置文件是</p><ul><li>A <code>httpd.conf</code></li><li>B <code>inetd.conf</code></li><li>C <code>rc.samba</code></li><li>D <code>smb.conf</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h3><p>SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议。</p><h3 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。</p><ul><li>WEB服务器配置文件   http.conf</li><li>WEB启动脚本配置文件   initd.conf</li><li>samba脚本          rc.samba</li><li>samba服务配置文件  smb.conf</li></ul><h1 id="考点3-Linux用户存放配置文件的目录"><a href="#考点3-Linux用户存放配置文件的目录" class="headerlink" title="考点3:Linux用户存放配置文件的目录"></a>考点3:Linux用户存放配置文件的目录</h1><p>在linux系统中,用来存放系统所需要的配置文件和子目录是</p><ul><li>A <code>/etc</code></li><li>B <code>/var</code></li><li>C <code>/root</code></li><li>D <code>/home</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><ul><li><code>etc</code>下放置配置文件</li><li><code>/var</code>下放置日志文件</li><li><code>/root</code>超级用户主目录</li><li><code>/home</code>使用者家目录</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Linux目录</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>/dev</code></td><td style="text-align:left">设备信息</td></tr><tr><td style="text-align:left"><code>/home</code></td><td style="text-align:left">家目录</td></tr><tr><td style="text-align:left"><code>/bin/sbin</code></td><td style="text-align:left">可执行文件</td></tr><tr><td style="text-align:left"><code>/etc</code></td><td style="text-align:left">系统文件</td></tr><tr><td style="text-align:left"><code>/lib/lib64</code></td><td style="text-align:left">动态库/静态库</td></tr><tr><td style="text-align:left"><code>/lost+found</code></td><td style="text-align:left">丢失文件</td></tr><tr><td style="text-align:left"><code>/opt</code></td><td style="text-align:left">第三方文件（相对于操作系统）</td></tr><tr><td style="text-align:left"><code>/root</code></td><td style="text-align:left">管理员的家目录</td></tr><tr><td style="text-align:left"><code>/usr</code></td><td style="text-align:left">第三方头文件和库</td></tr><tr><td style="text-align:left"><code>/var</code></td><td style="text-align:left">系统日志文件/缓存文件</td></tr><tr><td style="text-align:left">/etc/passwd</td><td style="text-align:left">用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。</td></tr><tr><td style="text-align:left">/etc/group</td><td style="text-align:left">类似/etc/passwd ，但说明的不是用户而是组。</td></tr><tr><td style="text-align:left">/etc/inittab</td><td style="text-align:left">init 的配置文件。</td></tr></tbody></table></div><h1 id="考点4-查看远程Linux运行了多少时间"><a href="#考点4-查看远程Linux运行了多少时间" class="headerlink" title="考点4:查看远程Linux运行了多少时间"></a>考点4:查看远程Linux运行了多少时间</h1><p>在Shell环境下,如何查看远程Linux系统运行了多少时间？</p><ul><li>A scp user@被监控主机ip “uptime”</li><li>B ssh user@被监控主机ip “uptime”</li><li>C ssh user@被监控主机ip “cputime”</li><li>D scp user@被监控主机ip “cputime”</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><ul><li>scp用于远程数据传输</li><li>ssh用于远程登录</li><li>uptime命令可以查看当前linux系统运行了多长时间</li></ul><p><a href="https://www.cnblogs.com/joshua317/articles/4740881.html" target="_blank" rel="noopener">https://www.cnblogs.com/joshua317/articles/4740881.html</a></p><h3 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h3><p>ssh命令用于远程登录上Linux主机。<br>常用格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-l login_name] [-p port] [user@]hostname</span><br></pre></td></tr></table></figure></p><h3 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h3><p>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [可选参数] file_source file_target</span><br></pre></td></tr></table></figure><h3 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h3><p><strong>uptime命令</strong>能够打印系统总共运行了多长时间和系统的平均负载。<br>uptime命令可以显示的信息显示依次为：<br>现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。<br><a href="http://man.linuxde.net/uptime" target="_blank" rel="noopener">http://man.linuxde.net/uptime</a></p><h1 id="考点5-计算机存储原理"><a href="#考点5-计算机存储原理" class="headerlink" title="考点5:计算机存储原理"></a>考点5:计算机存储原理</h1><p>下面关于计算机存储原理说法错误的是 。</p><ul><li>A 存储器由大量可以存储二进制数据的存储单元组成</li><li>B 数据总线从存储器中获取数据的过程称为写操作</li><li>C 程序执行时,读取指令是指计算机自动从存储器中取出一条指令</li><li>D 虚拟存储技术缓解主存容量小的矛盾</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>考察的是计算机存储结构原理<br>存储位：存放<strong>二进制</strong>单元，是存储器最小的存储单位。  从存储器获取为读操作。存储到存储器为写操作。<br>虚拟存储技术：当进程运行时，先将其中一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将他们从磁盘调入内存的工作  <img src="https://uploadfiles.nowcoder.com/images/20200218/300975041_1582039439525_DF41582E9D728E37EF30F19724309CF6"></p><h1 id="考点6-Linux日志-var-log-的子目录的用途"><a href="#考点6-Linux日志-var-log-的子目录的用途" class="headerlink" title="考点6:Linux日志/var/log/的子目录的用途"></a>考点6:Linux日志/var/log/的子目录的用途</h1><p>你被需要检查系统中的设备情况,需要检查哪个log日志？</p><ul><li>A <code>/var/log/tmp</code></li><li>B <code>/var/log/lastlog</code></li><li>C <code>/var/log/messages</code></li><li>D <code>/var/log/utmp</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="var-log子目录"><a href="#var-log子目录" class="headerlink" title="/var/log子目录"></a>/var/log子目录</h3><div class="table-container"><table><thead><tr><th style="text-align:left">/var/log子目录</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>/var/log/messages</strong></td><td style="text-align:left">包括整体系统信息，其中也包含系统启动期间的日志。此外，mail，cron，daemon，kern和auth等内容也记录在var/log/messages日志中。</td></tr><tr><td style="text-align:left">/<strong>var/log/dmesg</strong></td><td style="text-align:left">包含内核缓冲信息（kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用dmesg查看它们。</td></tr><tr><td style="text-align:left"><strong>/var/log/auth.log</strong></td><td style="text-align:left">包含系统授权信息，包括用户登录和使用的权限机制等。</td></tr><tr><td style="text-align:left"><strong>/var/log/boot.log</strong></td><td style="text-align:left">包含系统启动时的日志。</td></tr><tr><td style="text-align:left"><strong>/var/log/daemon.log</strong></td><td style="text-align:left">包含各种系统后台守护进程日志信息。</td></tr><tr><td style="text-align:left"><strong>/var/log/dpkg.log</strong></td><td style="text-align:left">包括安装或dpkg命令清除软件包的日志。</td></tr><tr><td style="text-align:left"><strong>/var/log/kern.log</strong></td><td style="text-align:left">包含内核产生的日志，有助于在定制内核时解决问题。</td></tr><tr><td style="text-align:left"><strong>/var/log/lastlog</strong></td><td style="text-align:left">记录所有用户的最近信息。这不是一个ASCII文件，因此需要用lastlog命令查看内容。</td></tr><tr><td style="text-align:left"><strong>/var/log/maillog /var/log/mail.log</strong></td><td style="text-align:left">包含来着系统运行电子邮件服务器的日志信息。例如，sendmail日志信息就全部送到这个文件中。</td></tr><tr><td style="text-align:left"><strong>/var/log/user.log</strong></td><td style="text-align:left">记录所有等级用户信息的日志。</td></tr><tr><td style="text-align:left"><strong>/var/log/Xorg.x.log</strong></td><td style="text-align:left">来自X的日志信息。</td></tr><tr><td style="text-align:left"><strong>/var/log/alternatives.log</strong></td><td style="text-align:left">更新替代信息都记录在这个文件中。</td></tr><tr><td style="text-align:left"><strong>/var/log/btmp</strong></td><td style="text-align:left">记录所有失败登录信息。使用last命令可以查看btmp文件。例如，”last -f /var/log/btmp &#124; more”。</td></tr><tr><td style="text-align:left"><strong>/var/log/cups</strong></td><td style="text-align:left">涉及所有打印信息的日志。</td></tr><tr><td style="text-align:left"><strong>/var/log/anaconda.log</strong></td><td style="text-align:left">在安装Linux时，所有安装信息都储存在这个文件中。</td></tr><tr><td style="text-align:left"><strong>/var/log/yum.log</strong></td><td style="text-align:left">包含使用yum安装的软件包信息。</td></tr><tr><td style="text-align:left"><strong>/var/log/cron</strong></td><td style="text-align:left">每当cron进程开始一个工作时，就会将相关信息记录在这个文件中。</td></tr><tr><td style="text-align:left"><strong>/var/log/secure</strong></td><td style="text-align:left">包含验证和授权方面信息。例如，sshd会将所有信息记录（其中包括失败登录）在这里。</td></tr><tr><td style="text-align:left"><strong>/var/log/wtmp或/var/log/utmp</strong></td><td style="text-align:left">包含登录信息。使用wtmp可以找出谁正在登陆进入系统，谁使用命令显示这个文件或信息等。</td></tr><tr><td style="text-align:left"><strong>/var/log/faillog</strong></td><td style="text-align:left">包含用户登录失败信息。此外，错误登录命令也会记录在本文件中。</td></tr></tbody></table></div><h3 id="特定应用相关的-var-log-的子目录"><a href="#特定应用相关的-var-log-的子目录" class="headerlink" title="特定应用相关的/var/log/的子目录"></a>特定应用相关的/var/log/的子目录</h3><p>除了上述Log文件以外，<br>/var/log还基于系统的具体应用包含以下一些子目录：</p><div class="table-container"><table><thead><tr><th style="text-align:left">应用相关的/var/log子目录</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">/var/log/httpd/或/var/log/apache2</td><td style="text-align:left">包含服务器access_log和error_log信息。</td></tr><tr><td style="text-align:left">/var/log/lighttpd/</td><td style="text-align:left">包含light HTTPD的access_log和error_log。</td></tr><tr><td style="text-align:left">/var/log/mail/</td><td style="text-align:left">这个子目录包含邮件服务器的额外日志。</td></tr><tr><td style="text-align:left">/var/log/prelink/</td><td style="text-align:left">包含.so文件被prelink修改的信息。</td></tr><tr><td style="text-align:left">/var/log/audit/</td><td style="text-align:left">包含被 Linux audit daemon储存的信息。</td></tr><tr><td style="text-align:left">/var/log/samba/</td><td style="text-align:left">包含由samba存储的信息。</td></tr><tr><td style="text-align:left">/var/log/sa/</td><td style="text-align:left">包含每日由sysstat软件包收集的sar文件。</td></tr><tr><td style="text-align:left">/var/log/sssd/</td><td style="text-align:left">用于守护进程安全服务。</td></tr></tbody></table></div><h1 id="考点7-tcpdump命令"><a href="#考点7-tcpdump命令" class="headerlink" title="考点7:tcpdump命令"></a>考点7:tcpdump命令</h1><p>linux tcpdump监听网卡 eth0,对方主机IP为10.1.1.180,tcp端口为80的数据,相应命令为？</p><ul><li>A tcpdump -h eth0 -nn ‘tcp and host 10.1.1.180:80’</li><li>B tcpdump -i eth0 -nn ‘tcp and host 10.1.1.180:80’</li><li>C tcpdump -h eth0 -nn ‘tcp and port 80 and host 10.1.1.180’</li><li>D tcpdump -i eth0 -nn ‘tcp and port 80 and host 10.1.1.180’</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>tcpdump抓包命令：用于截取网络分组，并输出分组内容的工具</p><div class="table-container"><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-A</td><td style="text-align:left">以ASCII格式打印所有分组，常用于www的网页的数据抓取</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">收到指定的数量的分组后，停止tcpdump</td></tr><tr><td style="text-align:left">-C</td><td style="text-align:left">将一个原始分组写入文件之前，检查文件的当前大小是否超过了file_size的指定大小，超过则关闭当前文件然后打开一个新文件，、</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">将匹配信心包的代码以人们能够理解的汇编格式给出</td></tr><tr><td style="text-align:left">-dd</td><td style="text-align:left">将匹配信息的代码以C语言程序段的格式给出</td></tr><tr><td style="text-align:left">-ddd</td><td style="text-align:left">将匹配信息的代码以十进制的形式给出</td></tr><tr><td style="text-align:left">-D</td><td style="text-align:left">打印系统中所有的可以用tcpdump截包的网络接口</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">输出行打印数据链路层的头部信息</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">将外部的internet地址以数字的形式打印</td></tr><tr><td style="text-align:left">-F</td><td style="text-align:left">从指定的文件中读取表达式，忽略命令行中给出的表达式、</td></tr><tr><td style="text-align:left"><strong>-i</strong></td><td style="text-align:left"><strong>指定监听的网络接口</strong></td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">使标准输出变成缓冲形式，可以把数据导出到文件</td></tr><tr><td style="text-align:left">-L</td><td style="text-align:left">列出网络接口的已知数据链路</td></tr><tr><td style="text-align:left">-b</td><td style="text-align:left">在数据链路层选择协议：ip arp rarp ipx</td></tr><tr><td style="text-align:left">-n</td><td style="text-align:left">不把网络地址转成名字</td></tr><tr><td style="text-align:left"><strong>-nn</strong></td><td style="text-align:left">不进行端口名称的转换</td></tr><tr><td style="text-align:left">-N</td><td style="text-align:left">不输出主机名中的域名部分</td></tr><tr><td style="text-align:left">-t</td><td style="text-align:left">输出的每一行不打印时间戳</td></tr><tr><td style="text-align:left">-tt</td><td style="text-align:left">在每一行中输出非格式化的时间戳</td></tr><tr><td style="text-align:left">-ttt</td><td style="text-align:left">输出本行和前面一行之间的时间差</td></tr><tr><td style="text-align:left">-tttt</td><td style="text-align:left">在每一行中输出由date处理的默认格式的时间戳</td></tr><tr><td style="text-align:left">-O</td><td style="text-align:left">不运行分组匹配代码优化程序</td></tr><tr><td style="text-align:left">-P</td><td style="text-align:left">不将网络接口设置成混杂模式</td></tr><tr><td style="text-align:left">-q</td><td style="text-align:left">快速输出，只输出较少的协议信息</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">从指定文件中读取包</td></tr><tr><td style="text-align:left">-S</td><td style="text-align:left">将tcp的序列号以绝对值形式输出，而不是相对值</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">从每个分组中读取最开始的snaplen个字节】</td></tr><tr><td style="text-align:left">-T</td><td style="text-align:left">将监听的包直接解释为指定类型的报文，常见有rpc远程过程调用，和snmp</td></tr><tr><td style="text-align:left">-v</td><td style="text-align:left">输出一个详细信息</td></tr><tr><td style="text-align:left">-vv</td><td style="text-align:left">输出详细的报文信息</td></tr><tr><td style="text-align:left">-w</td><td style="text-align:left">直接将分组写入文件中，而不是不分析打印</td></tr><tr><td style="text-align:left">-x</td><td style="text-align:left">可以列出16进制以及ASCII的数据包的内容</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i 网路接口名字</span><br></pre></td></tr></table></figure><p>并且需要带上端口号</p><h1 id="考点8-Redhat发布的Linux"><a href="#考点8-Redhat发布的Linux" class="headerlink" title="考点8:Redhat发布的Linux"></a>考点8:Redhat发布的Linux</h1><p>在Redhat公司发布的Linux版本中,若要使得用户登录验证,需要修改以下<strong>_</strong>脚本。</p><ul><li>A <code>/etc/inittab</code></li><li>B <code>/etc/passwd</code></li><li>C <code>/etc/shadow</code></li><li>D <code>/etc/group</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="etc目录的inittab-passwd-shadow-group文件的作用"><a href="#etc目录的inittab-passwd-shadow-group文件的作用" class="headerlink" title="/etc目录的inittab passwd shadow group文件的作用"></a>/etc目录的inittab passwd shadow group文件的作用</h3><div class="table-container"><table><thead><tr><th style="text-align:left">/etc目录常用文件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>/etc/inittab</code></td><td style="text-align:left">配置文件用来设置系统的默认<strong>运行级别</strong>。</td></tr><tr><td style="text-align:left"><code>/etc/passwd</code></td><td style="text-align:left">这个文件存放着所有用户帐号的信息，包括用户名和密码，因此，它对系统来说是至关重要的。</td></tr><tr><td style="text-align:left"><code>/etc/shadow</code></td><td style="text-align:left"><strong>用于存储 Linux 系统中用户的密码信息，又称为“影子文件”。</strong></td></tr><tr><td style="text-align:left"><code>/etc/group</code></td><td style="text-align:left">该文件是用户组配置文件，即用户组的所有信息都存放在此文件中</td></tr></tbody></table></div><p>其中，<strong>/ect/passwd用来保存用户的基本信息，而/etc/shadow用来保存所有用户的密码</strong></p><h3 id="etc-shadow文件作用"><a href="#etc-shadow文件作用" class="headerlink" title="/etc/shadow文件作用"></a>/etc/shadow文件作用</h3><p>shadow文件只是用来存储用户的密码，shadow的文件的第二个字段表示该用户是否有设置密码，而用户登录是否需要验证还是要看passwd文件的第二个字段。</p><ul><li>如果第二个字段为空，表示该用户登录不需要验证。</li><li>如果第二个字段为x，表示该用户登录需要进行验证。</li></ul><h1 id="考点9-常见Linux发行版本"><a href="#考点9-常见Linux发行版本" class="headerlink" title="考点9:常见Linux发行版本"></a>考点9:常见Linux发行版本</h1><p>以下哪几种属于Linux操作系统的发行版？</p><ul><li>A <code>CentOS</code></li><li>B <code>Ubuntu</code></li><li>C <code>macOS</code></li><li>D <code>Redhat</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>CentOS：国内非常火的红帽系服务器系统<br>Ubuntu：很流行的桌面Linux版本<br>macOS：苹果的桌面系统，它的内核是不基于Linux的, macOS是类Unix系统<br>Redhat：红帽Linux系统</p><h1 id="考点10-subnet命令"><a href="#考点10-subnet命令" class="headerlink" title="考点10:subnet命令"></a>考点10:subnet命令</h1><p>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnet 166.173.197.131 netmask 255.255.255.192&#123;</span><br><span class="line">range 166.173.197.10 166.173.197.107;</span><br><span class="line">default-lease-time 600;</span><br><span class="line">max-lease-time 7200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>表示？()</p><ul><li>A 向166.173.197.10网络分配从166.173.197.133到166.173.197.255</li><li>B 一个两小时的最大租用时间</li><li>C 指定了一个十分钟的缺省租用时间</li><li>D 网络地址166.173.197.0</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p><code>subnet</code>设置一个子网<code>166.173.197.131/24</code></p><ul><li><code>range</code>：可分配的<code>IP</code>地址范围上<code>166.173.197.10 ~ 166.173.197.107</code></li><li><code>default-lease-time</code>：默认租约时间</li><li><code>max-lease-time</code>：最大租约时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年04月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月31日Linux专项练习1</title>
      <link href="/exam//bf531909/"/>
      <url>/exam//bf531909/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/bf531909/#考点1-Linux修改权限命令-chmod命令" class="header_1">考点1:Linux修改权限命令_chmod命令</a>&nbsp;<br><a href="/exam/bf531909/#考点2-UNIX目录结构" class="header_1">考点2:UNIX目录结构</a>&nbsp;<br><a href="/exam/bf531909/#考点3" class="header_1">考点3:</a>&nbsp;<br><a href="/exam/bf531909/#考点4-记录已经加载的文件系统的文件" class="header_1">考点4:记录已经加载的文件系统的文件</a>&nbsp;<br><a href="/exam/bf531909/#考点5-Linux列举当前目录" class="header_1">考点5:Linux列举当前目录</a>&nbsp;<br><a href="/exam/bf531909/#考点6-Linux查看文件命令" class="header_1">考点6:Linux查看文件命令</a>&nbsp;<br><a href="/exam/bf531909/#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="header_1">考点7:Linux查看CPU Swap分区 硬盘信息命令</a>&nbsp;<br><a href="/exam/bf531909/#考点8-日志文件系统有哪些" class="header_1">考点8:日志文件系统有哪些</a>&nbsp;<br><a href="/exam/bf531909/#考点9-系统调用" class="header_1">考点9:系统调用</a>&nbsp;<br><a href="/exam/bf531909/#考点10" class="header_1">考点10:</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux修改权限命令-chmod命令"><a href="#考点1-Linux修改权限命令-chmod命令" class="headerlink" title="考点1:Linux修改权限命令_chmod命令"></a>考点1:Linux修改权限命令_chmod命令</h1><p>Linux下,为某个脚本赋予可执行权限()</p><ul><li>A <code>chmod +x filename.sh</code></li><li>B <code>chown +x filename.sh</code></li><li>C <code>chmod +r filename.sh</code></li><li>D <code>chown +r filename.sh</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>chmod命令修改权限 +x表示增加执行权限，+r表示增加读取权限，+w表示增加写权限  chown将指定文件的拥有者改为指定的用户或组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 3766</span><br><span class="line">-rwxr-xr-x 1 lan 197609     183  3月 19 21:32 hexos.sh*</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx</span><br><span class="line">111</span><br><span class="line">421</span><br></pre></td></tr></table></figure></p><h1 id="考点2-UNIX目录结构"><a href="#考点2-UNIX目录结构" class="headerlink" title="考点2:UNIX目录结构"></a>考点2:UNIX目录结构</h1><p>在UNIX系统中,目录结构采用( )</p><ul><li>A 单级目录结构</li><li>B 二级目录结构</li><li>C 单纯树形目录结构</li><li>D 带链接树形目录结构</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>带链接树形目录结构又称非循环图目录结构,它是指访问一文件(或目录)可以有多条路径。一般常说UNIX的文件系统是树形结构，其实是指带链接的树形结构，而不是纯树形目录结构。 </p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3:"></a>考点3:</h1><p>一个文件名字为rr.Z,可以用来解压缩的命令是？</p><ul><li>A <code>tar</code></li><li>B <code>gzip</code></li><li>C <code>compress</code></li><li>D <code>uncompress</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><ul><li><code>tar</code>: 操作.<code>tar</code>的命令</li><li><code>gzip</code>: 压缩.<code>gz</code>压缩包的命令</li><li><code>compress</code>：压缩.Z文件</li><li><code>uncompress</code>：解压缩.Z文件</li></ul><h1 id="考点4-记录已经加载的文件系统的文件"><a href="#考点4-记录已经加载的文件系统的文件" class="headerlink" title="考点4:记录已经加载的文件系统的文件"></a>考点4:记录已经加载的文件系统的文件</h1><p>系统当前已经加载的所有文件系统在<strong><strong>_</strong></strong>文件中得到反映。</p><ul><li>A <code>/usr/sbin/cfdisk</code></li><li>B <code>/sbin/fdisk</code></li><li>C <code>/etc/mtab</code></li><li>D <code>/etc/fstab</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p> <strong>/etc/mtab文件的作用</strong>：记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而/etc/fstab是系统准备装载的<br> <strong>etc/fstab文件的作用</strong>：记录了计算机上硬盘分区的相关信息，启动 Linux 的时候，检查分区的<br> fsck 命令，和挂载分区的 mount 命令，都需要 fstab 中的信息，来正确的检查和挂载硬盘。</p><h1 id="考点5-Linux列举当前目录"><a href="#考点5-Linux列举当前目录" class="headerlink" title="考点5:Linux列举当前目录"></a>考点5:Linux列举当前目录</h1><p>在linux中,列举当前目录下文件的是哪个命令<strong>__</strong>。</p><ul><li>A <code>ps</code></li><li>B <code>cd</code></li><li>C <code>mv</code></li><li>D <code>ls</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><ul><li>ps 查看运行中的进程</li><li>cd 进入某个目录</li><li>mv 移动文件或者文件夹</li><li>ls list的缩写，列出某个目录下的文件或者文件夹</li></ul><h1 id="考点6-Linux查看文件命令"><a href="#考点6-Linux查看文件命令" class="headerlink" title="考点6:Linux查看文件命令"></a>考点6:Linux查看文件命令</h1><p>在Linux下查看文件有多种方法,若希望在查看文件内容过程中,可以按空格实现翻页,应使用(      )命令</p><ul><li>A <code>cat</code></li><li>B <code>more</code></li><li>C <code>less</code></li><li>D <code>head</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><ul><li>cat：由第一行开始显示文件所有内容； </li><li>tac：从最后一行开始显示文件的所有内容，<ul><li>注意 tac 与cat 写法正好相反； </li></ul></li><li>more：一页一页的显示文件内容，只能向后翻页； </li><li>less：也是一页一页显示文件内容，但是可以通过键盘上的【pagedown】，【pageup】控制向后，向前翻页； </li><li>head：显示一个文件的前几行； </li><li>tail：显示一个文件的后几行； </li></ul><h1 id="考点7-Linux查看CPU-Swap分区-硬盘信息命令"><a href="#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="headerlink" title="考点7:Linux查看CPU Swap分区 硬盘信息命令"></a>考点7:Linux查看CPU Swap分区 硬盘信息命令</h1><p>如何在命令行查看一台linux机器的CPU、SWAP分区信息、硬盘信息?</p><ul><li>A <code>cat /proc/cpuinfo</code></li><li>B <code>du</code></li><li>C <code>cat /proc/swaps</code></li><li>D <code>df -lh</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><p>-<code>cat /proc/cpuinfo</code>：查看一台<code>linux</code>机器的<code>CPU</code>信息<br>-<code>du</code>：查看该目录占用文件系统数据块的情况<br>-<code>cat /proc/swaps</code>：查看<code>SWAP</code>分区信息<br>-<code>df -lh</code>：查看硬盘信息</p><h1 id="考点8-日志文件系统有哪些"><a href="#考点8-日志文件系统有哪些" class="headerlink" title="考点8:日志文件系统有哪些"></a>考点8:日志文件系统有哪些</h1><p>以下哪个是日志文件系统()</p><ul><li>A <code>ext2</code></li><li>B <code>fat32</code></li><li>C <code>ntfs</code></li><li>D <code>ext3</code></li><li>E <code>ext4</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details><p>日志文件系统（英语：Journaling file system）是一种文件系统。在发生变化时，它先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。</p><h3 id="常见的日志文件系统"><a href="#常见的日志文件系统" class="headerlink" title="常见的日志文件系统"></a>常见的日志文件系统</h3><p>JFS：IBM的 Journaled File System, 最早的日志文件系统。<br>Ext4/Ext3文件系统：由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。<br>XFS文件系统：广泛用于Linux系统，取代了Ext4。<br>ReiserFS：用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。<br>Btrfs：用B树作为数据结构，被认为是下一代Linux文件系统。<br>NTFS：微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。<br>HFS+：苹果公司发展的OS X操作系统下主要使用的文件系统。</p><h1 id="考点9-系统调用"><a href="#考点9-系统调用" class="headerlink" title="考点9:系统调用"></a>考点9:系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p><ul><li>A <code>nmap</code></li><li>B <code>read</code></li><li>C <code>execve</code></li><li>D <code>fork</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><ul><li>任何shell都会执行 exec 和 fork</li><li>而ls会执行read</li><li>三个加起来就是read,execve,fork</li></ul><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10:"></a>考点10:</h1><p>linux 2.6.* 内核默认支持的文件系统有哪些？</p><ul><li>A <code>ext3</code></li><li>B <code>ext2</code></li><li>C <code>ext4</code></li><li>D <code>xfs</code></li><li>E <code>ufs</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>背答案算了</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月23日Linux专项练习4</title>
      <link href="/exam//3a8d0894/"/>
      <url>/exam//3a8d0894/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3a8d0894/#考点1-如何修改文件权限" class="header_1">考点1:如何修改文件权限</a>&nbsp;<br><a href="/exam/3a8d0894/#考点2-hardware-filename-fixed-address-server-name命令" class="header_1">考点2:hardware filename fixed-address server-name命令</a>&nbsp;<br><a href="/exam/3a8d0894/#考点3-ls-df-du-fine命令" class="header_1">考点3:ls df du fine命令</a>&nbsp;<br><a href="/exam/3a8d0894/#考点4-Linux命令返回值" class="header_1">考点4:Linux命令返回值</a>&nbsp;<br><a href="/exam/3a8d0894/#考点5-查看文件命令cat-more-tail" class="header_1">考点5:查看文件命令cat more tail</a>&nbsp;<br><a href="/exam/3a8d0894/#考点5-vi编辑器的三种模式" class="header_1">考点5:vi编辑器的三种模式</a>&nbsp;<br><a href="/exam/3a8d0894/#考点6-useradd命令" class="header_1">考点6:useradd命令</a>&nbsp;<br><a href="/exam/3a8d0894/#考点7-多进程同时操作一个文件" class="header_1">考点7:多进程同时操作一个文件</a>&nbsp;<br><a href="/exam/3a8d0894/#考点8-TCP握手-分手" class="header_1">考点8:TCP握手 分手</a>&nbsp;<br><a href="/exam/3a8d0894/#考点9-Linux日志文件" class="header_1">考点9:Linux日志文件</a>&nbsp;<br><a href="/exam/3a8d0894/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-如何修改文件权限"><a href="#考点1-如何修改文件权限" class="headerlink" title="考点1:如何修改文件权限"></a>考点1:如何修改文件权限</h1><p>怎样更改一个文件的权限设置？</p><ul><li>A <code>chmod</code></li><li>B <code>file</code></li><li>C <code>attrib</code></li><li>D <code>change</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>chmod 是change &nbsp;mode of file 的缩写，改变文件的的读写权限。</p><h1 id="考点2-hardware-filename-fixed-address-server-name命令"><a href="#考点2-hardware-filename-fixed-address-server-name命令" class="headerlink" title="考点2:hardware filename fixed-address server-name命令"></a>考点2:hardware filename fixed-address server-name命令</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p><ul><li>A <code>server-name</code></li><li>B <code>fixed-address</code></li><li>C <code>filename</code></li><li>D <code>hardware</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="hardware语句"><a href="#hardware语句" class="headerlink" title="hardware语句"></a>hardware语句</h3><p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hardware hardware-type hardware-address;</span><br></pre></td></tr></table></figure><br>指明物理硬件接口类型和硬件地址。硬件地址由6个8位组构成，每个8位组以“：”隔开。如00：00：E8：1B：54：97</p><h3 id="server-name-语句"><a href="#server-name-语句" class="headerlink" title="server-name 语句"></a>server-name 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-name <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure><p>用于告诉客户服务器的名字。</p><h3 id="fixed-address-语句"><a href="#fixed-address-语句" class="headerlink" title="fixed-address 语句"></a>fixed-address 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed-address address [, address ... ];</span><br></pre></td></tr></table></figure><p>fixed-address 语句用于指定一个或多个IP地址给一个DHCP客户。只能出现在host声明里。</p><h1 id="考点3-ls-df-du-fine命令"><a href="#考点3-ls-df-du-fine命令" class="headerlink" title="考点3:ls df du fine命令"></a>考点3:ls df du fine命令</h1><p>下列哪个命令可以看到文件的大小？(不添加参数的情况下)</p><ul><li>A <code>ls</code></li><li>B <code>df</code></li><li>C <code>du</code></li><li>D <code>find</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>A：ls是list的缩写，用来显示当前目录下面文件的信息；如果要查看文件的大小则需要加上-al参数<br>B：df是disk free的缩写，用来显示文件系统中不同磁盘的使用情况；<br>C：du是disk usage的缩写，显示当前目录或者当前文件的占用的块大小；<br>D：find命令作用在目录下，用来查找指定目录或者当前目录下的文件。</p><h2 id="ls-l查看文件大小"><a href="#ls-l查看文件大小" class="headerlink" title="ls -l查看文件大小"></a>ls -l查看文件大小</h2><p>参考资料：<a href="https://www.cnblogs.com/sparkdev/p/7476005.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/7476005.html</a><br>ls -al命令输出的第5列就是该文件或目录的大小（以字节为单位显示的文件大小）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l exam&#x2F;</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root    3093 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3498022 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root     158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root     576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root     174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root     376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root    8192 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root     817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root  170424 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root    4096 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root    4096 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root     422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root    4096 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="ls-lh"><a href="#ls-lh" class="headerlink" title="ls -lh"></a>ls -lh</h3><p>在 Linux 命令中，涉及到文件大小的地方，一般默认是以字节为单位显示的。这样可读性就不是很好。所以有了 -h 选项！这个选项的全称是 —human-readable(给人读的)。也就是以 K, M, G 等单位来显示文件的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh exam&#x2F;</span><br><span class="line">总用量 3.6M</span><br><span class="line">-rw-r--r--.   1 root root 3.1K 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3.4M 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root  158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root  576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root  431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root  174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root  376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root 8.0K 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root 167K 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root 4.0K 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root 4.0K 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root  422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root 4.0K 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="考点4-Linux命令返回值"><a href="#考点4-Linux命令返回值" class="headerlink" title="考点4:Linux命令返回值"></a>考点4:Linux命令返回值</h1><p>linux命令执行成功后会返回</p><ul><li>A 0</li><li>B 1</li><li>C 2</li><li>D -1</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="Linux命令返回值"><a href="#Linux命令返回值" class="headerlink" title="Linux命令返回值"></a>Linux命令返回值</h3><p>参考资料：<br><a href="https://blog.csdn.net/cy413026/article/details/104172448" target="_blank" rel="noopener">https://blog.csdn.net/cy413026/article/details/104172448</a><br>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306" target="_blank" rel="noopener">https://blog.csdn.net/u013457167/article/details/79196306</a></p><p>在shell终端中，你所输入的一切命令其实都有返回值，而这个返回值默认保存在变量<code>$?</code>中，举例看一下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"> </span><br><span class="line">grup_pwd=`cat /etc/grub.conf | grep -v ^# | grep password 2&gt; /dev/null`</span><br><span class="line"> </span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">   echo "  [ √ ] 已设置grub密码,符合要求"</span><br><span class="line">else</span><br><span class="line">   echo "  [ X ] 没有设置grub密码，不符合要求,建议设置grub密码"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="Linux错误码含义"><a href="#Linux错误码含义" class="headerlink" title="Linux错误码含义"></a>Linux错误码含义</h3><p>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306" target="_blank" rel="noopener">https://blog.csdn.net/u013457167/article/details/79196306</a></p><h1 id="考点5-查看文件命令cat-more-tail"><a href="#考点5-查看文件命令cat-more-tail" class="headerlink" title="考点5:查看文件命令cat more tail"></a>考点5:查看文件命令cat more tail</h1><p>为了查看不断更新的日志文件,可以使用的指令是()</p><ul><li>A <code>cat -n</code></li><li>B <code>vi</code></li><li>C <code>more</code></li><li>D <code>tail -f</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>linux 下tail用于查看档案的结尾，-f 参数是follow的意思，当文件增长时，输出后续添加的数据。所以使用使用tail命令的-f选项可以方便的查阅正在改变的日志文件。<br>Linux tail 命令：<a href="https://www.runoob.com/linux/linux-comm-tail.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-tail.html</a></p><h1 id="考点5-vi编辑器的三种模式"><a href="#考点5-vi编辑器的三种模式" class="headerlink" title="考点5:vi编辑器的三种模式"></a>考点5:vi编辑器的三种模式</h1><p>在RHEL5系统中,在vi编辑器环境中的任意时刻,选择”ESC”键后,编辑器将进入(  )模式</p><ul><li>A 命令</li><li>B 输入</li><li>C 末行</li><li>D 文本</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>vim编辑器可以分为三种模式：<br>1.命令模式：控制屏幕光标的移动，进行文本的删除，复制等文字编辑工作，不使用【del】和【backspace】键，以及进入插入模式或者回到底行模式；<br>2.插入模式：只有在插入模式下，才可以输入文字，按【esc】可以回到命令模式，vim编辑器一打开是不可以输入的，因为刚打开时候处于命令模式;<br>3.底行模式：保存文件或者退出vim，也可以设置编辑环境和一些编译工作。<br><img src="https://uploadfiles.nowcoder.com/images/20180619/3431580_1529372993152_25A1FCC1486B869925E23FECFEBADC61" alt=""></p><h1 id="考点6-useradd命令"><a href="#考点6-useradd命令" class="headerlink" title="考点6:useradd命令"></a>考点6:useradd命令</h1><p>创建用户时不指定用户主目录的参数(      )</p><ul><li>A <code>useradd -o</code></li><li>B <code>useradd -m</code></li><li>C <code>useradd -M</code></li><li>D <code>useradd -d</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">useradd参数</th><th style="text-align:left">全称</th><th style="text-align:left">释义</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">base-dir BASE_DIR</td><td style="text-align:left">新账户的主目录的基目录</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">comment COMMENT</td><td style="text-align:left">新账户的 GECOS 字段</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">home-dir HOME_DIR</td><td style="text-align:left">新账户的主目录</td></tr><tr><td style="text-align:left">-D</td><td style="text-align:left">defaults</td><td style="text-align:left">显示或更改默认的 useradd 配置</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">expiredate EXPIRE_DATE</td><td style="text-align:left">新账户的过期日期</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">inactive INACTIVE</td><td style="text-align:left">新账户的密码不活动期</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">gid GROUP</td><td style="text-align:left">新账户主组的名称或 ID</td></tr><tr><td style="text-align:left">-G</td><td style="text-align:left">groups GROUPS</td><td style="text-align:left">新账户的附加组列表</td></tr><tr><td style="text-align:left">-h</td><td style="text-align:left">help</td><td style="text-align:left">显示此帮助信息并推出</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">skel SKEL_DIR</td><td style="text-align:left">使用此目录作为骨架目录</td></tr><tr><td style="text-align:left">-K</td><td style="text-align:left">key KEY=VALUE</td><td style="text-align:left">不使用 /etc/login.defs 中的默认值</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">no-log-init</td><td style="text-align:left">不要将此用户添加到最近登录和登录失败数据库</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">create-home</td><td style="text-align:left">创建用户的主目录</td></tr><tr><td style="text-align:left">-M</td><td style="text-align:left">no-create-home</td><td style="text-align:left">不创建用户的主目录</td></tr><tr><td style="text-align:left">-N</td><td style="text-align:left">no-user-group</td><td style="text-align:left">不创建同名的组</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">non-unique</td><td style="text-align:left">允许使用重复的 UID 创建用户</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">password PASSWORD</td><td style="text-align:left">加密后的新账户密码</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">system</td><td style="text-align:left">创建一个系统账户</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">shell SHELL</td><td style="text-align:left">新账户的登录 shell</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">uid UID</td><td style="text-align:left">新账户的用户 ID</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">user-group</td><td style="text-align:left">创建与用户同名的组</td></tr><tr><td style="text-align:left">-Z</td><td style="text-align:left">selinux-user SEUSER</td><td style="text-align:left">为 SELinux 用户映射使用指定 SEUSER</td></tr></tbody></table></div><h1 id="考点7-多进程同时操作一个文件"><a href="#考点7-多进程同时操作一个文件" class="headerlink" title="考点7:多进程同时操作一个文件"></a>考点7:多进程同时操作一个文件</h1><p>Linux下两个进程可以同时打开同一个文件,这时如下描述错误的是:</p><ul><li>A 两个进程中分别产生生成两个独立的<code>fd</code></li><li>B 两个进程可以任意对文件进行读写操作,操作系统并不保证写的原子性</li><li>C 进程可以通过系统调用对文件加锁,从而实现对文件内容的保护</li><li>D 任何一个进程删除该文件时,另外一个进程会立即出现读写失败</li><li>E 两个进程可以分别读取文件的不同部分而不会相互影响</li><li>F 一个进程对文件长度和内容的修改另外一个进程可以立即感知</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>一般删除都是文件索引，如果两个文件同时打开同一个文件，一个线程执行删除操作，只要另一个线程不退出，就可以继续对该文件进行操作，一旦退出才找不到该文件的索引节点而报错。</p><p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程.<br><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html</a><br><a href="http://blog.chinaunix.net/uid-26548237-id-3046664.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26548237-id-3046664.html</a></p><h1 id="考点8-TCP握手-分手"><a href="#考点8-TCP握手-分手" class="headerlink" title="考点8:TCP握手 分手"></a>考点8:TCP握手 分手</h1><p>TCP的握手与分手,可能出现的情形有()。</p><ul><li>A 握手需要3次通信</li><li>B 分手需要进行4次通信</li><li>C <code>FIN</code>和<code>ACK</code> 在同一包里</li><li>D <code>ACK</code> 和<code>SYN</code> 在同一包里</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>知识盲区：后续再解析<br><a href="https://m.nowcoder.com/questions?tagId=42507626&amp;type=1&amp;source=intelli&amp;pos=6" target="_blank" rel="noopener">https://m.nowcoder.com/questions?tagId=42507626&amp;type=1&amp;source=intelli&amp;pos=6</a></p><h1 id="考点9-Linux日志文件"><a href="#考点9-Linux日志文件" class="headerlink" title="考点9:Linux日志文件"></a>考点9:Linux日志文件</h1><p>以下说法正确的是()</p><ul><li>A <code>linux</code>系统中的<code>/var/log/lastlog</code>日志记录了所有用户最后登录的记录,可以用<code>lastlog</code>命令查看</li><li>B <code>linux</code>系统中的<code>/var/log/last</code>日志可以用<code>last</code>命令查看</li><li>C <code>/var/log/wtmp</code>日志记录了登录过本系统的用户信息,可以用<code>tail -f</code>命令查看</li><li>D <code>/var/run/utmp</code>日志记录了正在登录本系统中的用户信息,可以用<code>last -f</code>命令查看</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>B. 执行last指令时，它会读取位于/var/log/wtmp的文件，并把该给文件的内容记录的登录系统的用户名单全部显示出来。<br>C. wtmp是二进制文件，他们不能被诸如tail命令剪贴或合并，需要使用who、w、users、last和ac来使用这两个文件包含的信息。</p><p><strong>/var/log/lastlog</strong>:记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看<br><strong>/var/log/wtmp</strong> :永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用<strong>last命令</strong>查看.<br><strong>/var/log/utmp</strong>:记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 </p><p><strong>/var/log/wtmp</strong>是一个二进制文件，记录每个用户的登录次数和持续时间等信息，使用”last -f”查看，如”last -f /var/log/wtmp”;<br><strong>/var/run/utmp</strong>是一个二进制文件，保存当前在本系统中的用户信息，使用”last -f”查看，如”last -f /var/run/utmp”;<br>  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linux.cn/article-10096-1.html" target="_blank" rel="noopener">https://linux.cn/article-10096-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月31日Linux专项联系2</title>
      <link href="/exam//e8640a22/"/>
      <url>/exam//e8640a22/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/e8640a22/#考点1-输入输出重定向" class="header_1">考点1:输入输出重定向</a>&nbsp;<br><a href="/exam/e8640a22/#考点2-Linux目录结构" class="header_1">考点2:Linux目录结构</a>&nbsp;<br><a href="/exam/e8640a22/#考点3-常用端口号-WWW和FTP端口号" class="header_1">考点3:常用端口号 WWW和FTP端口号</a>&nbsp;<br><a href="/exam/e8640a22/#考点4-Linux查看磁盘挂载状态命令" class="header_1">考点4:Linux查看磁盘挂载状态命令</a>&nbsp;<br><a href="/exam/e8640a22/#考点5-vi强制保存退出参数" class="header_1">考点5:vi强制保存退出参数</a>&nbsp;<br><a href="/exam/e8640a22/#考点7-Linux的ifconfig命令" class="header_1">考点7:Linux的ifconfig命令</a>&nbsp;<br><a href="/exam/e8640a22/#考点8-Linux进程-clone和fork的区别" class="header_1">考点8:Linux进程 clone和fork的区别</a>&nbsp;<br><a href="/exam/e8640a22/#考点9" class="header_1">考点9:</a>&nbsp;<br><a href="/exam/e8640a22/#考点10-Linux可以查看系统启动时间的命令" class="header_1">考点10:Linux可以查看系统启动时间的命令</a>&nbsp;<br><a href="/exam/e8640a22/#考点11" class="header_1">考点11:</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-输入输出重定向"><a href="#考点1-输入输出重定向" class="headerlink" title="考点1:输入输出重定向"></a>考点1:输入输出重定向</h1><p>在RHEL5系统中,小王希望将他执行的ls命令的输出结果保存在当前目录下文件output.ls中,以供日后进行分析和使用,但要求不覆盖原文件的内容,他应该使用的命令是(  )</p><ul><li>A <code>ls&gt;output.ls</code></li><li>B <code>ls&gt;&gt;output.ls</code></li><li>C <code>ls&lt;&lt;output.ls</code></li><li>D <code>ls—output.ls</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>&gt;  输出重定向到一个文件或设备 <strong>覆盖原来的文件</strong><br>&gt;!  输出重定向到一个文件或设备 <strong>强制覆盖原来的文件</strong><br>&gt;&gt;  输出重定向到一个文件或设备 <strong>追加原来的文件</strong><br>&lt;  输入重定向到一个程序 </p><ul> <li>command &gt; file:将输出重定向到 file。 </li><li>command &lt; file:将输入重定向到 file。 </li><li>command &gt;&gt; file:将输出以追加的方式重定向到 file。 </li><li>n &gt; file:将文件描述符为 n 的文件重定向到 file。 </li><li>n &gt;&gt; file:将文件描述符为 n 的文件以追加的方式重定向到 file。 </li><li>n &gt;&amp; m:将输出文件 m 和 n 合并。 </li><li>n &lt;&amp; m:将输入文件 m 和 n 合并。 </li><li>&lt;&lt; tag:将开始标记 tag 和结束标记 tag 之间的内容作为输入。 </li></ul><h1 id="考点2-Linux目录结构"><a href="#考点2-Linux目录结构" class="headerlink" title="考点2:Linux目录结构"></a>考点2:Linux目录结构</h1><p>Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在()目录中</p><ul><li>A <code>/bin</code></li><li>B <code>/etc</code></li><li>C <code>/dev</code></li><li>D <code>/lib</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p> /bin  二进制执行文件，也就是命令文件<br> /etc 下存放的是配置文件<br> /dev 存放是时外部设备文件，硬盘，usb等<br> /lib 存放的是库文件 </p><p>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公共的临时文件存储点<br>/root 系统管理员的主目录<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>/usr/x11R6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令</p><p>/dev   是device的简写，英文原意是device 设备。</p><h1 id="考点3-常用端口号-WWW和FTP端口号"><a href="#考点3-常用端口号-WWW和FTP端口号" class="headerlink" title="考点3:常用端口号 WWW和FTP端口号"></a>考点3:常用端口号 WWW和FTP端口号</h1><p>下面对www 和ftp的端口描述正确的是</p><ul><li>A 20 21</li><li>B 80 20</li><li>C 80 21</li><li>D 80,20 21</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="FTP端口"><a href="#FTP端口" class="headerlink" title="FTP端口"></a>FTP端口</h3><p>FTP服务器有两个端口，其中<strong>21端口用于连接</strong>，<strong>20端口用于传输数据</strong><br>进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。<br>也就是说，<strong>端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证</strong>。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。</p><p>www 80<br>ftp(主动模式20数据端口，用于传输-服务端传输文件  被动模式21控制端口,认证-客户端认证用户)  ftp协议由ftp服务器和ftp客户端构成,是基于tcp的两个端口：20,21<br>tftp协议基于udp端口 tcp传输层协议 ftp应用层协议 </p><h3 id="其他常用端口"><a href="#其他常用端口" class="headerlink" title="其他常用端口"></a>其他常用端口</h3><ul><li>SSH：22</li><li>Telnet：23 </li><li>SMTP：25 </li><li>POP3：110. S</li><li>NMP：161 </li><li>DNS服务：53  </li><li>HTTP(www)：80(默认端口) </li><li>HTTPS：443(在http的基础上ssl加密) </li></ul><h1 id="考点4-Linux查看磁盘挂载状态命令"><a href="#考点4-Linux查看磁盘挂载状态命令" class="headerlink" title="考点4:Linux查看磁盘挂载状态命令"></a>考点4:Linux查看磁盘挂载状态命令</h1><p>linux下查看磁盘挂载状态的命令式？</p><ul><li>A <code>rpm</code></li><li>B <code>mount</code></li><li>C <code>netstat</code></li><li>D <code>df</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>安装命令：rpm -ivh<br>卸载命令: rpm -e [package name]<br>查看挂载状态: mount<br>查看磁盘情况: df<br>查看端口:netstat –anlp<br>.tar.gz的安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar –zxvf tar.gz </span><br><span class="line">.&#x2F;configure </span><br><span class="line">Make </span><br><span class="line">Make install</span><br></pre></td></tr></table></figure></p><h1 id="考点5-vi强制保存退出参数"><a href="#考点5-vi强制保存退出参数" class="headerlink" title="考点5:vi强制保存退出参数"></a>考点5:vi强制保存退出参数</h1><p>某配置文件针对所有用户的访问权限是只读,vi编辑器强制存盘退出的指令是(      )</p><ul><li>A <code>:wq</code></li><li>B <code>ZZ</code></li><li>C <code>:q!</code></li><li>D <code>:wq!</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><div class="table-container"><table><thead><tr><th style="text-align:left">vim的退出编辑命令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">:q</td><td style="text-align:left">不保存退出</td></tr><tr><td style="text-align:left">:q!</td><td style="text-align:left">不保存强制退出</td></tr><tr><td style="text-align:left">:wq</td><td style="text-align:left">写入文件并退出</td></tr><tr><td style="text-align:left">:wq!</td><td style="text-align:left"><strong>强制写入并退出（只有当操作者是文件所有者才可行）</strong></td></tr><tr><td style="text-align:left">:x</td><td style="text-align:left">文件有变动时等同于 :wq，文件无变动时等同与 :q</td></tr><tr><td style="text-align:left">ZZ</td><td style="text-align:left">等同于:x</td></tr></tbody></table></div><h1 id="考点7-Linux的ifconfig命令"><a href="#考点7-Linux的ifconfig命令" class="headerlink" title="考点7:Linux的ifconfig命令"></a>考点7:Linux的ifconfig命令</h1><p>下列提法中,不属于ifconfig命令作用范围的是 。</p><ul><li>A 配置本地回环地址</li><li>B 配置网卡的<code>IP</code>地址</li><li>C 激活网络适配器</li><li>D 加载网卡到内核中</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><p>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -interface [options] address</span><br></pre></td></tr></table></figure><br>3.主要参数如下</p><ul><li>interface：指定的网络接口名，如eth0和eth1。 </li><li>options:<ul><li>up：激活指定的网络接口卡。</li><li>down：关闭指定的网络接口。 </li><li>broadcast address：设置接口的广播地址。 </li><li>pointopoint：启用点对点方式。 </li><li>address：设置指定接口设备的IP地址。 </li><li>netmask address：设置接口的子网掩码。</li></ul></li></ul><h1 id="考点8-Linux进程-clone和fork的区别"><a href="#考点8-Linux进程-clone和fork的区别" class="headerlink" title="考点8:Linux进程 clone和fork的区别"></a>考点8:Linux进程 clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p><ul><li>A <code>clone</code>和<code>fork</code>最大不同在于<code>fork</code>不再复制父进程的栈空间,而是自己创建一个新的。</li><li>B <code>clone</code>和<code>fork</code>最大不同在于<code>clone</code>不再复制父进程的栈空间,而是自己创建一个新的。</li><li>C <code>clone</code>是<code>fork</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li><li>D <code>fork</code>是<code>clone</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>fork()<br>函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()<br>函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以clone()<br>函数带参数，没有复制的资源可以通过指针共享给子进程</p><p>fork()是全部复制<br>vfork()是共享内存<br><strong>clone()是可以将父进程资源有选择地复制给子进程</strong>，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。 </p><p>fork是复制进程，创建一个新的进程，不带参数<br>clone是可选的复制父进程资源，可以通过参数控制复制的内容 </p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件？ </p><ul><li>A <code>/usr/tmp</code></li><li>B <code>/etc/default</code></li><li>C <code>/etc/skel</code></li><li>D <code>/etc/users</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Linux下的/etc/skel目录往往不被人注意，其实此目录在新建用户时还是很有用的，灵活运用此目录可以节约一定的配置时间。<br>skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的根目录，并且将用户属主与用户组调整为与此根目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。<br>注：<br>1.如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。<br>2.如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：<br>sudo useradd -d /home/chen -m -k<br> /etc/my_skel chen<br>上述命令将新建用户chen，设置用户根目录为/home/chen，并且此目录会自动建立；同时指定框架目录为/etc/my_skel。<br>3.如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录，方法如下：<br>查找SKEL变量的定义，如果此变量的定义已被注释掉，可以取消注释，然后修改其值：<br>SKEL=/etc/my_skel</p><h1 id="考点10-Linux可以查看系统启动时间的命令"><a href="#考点10-Linux可以查看系统启动时间的命令" class="headerlink" title="考点10:Linux可以查看系统启动时间的命令"></a>考点10:Linux可以查看系统启动时间的命令</h1><p>以下哪些命令可以查看当前系统的启动时间()</p><ul><li>A <code>w</code></li><li>B <code>top</code></li><li>C <code>ps</code></li><li>D <code>uptime</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">ps</td><td style="text-align:left">查看当前系统中的进程</td></tr><tr><td style="text-align:left">who -b</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">last reboot</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">top</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">uptime</td><td style="text-align:left">查看当前系统的启动时间</td></tr></tbody></table></div><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11:"></a>考点11:</h1><p>关于Linux系统的负载(Load),以下表述正确的是<strong>__</strong>。</p><ul><li>A 通过就绪和运行的进程数来反映</li><li>B 可以通过<code>TOP</code>命令查看</li><li>C 可以通过<code>uptime</code>查看</li><li>D <code>Load:2.5,1.3,1.1</code>表示系统的负载压力在逐渐减少</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Test </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月31日Linux专项练习1</title>
      <link href="/exam//d5fcd365/"/>
      <url>/exam//d5fcd365/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/d5fcd365/#考点1-Linux修改权限命令-chmod命令" class="header_1">考点1:Linux修改权限命令_chmod命令</a>&nbsp;<br><a href="/exam/d5fcd365/#考点2-UNIX目录结构" class="header_1">考点2:UNIX目录结构</a>&nbsp;<br><a href="/exam/d5fcd365/#考点3-Linux的-Z文件的解压缩命令" class="header_1">考点3:Linux的.Z文件的解压缩命令</a>&nbsp;<br><a href="/exam/d5fcd365/#考点4-记录已经加载的文件系统的文件" class="header_1">考点4:记录已经加载的文件系统的文件</a>&nbsp;<br><a href="/exam/d5fcd365/#考点5-Linux列举当前目录" class="header_1">考点5:Linux列举当前目录</a>&nbsp;<br><a href="/exam/d5fcd365/#考点6-Linux查看文件命令" class="header_1">考点6:Linux查看文件命令</a>&nbsp;<br><a href="/exam/d5fcd365/#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="header_1">考点7:Linux查看CPU Swap分区 硬盘信息命令</a>&nbsp;<br><a href="/exam/d5fcd365/#考点8-日志文件系统有哪些" class="header_1">考点8:日志文件系统有哪些</a>&nbsp;<br><a href="/exam/d5fcd365/#考点9-系统调用" class="header_1">考点9:系统调用</a>&nbsp;<br><a href="/exam/d5fcd365/#考点10-Linux2-6默认支持的文件系统" class="header_1">考点10:Linux2.6默认支持的文件系统</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux修改权限命令-chmod命令"><a href="#考点1-Linux修改权限命令-chmod命令" class="headerlink" title="考点1:Linux修改权限命令_chmod命令"></a>考点1:Linux修改权限命令_chmod命令</h1><p>Linux下,为某个脚本赋予可执行权限()</p><ul><li>A <code>chmod +x filename.sh</code></li><li>B <code>chown +x filename.sh</code></li><li>C <code>chmod +r filename.sh</code></li><li>D <code>chown +r filename.sh</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>chmod命令修改权限 +x表示增加执行权限，+r表示增加读取权限，+w表示增加写权限<br>chown将指定文件的拥有者改为指定的用户或组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l</span><br><span class="line">total 3766</span><br><span class="line">-rwxr-xr-x 1 lan 197609     183  3月 19 21:32 hexos.sh*</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx</span><br><span class="line">111</span><br><span class="line">421</span><br></pre></td></tr></table></figure></p><h1 id="考点2-UNIX目录结构"><a href="#考点2-UNIX目录结构" class="headerlink" title="考点2:UNIX目录结构"></a>考点2:UNIX目录结构</h1><p>在UNIX系统中,目录结构采用( )</p><ul><li>A 单级目录结构</li><li>B 二级目录结构</li><li>C 单纯树形目录结构</li><li>D 带链接树形目录结构</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>带链接树形目录结构又称非循环图目录结构,它是指访问一文件(或目录)可以有多条路径。一般常说UNIX的文件系统是树形结构，其实是指带链接的树形结构，而不是纯树形目录结构。 </p><h1 id="考点3-Linux的-Z文件的解压缩命令"><a href="#考点3-Linux的-Z文件的解压缩命令" class="headerlink" title="考点3:Linux的.Z文件的解压缩命令"></a>考点3:Linux的.Z文件的解压缩命令</h1><p>一个文件名字为rr.Z,可以用来解压缩的命令是？</p><ul><li>A <code>tar</code></li><li>B <code>gzip</code></li><li>C <code>compress</code></li><li>D <code>uncompress</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>tar</code></td><td style="text-align:left">操作<code>.tar</code>的命令</td></tr><tr><td style="text-align:left"><code>gzip</code></td><td style="text-align:left">压缩<code>.gz</code>压缩包的命令</td></tr><tr><td style="text-align:left"><code>compress</code></td><td style="text-align:left">压缩.Z文件</td></tr><tr><td style="text-align:left"><code>uncompress</code></td><td style="text-align:left">解压缩.Z文件</td></tr></tbody></table></div><h1 id="考点4-记录已经加载的文件系统的文件"><a href="#考点4-记录已经加载的文件系统的文件" class="headerlink" title="考点4:记录已经加载的文件系统的文件"></a>考点4:记录已经加载的文件系统的文件</h1><p>系统当前已经加载的所有文件系统在<strong><strong>_</strong></strong>文件中得到反映。</p><ul><li>A <code>/usr/sbin/cfdisk</code></li><li>B <code>/sbin/fdisk</code></li><li>C <code>/etc/mtab</code></li><li>D <code>/etc/fstab</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">/etc/文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>/etc/mtab</code></td><td style="text-align:left">记载的是现在系统已经装载的文件系统，包括操作系统建立的虚拟文件等；而/etc/fstab是系统准备装载的</td></tr><tr><td style="text-align:left"><code>/etc/fstab</code></td><td style="text-align:left">记录了计算机上硬盘分区的相关信息，启动Linux的时候，检查分区的fsck命令，和挂载分区的mount命令，都需要fstab中的信息，来正确的检查和挂载硬盘。</td></tr></tbody></table></div><h1 id="考点5-Linux列举当前目录"><a href="#考点5-Linux列举当前目录" class="headerlink" title="考点5:Linux列举当前目录"></a>考点5:Linux列举当前目录</h1><p>在linux中,列举当前目录下文件的是哪个命令<strong>__</strong>。</p><ul><li>A <code>ps</code></li><li>B <code>cd</code></li><li>C <code>mv</code></li><li>D <code>ls</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">ps</td><td style="text-align:left">查看运行中的进程</td></tr><tr><td style="text-align:left">cd</td><td style="text-align:left">进入某个目录</td></tr><tr><td style="text-align:left">mv</td><td style="text-align:left">移动文件或者文件夹</td></tr><tr><td style="text-align:left">ls</td><td style="text-align:left">list的缩写，列出某个目录下的文件或者文件夹</td></tr></tbody></table></div><h1 id="考点6-Linux查看文件命令"><a href="#考点6-Linux查看文件命令" class="headerlink" title="考点6:Linux查看文件命令"></a>考点6:Linux查看文件命令</h1><p>在Linux下查看文件有多种方法,若希望在查看文件内容过程中,可以按空格实现翻页,应使用(      )命令</p><ul><li>A <code>cat</code></li><li>B <code>more</code></li><li>C <code>less</code></li><li>D <code>head</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><ul><li>cat：由第一行开始显示文件所有内容； </li><li>tac：从最后一行开始显示文件的所有内容，<ul><li>注意 tac 与cat 写法正好相反； </li></ul></li><li>more：一页一页的显示文件内容，只能向后翻页； </li><li>less：也是一页一页显示文件内容，但是可以通过键盘上的【pagedown】，【pageup】控制向后，向前翻页； </li><li>head：显示一个文件的前几行； </li><li>tail：显示一个文件的后几行； </li></ul><h1 id="考点7-Linux查看CPU-Swap分区-硬盘信息命令"><a href="#考点7-Linux查看CPU-Swap分区-硬盘信息命令" class="headerlink" title="考点7:Linux查看CPU Swap分区 硬盘信息命令"></a>考点7:Linux查看CPU Swap分区 硬盘信息命令</h1><p>如何在命令行查看一台linux机器的CPU、SWAP分区信息、硬盘信息?</p><ul><li>A <code>cat /proc/cpuinfo</code></li><li>B <code>du</code></li><li>C <code>cat /proc/swaps</code></li><li>D <code>df -lh</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>cat /proc/cpuinfo</code></td><td style="text-align:left">查看一台<code>linux</code>机器的<code>CPU</code>信息</td></tr><tr><td style="text-align:left"><code>cat /proc/swaps</code></td><td style="text-align:left">查看<code>SWAP</code>分区信息</td></tr><tr><td style="text-align:left"><code>du</code></td><td style="text-align:left">查看该目录占用文件系统数据块的情况</td></tr><tr><td style="text-align:left"><code>df -lh</code></td><td style="text-align:left">查看硬盘信息</td></tr></tbody></table></div><h3 id="cat-proc-cpuinfo查看CPU信息"><a href="#cat-proc-cpuinfo查看CPU信息" class="headerlink" title="cat /proc/cpuinfo查看CPU信息"></a>cat /proc/cpuinfo查看CPU信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;proc&#x2F;cpuinfo </span><br><span class="line">Processor    : AArch64 Processor rev 4 (aarch64)</span><br><span class="line">processor    : 0</span><br><span class="line">processor    : 1</span><br><span class="line">processor    : 2</span><br><span class="line">processor    : 3</span><br><span class="line">processor    : 4</span><br><span class="line">processor    : 5</span><br><span class="line">processor    : 6</span><br><span class="line">processor    : 7</span><br><span class="line">Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32 </span><br><span class="line">CPU implementer    : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant    : 0x0</span><br><span class="line">CPU part    : 0xd03</span><br><span class="line">CPU revision    : 4</span><br><span class="line"></span><br><span class="line">Hardware    : Qualcomm Technologies, Inc MSM8976</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="cat-proc-swaps查看swap分区信息"><a href="#cat-proc-swaps查看swap分区信息" class="headerlink" title="cat /proc/swaps查看swap分区信息"></a>cat /proc/swaps查看swap分区信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;proc&#x2F;swaps</span><br><span class="line">Filename                Type        Size    Used    Priority</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="du查看文件或目录占用大小"><a href="#du查看文件或目录占用大小" class="headerlink" title="du查看文件或目录占用大小"></a>du查看文件或目录占用大小</h3><p>查看当前目录下各个文件或目录的占用大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -h -d 1</span><br><span class="line">8.0K    .&#x2F;.pki</span><br><span class="line">20K    .&#x2F;.ssh</span><br><span class="line">2.6M    .&#x2F;.nvm</span><br><span class="line">12K    .&#x2F;.config</span><br><span class="line">42M    .&#x2F;.npm</span><br><span class="line">104K    .&#x2F;C_Test</span><br><span class="line">12K    .&#x2F;Shell_Test</span><br><span class="line">8.0K    .&#x2F;Linux_Test</span><br><span class="line">45M    .</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="df-h查看磁盘空间占用情况"><a href="#df-h查看磁盘空间占用情况" class="headerlink" title="df -h查看磁盘空间占用情况"></a>df -h查看磁盘空间占用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">文件系统                                容量  已用  可用 已用% 挂载点</span><br><span class="line">&#x2F;dev&#x2F;block&#x2F;bootdevice&#x2F;by-name&#x2F;userdata   55G   15G   40G   28% &#x2F;</span><br><span class="line">tmpfs                                   1.8G  364K  1.8G    1% &#x2F;dev</span><br><span class="line">tmpfs                                   1.8G     0  1.8G    0% &#x2F;dev&#x2F;shm</span><br><span class="line">&#x2F;data&#x2F;media                              55G   15G   40G   28% &#x2F;mnt&#x2F;files</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="free-h查看内存占用情况"><a href="#free-h查看内存占用情况" class="headerlink" title="free -h查看内存占用情况"></a>free -h查看内存占用情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           3.5G        1.8G         64M        8.7M        1.6G        1.6G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h1 id="考点8-日志文件系统有哪些"><a href="#考点8-日志文件系统有哪些" class="headerlink" title="考点8:日志文件系统有哪些"></a>考点8:日志文件系统有哪些</h1><p>以下哪个是日志文件系统()</p><ul><li>A <code>ext2</code></li><li>B <code>fat32</code></li><li>C <code>ntfs</code></li><li>D <code>ext3</code></li><li>E <code>ext4</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>日志文件系统（英语：Journaling file system）是一种文件系统。在发生变化时，它先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。</p><h3 id="常见的日志文件系统"><a href="#常见的日志文件系统" class="headerlink" title="常见的日志文件系统"></a>常见的日志文件系统</h3><div class="table-container"><table><thead><tr><th style="text-align:left">文件系统</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">JFS</td><td style="text-align:left">IBM的 Journaled File System, 最早的日志文件系统。</td></tr><tr><td style="text-align:left">Ext4/Ext3文件系统</td><td style="text-align:left">由Ext2文件系统演化而成的日志文件系统，广泛用于Linux系统。</td></tr><tr><td style="text-align:left">XFS文件系统</td><td style="text-align:left">广泛用于Linux系统，取代了Ext4。</td></tr><tr><td style="text-align:left">ReiserFS</td><td style="text-align:left">用B+树作为数据结构的日志文件系统，在处理小文件时有较好的性能。</td></tr><tr><td style="text-align:left">Btrfs</td><td style="text-align:left">用B树作为数据结构，被认为是下一代Linux文件系统。</td></tr><tr><td style="text-align:left">NTFS</td><td style="text-align:left">微软的NTFS也是日志文件系统，也是Windows下最常用的文件系统。</td></tr><tr><td style="text-align:left">HFS+</td><td style="text-align:left">苹果公司发展的OS X操作系统下主要使用的文件系统。</td></tr></tbody></table></div><h1 id="考点9-系统调用"><a href="#考点9-系统调用" class="headerlink" title="考点9:系统调用"></a>考点9:系统调用</h1><p>Linux执行ls,会引起哪些系统调用()</p><ul><li>A <code>nmap</code></li><li>B <code>read</code></li><li>C <code>execve</code></li><li>D <code>fork</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>任何shell都会执行exec和fork，而ls会执行read。<br>三个加起来就是read,execve,fork</p><h1 id="考点10-Linux2-6默认支持的文件系统"><a href="#考点10-Linux2-6默认支持的文件系统" class="headerlink" title="考点10:Linux2.6默认支持的文件系统"></a>考点10:Linux2.6默认支持的文件系统</h1><p>linux 2.6.* 内核默认支持的文件系统有哪些？</p><ul><li>A <code>ext3</code></li><li>B <code>ext2</code></li><li>C <code>ext4</code></li><li>D <code>xfs</code></li><li>E <code>ufs</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>背答案算了</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月31日Linux专项联系2</title>
      <link href="/exam//7b887ccd/"/>
      <url>/exam//7b887ccd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/7b887ccd/#考点1-输入输出重定向" class="header_1">考点1:输入输出重定向</a>&nbsp;<br><a href="/exam/7b887ccd/#考点2-Linux目录结构" class="header_1">考点2:Linux目录结构</a>&nbsp;<br><a href="/exam/7b887ccd/#考点3-常用端口号-WWW和FTP端口号" class="header_1">考点3:常用端口号 WWW和FTP端口号</a>&nbsp;<br><a href="/exam/7b887ccd/#考点4-Linux查看磁盘挂载状态命令" class="header_1">考点4:Linux查看磁盘挂载状态命令</a>&nbsp;<br><a href="/exam/7b887ccd/#考点5-vi强制保存退出参数" class="header_1">考点5:vi强制保存退出参数</a>&nbsp;<br><a href="/exam/7b887ccd/#考点7-Linux的ifconfig命令" class="header_1">考点7:Linux的ifconfig命令</a>&nbsp;<br><a href="/exam/7b887ccd/#考点8-Linux进程-clone和fork的区别" class="header_1">考点8:Linux进程 clone和fork的区别</a>&nbsp;<br><a href="/exam/7b887ccd/#考点9-存储用户创建用户目录的系统用户默认文件的文件" class="header_1">考点9:存储用户创建用户目录的系统用户默认文件的文件</a>&nbsp;<br><a href="/exam/7b887ccd/#考点10-Linux可以查看系统启动时间的命令" class="header_1">考点10:Linux可以查看系统启动时间的命令</a>&nbsp;<br><a href="/exam/7b887ccd/#考点11-可以查看Linux系统负载的命令" class="header_1">考点11:可以查看Linux系统负载的命令</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-输入输出重定向"><a href="#考点1-输入输出重定向" class="headerlink" title="考点1:输入输出重定向"></a>考点1:输入输出重定向</h1><p>在RHEL5系统中,小王希望将他执行的ls命令的输出结果保存在当前目录下文件output.ls中,以供日后进行分析和使用,但要求不覆盖原文件的内容,他应该使用的命令是(  )</p><ul><li>A <code>ls&gt;output.ls</code></li><li>B <code>ls&gt;&gt;output.ls</code></li><li>C <code>ls&lt;&lt;output.ls</code></li><li>D <code>ls—output.ls</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>&gt;  输出重定向到一个文件或设备 <strong>覆盖原来的文件</strong><br>&gt;!  输出重定向到一个文件或设备 <strong>强制覆盖原来的文件</strong><br>&gt;&gt;  输出重定向到一个文件或设备 <strong>追加原来的文件</strong><br>&lt;  输入重定向到一个程序 </p><ul> <li>command &gt; file:将输出重定向到 file。 </li><li>command &lt; file:将输入重定向到 file。 </li><li>command &gt;&gt; file:将输出以追加的方式重定向到 file。 </li><li>n &gt; file:将文件描述符为 n 的文件重定向到 file。 </li><li>n &gt;&gt; file:将文件描述符为 n 的文件以追加的方式重定向到 file。 </li><li>n &gt;&amp; m:将输出文件 m 和 n 合并。 </li><li>n &lt;&amp; m:将输入文件 m 和 n 合并。 </li><li>&lt;&lt; tag:将开始标记 tag 和结束标记 tag 之间的内容作为输入。 </li></ul><h1 id="考点2-Linux目录结构"><a href="#考点2-Linux目录结构" class="headerlink" title="考点2:Linux目录结构"></a>考点2:Linux目录结构</h1><p>Linux文件系统的文件都按其作用分门别类地放在相关的目录中,对于外部设备文件,一般应将其放在()目录中</p><ul><li>A <code>/bin</code></li><li>B <code>/etc</code></li><li>C <code>/dev</code></li><li>D <code>/lib</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p> /bin  二进制执行文件，也就是命令文件<br> /etc 下存放的是配置文件<br> /dev 存放是时外部设备文件，硬盘，usb等<br> /lib 存放的是库文件 </p><p>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 超级管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公共的临时文件存储点<br>/root 系统管理员的主目录<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统<br>/lost+found这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录，其中包含：<br>/usr/x11R6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令</p><p>/dev   是device的简写，英文原意是device 设备。</p><h1 id="考点3-常用端口号-WWW和FTP端口号"><a href="#考点3-常用端口号-WWW和FTP端口号" class="headerlink" title="考点3:常用端口号 WWW和FTP端口号"></a>考点3:常用端口号 WWW和FTP端口号</h1><p>下面对www 和ftp的端口描述正确的是</p><ul><li>A 20 21</li><li>B 80 20</li><li>C 80 21</li><li>D 80,20 21</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="FTP端口"><a href="#FTP端口" class="headerlink" title="FTP端口"></a>FTP端口</h3><p>FTP服务器有两个端口，其中<strong>21端口用于连接</strong>，<strong>20端口用于传输数据</strong><br>进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。<br>也就是说，<strong>端口20才是真正传输所用到的端口，端口21只用于FTP的登陆认证</strong>。我们平常下载文件时，会遇到下载到99%时，文件不完成，不能成功的下载。其实是因为文件下载完毕后，还要在21端口再行进行用户认证，而下载文件的时间如果过长，客户机与服务器的21端口的连接会被服务器认为是超时连接而中断掉，就是这个原因。解决方法就是设置21端口的响应时间。</p><p>www 80<br>ftp(主动模式20数据端口，用于传输-服务端传输文件  被动模式21控制端口,认证-客户端认证用户)  ftp协议由ftp服务器和ftp客户端构成,是基于tcp的两个端口：20,21<br>tftp协议基于udp端口 tcp传输层协议 ftp应用层协议 </p><h3 id="其他常用端口"><a href="#其他常用端口" class="headerlink" title="其他常用端口"></a>其他常用端口</h3><ul><li>SSH：22</li><li>Telnet：23 </li><li>SMTP：25 </li><li>POP3：110. S</li><li>NMP：161 </li><li>DNS服务：53  </li><li>HTTP(www)：80(默认端口) </li><li>HTTPS：443(在http的基础上ssl加密) </li></ul><h1 id="考点4-Linux查看磁盘挂载状态命令"><a href="#考点4-Linux查看磁盘挂载状态命令" class="headerlink" title="考点4:Linux查看磁盘挂载状态命令"></a>考点4:Linux查看磁盘挂载状态命令</h1><p>linux下查看磁盘挂载状态的命令式？</p><ul><li>A <code>rpm</code></li><li>B <code>mount</code></li><li>C <code>netstat</code></li><li>D <code>df</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>安装命令：rpm -ivh<br>卸载命令: rpm -e [package name]<br>查看挂载状态: mount<br>查看磁盘情况: df<br>查看端口:netstat –anlp<br>.tar.gz的安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar –zxvf tar.gz </span><br><span class="line">.&#x2F;configure </span><br><span class="line">Make </span><br><span class="line">Make install</span><br></pre></td></tr></table></figure></p><h1 id="考点5-vi强制保存退出参数"><a href="#考点5-vi强制保存退出参数" class="headerlink" title="考点5:vi强制保存退出参数"></a>考点5:vi强制保存退出参数</h1><p>某配置文件针对所有用户的访问权限是只读,vi编辑器强制存盘退出的指令是(      )</p><ul><li>A <code>:wq</code></li><li>B <code>ZZ</code></li><li>C <code>:q!</code></li><li>D <code>:wq!</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><div class="table-container"><table><thead><tr><th style="text-align:left">vim的退出编辑命令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">:q</td><td style="text-align:left">不保存退出</td></tr><tr><td style="text-align:left">:q!</td><td style="text-align:left">不保存强制退出</td></tr><tr><td style="text-align:left">:wq</td><td style="text-align:left">写入文件并退出</td></tr><tr><td style="text-align:left">:wq!</td><td style="text-align:left"><strong>强制写入并退出（只有当操作者是文件所有者才可行）</strong></td></tr><tr><td style="text-align:left">:x</td><td style="text-align:left">文件有变动时等同于 :wq，文件无变动时等同与 :q</td></tr><tr><td style="text-align:left">ZZ</td><td style="text-align:left">等同于:x</td></tr></tbody></table></div><h1 id="考点7-Linux的ifconfig命令"><a href="#考点7-Linux的ifconfig命令" class="headerlink" title="考点7:Linux的ifconfig命令"></a>考点7:Linux的ifconfig命令</h1><p>下列提法中,不属于ifconfig命令作用范围的是 。</p><ul><li>A 配置本地回环地址</li><li>B 配置网卡的<code>IP</code>地址</li><li>C 激活网络适配器</li><li>D 加载网卡到内核中</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h3><p>1.作用<br>ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>2.格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -interface [options] address</span><br></pre></td></tr></table></figure><br>3.主要参数如下</p><ul><li>interface：指定的网络接口名，如eth0和eth1。 </li><li>options:<ul><li>up：激活指定的网络接口卡。</li><li>down：关闭指定的网络接口。 </li><li>broadcast address：设置接口的广播地址。 </li><li>pointopoint：启用点对点方式。 </li><li>address：设置指定接口设备的IP地址。 </li><li>netmask address：设置接口的子网掩码。</li></ul></li></ul><h1 id="考点8-Linux进程-clone和fork的区别"><a href="#考点8-Linux进程-clone和fork的区别" class="headerlink" title="考点8:Linux进程 clone和fork的区别"></a>考点8:Linux进程 clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p><ul><li>A <code>clone</code>和<code>fork</code>最大不同在于<code>fork</code>不再复制父进程的栈空间,而是自己创建一个新的。</li><li>B <code>clone</code>和<code>fork</code>最大不同在于<code>clone</code>不再复制父进程的栈空间,而是自己创建一个新的。</li><li>C <code>clone</code>是<code>fork</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li><li>D <code>fork</code>是<code>clone</code>的升级版本,不仅可以创建进程或者线程,还可以指定创建新的命名空间(<code>namespace</code>)、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>fork()<br>函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()<br>函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以clone()<br>函数带参数，没有复制的资源可以通过指针共享给子进程</p><p>fork()是全部复制<br>vfork()是共享内存<br><strong>clone()是可以将父进程资源有选择地复制给子进程</strong>，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。 </p><p>fork是复制进程，创建一个新的进程，不带参数<br>clone是可选的复制父进程资源，可以通过参数控制复制的内容 </p><h1 id="考点9-存储用户创建用户目录的系统用户默认文件的文件"><a href="#考点9-存储用户创建用户目录的系统用户默认文件的文件" class="headerlink" title="考点9:存储用户创建用户目录的系统用户默认文件的文件"></a>考点9:存储用户创建用户目录的系统用户默认文件的文件</h1><p>在Linux系统中, 哪个文件你可以存储用于创建用户目录的系统用户默认文件？ </p><ul><li>A <code>/usr/tmp</code></li><li>B <code>/etc/default</code></li><li>C <code>/etc/skel</code></li><li>D <code>/etc/users</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Linux下的/etc/skel目录往往不被人注意，其实此目录在新建用户时还是很有用的，灵活运用此目录可以节约一定的配置时间。<br>skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的根目录，并且将用户属主与用户组调整为与此根目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。<br>注：<br>1.如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。<br>2.如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时指定新的框架目录。例如：<br>sudo useradd -d /home/chen -m -k<br> /etc/my_skel chen<br>上述命令将新建用户chen，设置用户根目录为/home/chen，并且此目录会自动建立；同时指定框架目录为/etc/my_skel。<br>3.如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录，方法如下：<br>查找SKEL变量的定义，如果此变量的定义已被注释掉，可以取消注释，然后修改其值：<br>SKEL=/etc/my_skel</p><h1 id="考点10-Linux可以查看系统启动时间的命令"><a href="#考点10-Linux可以查看系统启动时间的命令" class="headerlink" title="考点10:Linux可以查看系统启动时间的命令"></a>考点10:Linux可以查看系统启动时间的命令</h1><p>以下哪些命令可以查看当前系统的启动时间()</p><ul><li>A <code>w</code></li><li>B <code>top</code></li><li>C <code>ps</code></li><li>D <code>uptime</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">ps</td><td style="text-align:left">查看当前系统中的进程</td></tr><tr><td style="text-align:left">who -b</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">last reboot</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">top</td><td style="text-align:left">查看当前系统的启动时间</td></tr><tr><td style="text-align:left">uptime</td><td style="text-align:left">查看当前系统的启动时间</td></tr></tbody></table></div><h1 id="考点11-可以查看Linux系统负载的命令"><a href="#考点11-可以查看Linux系统负载的命令" class="headerlink" title="考点11:可以查看Linux系统负载的命令"></a>考点11:可以查看Linux系统负载的命令</h1><p>关于Linux系统的负载(Load),以下表述正确的是<strong>__</strong>。</p><ul><li>A 通过就绪和运行的进程数来反映</li><li>B 可以通过<code>TOP</code>命令查看</li><li>C 可以通过<code>uptime</code>查看</li><li>D <code>Load:2.5,1.3,1.1</code>表示系统的负载压力在逐渐减少</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月23日Linux专项练习4</title>
      <link href="/exam//7a1aced2/"/>
      <url>/exam//7a1aced2/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/7a1aced2/#考点1-如何修改文件权限" class="header_1">考点1:如何修改文件权限</a>&nbsp;<br><a href="/exam/7a1aced2/#考点2-hardware-filename-fixed-address-server-name命令" class="header_1">考点2:hardware filename fixed-address server-name命令</a>&nbsp;<br><a href="/exam/7a1aced2/#考点3-ls-df-du-fine命令" class="header_1">考点3:ls df du fine命令</a>&nbsp;<br><a href="/exam/7a1aced2/#考点4-Linux命令返回值" class="header_1">考点4:Linux命令返回值</a>&nbsp;<br><a href="/exam/7a1aced2/#考点5-查看文件命令cat-more-tail" class="header_1">考点5:查看文件命令cat more tail</a>&nbsp;<br><a href="/exam/7a1aced2/#考点5-vi编辑器的三种模式" class="header_1">考点5:vi编辑器的三种模式</a>&nbsp;<br><a href="/exam/7a1aced2/#考点6-useradd命令" class="header_1">考点6:useradd命令</a>&nbsp;<br><a href="/exam/7a1aced2/#考点7-多进程同时操作一个文件" class="header_1">考点7:多进程同时操作一个文件</a>&nbsp;<br><a href="/exam/7a1aced2/#考点8-TCP握手-分手" class="header_1">考点8:TCP握手 分手</a>&nbsp;<br><a href="/exam/7a1aced2/#考点9-Linux日志文件" class="header_1">考点9:Linux日志文件</a>&nbsp;<br><a href="/exam/7a1aced2/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-如何修改文件权限"><a href="#考点1-如何修改文件权限" class="headerlink" title="考点1:如何修改文件权限"></a>考点1:如何修改文件权限</h1><p>怎样更改一个文件的权限设置？</p><ul><li>A <code>chmod</code></li><li>B <code>file</code></li><li>C <code>attrib</code></li><li>D <code>change</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>chmod 是change &nbsp;mode of file 的缩写，改变文件的的读写权限。</p><h1 id="考点2-hardware-filename-fixed-address-server-name命令"><a href="#考点2-hardware-filename-fixed-address-server-name命令" class="headerlink" title="考点2:hardware filename fixed-address server-name命令"></a>考点2:hardware filename fixed-address server-name命令</h1><p>在dhcpd.conf中用于向某个客户主机分配固定IP地址的参数是 (   )</p><ul><li>A <code>server-name</code></li><li>B <code>fixed-address</code></li><li>C <code>filename</code></li><li>D <code>hardware</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="hardware语句"><a href="#hardware语句" class="headerlink" title="hardware语句"></a>hardware语句</h3><p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hardware hardware-type hardware-address;</span><br></pre></td></tr></table></figure><br>指明物理硬件接口类型和硬件地址。硬件地址由6个8位组构成，每个8位组以“：”隔开。如00：00：E8：1B：54：97</p><h3 id="server-name-语句"><a href="#server-name-语句" class="headerlink" title="server-name 语句"></a>server-name 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-name <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure><p>用于告诉客户服务器的名字。</p><h3 id="fixed-address-语句"><a href="#fixed-address-语句" class="headerlink" title="fixed-address 语句"></a>fixed-address 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed-address address [, address ... ];</span><br></pre></td></tr></table></figure><p>fixed-address 语句用于指定一个或多个IP地址给一个DHCP客户。只能出现在host声明里。</p><h1 id="考点3-ls-df-du-fine命令"><a href="#考点3-ls-df-du-fine命令" class="headerlink" title="考点3:ls df du fine命令"></a>考点3:ls df du fine命令</h1><p>下列哪个命令可以看到文件的大小？(不添加参数的情况下)</p><ul><li>A <code>ls</code></li><li>B <code>df</code></li><li>C <code>du</code></li><li>D <code>find</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>A：ls是list的缩写，用来显示当前目录下面文件的信息；如果要查看文件的大小则需要加上-al参数<br>B：df是disk free的缩写，用来显示文件系统中不同磁盘的使用情况；<br>C：du是disk usage的缩写，显示当前目录或者当前文件的占用的块大小；<br>D：find命令作用在目录下，用来查找指定目录或者当前目录下的文件。</p><h2 id="ls-l查看文件大小"><a href="#ls-l查看文件大小" class="headerlink" title="ls -l查看文件大小"></a>ls -l查看文件大小</h2><p>参考资料：<a href="https://www.cnblogs.com/sparkdev/p/7476005.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/7476005.html</a><br>ls -al命令输出的第5列就是该文件或目录的大小（以字节为单位显示的文件大小）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l exam&#x2F;</span><br><span class="line">总用量 3640</span><br><span class="line">-rw-r--r--.   1 root root    3093 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3498022 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root     158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root     576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root     431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root     174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root     376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root    8192 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root     817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root  170424 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root    4096 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root    4096 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root     422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root    4096 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="ls-lh"><a href="#ls-lh" class="headerlink" title="ls -lh"></a>ls -lh</h3><p>在 Linux 命令中，涉及到文件大小的地方，一般默认是以字节为单位显示的。这样可读性就不是很好。所以有了 -h 选项！这个选项的全称是 —human-readable(给人读的)。也就是以 K, M, G 等单位来显示文件的大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh exam&#x2F;</span><br><span class="line">总用量 3.6M</span><br><span class="line">-rw-r--r--.   1 root root 3.1K 3月  19 21:12 _config.yml</span><br><span class="line">-rw-r--r--.   1 root root 3.4M 3月  22 20:29 db.json</span><br><span class="line">-rw-r--r--.   1 root root  158 3月  19 21:12 FM.properties</span><br><span class="line">-rw-r--r--.   1 root root  576 3月  19 21:12 HexoD.bat</span><br><span class="line">-rw-r--r--.   1 root root  431 3月  22 20:52 HexoS.bat</span><br><span class="line">-rwxr--r--.   1 root root  174 3月  19 21:16 hexos.sh</span><br><span class="line">-rw-r--r--.   1 root root  376 3月  19 21:12 HexoSTest.bat</span><br><span class="line">drwxr-xr-x. 308 root root 8.0K 3月  19 21:19 node_modules</span><br><span class="line">-rw-r--r--.   1 root root  817 3月  19 21:12 package.json</span><br><span class="line">-rw-r--r--.   1 root root 167K 3月  19 21:19 package-lock.json</span><br><span class="line">drwxr-xr-x.   2 root root 4.0K 3月  19 21:12 scaffolds</span><br><span class="line">drwxr-xr-x.   9 root root 4.0K 3月  19 21:12 source</span><br><span class="line">-rw-r--r--.   1 root root  422 3月  19 21:12 StartWriting.bat</span><br><span class="line">drwxr-xr-x.   3 root root 4.0K 3月  19 21:12 themes</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="考点4-Linux命令返回值"><a href="#考点4-Linux命令返回值" class="headerlink" title="考点4:Linux命令返回值"></a>考点4:Linux命令返回值</h1><p>linux命令执行成功后会返回</p><ul><li>A 0</li><li>B 1</li><li>C 2</li><li>D -1</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="Linux命令返回值"><a href="#Linux命令返回值" class="headerlink" title="Linux命令返回值"></a>Linux命令返回值</h3><p>参考资料：<br><a href="https://blog.csdn.net/cy413026/article/details/104172448" target="_blank" rel="noopener">https://blog.csdn.net/cy413026/article/details/104172448</a><br>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306" target="_blank" rel="noopener">https://blog.csdn.net/u013457167/article/details/79196306</a></p><p>在shell终端中，你所输入的一切命令其实都有返回值，而这个返回值默认保存在变量<code>$?</code>中，举例看一下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/bash</span></span><br><span class="line"> </span><br><span class="line">grup_pwd=`cat /etc/grub.conf | grep -v ^# | grep password 2&gt; /dev/null`</span><br><span class="line"> </span><br><span class="line">if [ $? -eq 0 ];then</span><br><span class="line">   echo "  [ √ ] 已设置grub密码,符合要求"</span><br><span class="line">else</span><br><span class="line">   echo "  [ X ] 没有设置grub密码，不符合要求,建议设置grub密码"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h3 id="Linux错误码含义"><a href="#Linux错误码含义" class="headerlink" title="Linux错误码含义"></a>Linux错误码含义</h3><p>Linux错误代码及其含义：<a href="https://blog.csdn.net/u013457167/article/details/79196306" target="_blank" rel="noopener">https://blog.csdn.net/u013457167/article/details/79196306</a></p><h1 id="考点5-查看文件命令cat-more-tail"><a href="#考点5-查看文件命令cat-more-tail" class="headerlink" title="考点5:查看文件命令cat more tail"></a>考点5:查看文件命令cat more tail</h1><p>为了查看不断更新的日志文件,可以使用的指令是()</p><ul><li>A <code>cat -n</code></li><li>B <code>vi</code></li><li>C <code>more</code></li><li>D <code>tail -f</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>linux 下tail用于查看档案的结尾，-f 参数是follow的意思，当文件增长时，输出后续添加的数据。所以使用使用tail命令的-f选项可以方便的查阅正在改变的日志文件。<br>Linux tail 命令：<a href="https://www.runoob.com/linux/linux-comm-tail.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-tail.html</a></p><h1 id="考点5-vi编辑器的三种模式"><a href="#考点5-vi编辑器的三种模式" class="headerlink" title="考点5:vi编辑器的三种模式"></a>考点5:vi编辑器的三种模式</h1><p>在RHEL5系统中,在vi编辑器环境中的任意时刻,选择”ESC”键后,编辑器将进入(  )模式</p><ul><li>A 命令</li><li>B 输入</li><li>C 末行</li><li>D 文本</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>vim编辑器可以分为三种模式：<br>1.命令模式：控制屏幕光标的移动，进行文本的删除，复制等文字编辑工作，不使用【del】和【backspace】键，以及进入插入模式或者回到底行模式；<br>2.插入模式：只有在插入模式下，才可以输入文字，按【esc】可以回到命令模式，vim编辑器一打开是不可以输入的，因为刚打开时候处于命令模式;<br>3.底行模式：保存文件或者退出vim，也可以设置编辑环境和一些编译工作。<br><img src="https://uploadfiles.nowcoder.com/images/20180619/3431580_1529372993152_25A1FCC1486B869925E23FECFEBADC61" alt=""></p><h1 id="考点6-useradd命令"><a href="#考点6-useradd命令" class="headerlink" title="考点6:useradd命令"></a>考点6:useradd命令</h1><p>创建用户时不指定用户主目录的参数(      )</p><ul><li>A <code>useradd -o</code></li><li>B <code>useradd -m</code></li><li>C <code>useradd -M</code></li><li>D <code>useradd -d</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">useradd参数</th><th style="text-align:left">全称</th><th style="text-align:left">释义</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">base-dir BASE_DIR</td><td style="text-align:left">新账户的主目录的基目录</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">comment COMMENT</td><td style="text-align:left">新账户的 GECOS 字段</td></tr><tr><td style="text-align:left">-d</td><td style="text-align:left">home-dir HOME_DIR</td><td style="text-align:left">新账户的主目录</td></tr><tr><td style="text-align:left">-D</td><td style="text-align:left">defaults</td><td style="text-align:left">显示或更改默认的 useradd 配置</td></tr><tr><td style="text-align:left">-e</td><td style="text-align:left">expiredate EXPIRE_DATE</td><td style="text-align:left">新账户的过期日期</td></tr><tr><td style="text-align:left">-f</td><td style="text-align:left">inactive INACTIVE</td><td style="text-align:left">新账户的密码不活动期</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">gid GROUP</td><td style="text-align:left">新账户主组的名称或 ID</td></tr><tr><td style="text-align:left">-G</td><td style="text-align:left">groups GROUPS</td><td style="text-align:left">新账户的附加组列表</td></tr><tr><td style="text-align:left">-h</td><td style="text-align:left">help</td><td style="text-align:left">显示此帮助信息并推出</td></tr><tr><td style="text-align:left">-k</td><td style="text-align:left">skel SKEL_DIR</td><td style="text-align:left">使用此目录作为骨架目录</td></tr><tr><td style="text-align:left">-K</td><td style="text-align:left">key KEY=VALUE</td><td style="text-align:left">不使用 /etc/login.defs 中的默认值</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">no-log-init</td><td style="text-align:left">不要将此用户添加到最近登录和登录失败数据库</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">create-home</td><td style="text-align:left">创建用户的主目录</td></tr><tr><td style="text-align:left">-M</td><td style="text-align:left">no-create-home</td><td style="text-align:left">不创建用户的主目录</td></tr><tr><td style="text-align:left">-N</td><td style="text-align:left">no-user-group</td><td style="text-align:left">不创建同名的组</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">non-unique</td><td style="text-align:left">允许使用重复的 UID 创建用户</td></tr><tr><td style="text-align:left">-p</td><td style="text-align:left">password PASSWORD</td><td style="text-align:left">加密后的新账户密码</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:left">system</td><td style="text-align:left">创建一个系统账户</td></tr><tr><td style="text-align:left">-s</td><td style="text-align:left">shell SHELL</td><td style="text-align:left">新账户的登录 shell</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:left">uid UID</td><td style="text-align:left">新账户的用户 ID</td></tr><tr><td style="text-align:left">-U</td><td style="text-align:left">user-group</td><td style="text-align:left">创建与用户同名的组</td></tr><tr><td style="text-align:left">-Z</td><td style="text-align:left">selinux-user SEUSER</td><td style="text-align:left">为 SELinux 用户映射使用指定 SEUSER</td></tr></tbody></table></div><h1 id="考点7-多进程同时操作一个文件"><a href="#考点7-多进程同时操作一个文件" class="headerlink" title="考点7:多进程同时操作一个文件"></a>考点7:多进程同时操作一个文件</h1><p>Linux下两个进程可以同时打开同一个文件,这时如下描述错误的是:</p><ul><li>A 两个进程中分别产生生成两个独立的<code>fd</code></li><li>B 两个进程可以任意对文件进行读写操作,操作系统并不保证写的原子性</li><li>C 进程可以通过系统调用对文件加锁,从而实现对文件内容的保护</li><li>D 任何一个进程删除该文件时,另外一个进程会立即出现读写失败</li><li>E 两个进程可以分别读取文件的不同部分而不会相互影响</li><li>F 一个进程对文件长度和内容的修改另外一个进程可以立即感知</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>一般删除都是文件索引，如果两个文件同时打开同一个文件，一个线程执行删除操作，只要另一个线程不退出，就可以继续对该文件进行操作，一旦退出才找不到该文件的索引节点而报错。</p><p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程.<br><a href="http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoyl/archive/2012/05/15/2502010.html</a><br><a href="http://blog.chinaunix.net/uid-26548237-id-3046664.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26548237-id-3046664.html</a></p><h1 id="考点8-TCP握手-分手"><a href="#考点8-TCP握手-分手" class="headerlink" title="考点8:TCP握手 分手"></a>考点8:TCP握手 分手</h1><p>TCP的握手与分手,可能出现的情形有()。</p><ul><li>A 握手需要3次通信</li><li>B 分手需要进行4次通信</li><li>C <code>FIN</code>和<code>ACK</code> 在同一包里</li><li>D <code>ACK</code> 和<code>SYN</code> 在同一包里</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>知识盲区：后续再解析<br><a href="https://m.nowcoder.com/questions?tagId=42507626&amp;type=1&amp;source=intelli&amp;pos=6" target="_blank" rel="noopener">https://m.nowcoder.com/questions?tagId=42507626&amp;type=1&amp;source=intelli&amp;pos=6</a></p><h1 id="考点9-Linux日志文件"><a href="#考点9-Linux日志文件" class="headerlink" title="考点9:Linux日志文件"></a>考点9:Linux日志文件</h1><p>以下说法正确的是()</p><ul><li>A <code>linux</code>系统中的<code>/var/log/lastlog</code>日志记录了所有用户最后登录的记录,可以用<code>lastlog</code>命令查看</li><li>B <code>linux</code>系统中的<code>/var/log/last</code>日志可以用<code>last</code>命令查看</li><li>C <code>/var/log/wtmp</code>日志记录了登录过本系统的用户信息,可以用<code>tail -f</code>命令查看</li><li>D <code>/var/run/utmp</code>日志记录了正在登录本系统中的用户信息,可以用<code>last -f</code>命令查看</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>B. 执行last指令时，它会读取位于/var/log/wtmp的文件，并把该给文件的内容记录的登录系统的用户名单全部显示出来。<br>C. wtmp是二进制文件，他们不能被诸如tail命令剪贴或合并，需要使用who、w、users、last和ac来使用这两个文件包含的信息。</p><p><strong>/var/log/lastlog</strong>:记录系统中所有用户最后一次的登录时间的曰志。这个文件也是二进制文件.不能直接用Vi 查看。而要使用lastlog命令查看<br><strong>/var/log/wtmp</strong> :永久记录所有用户的登陆、注销信息，同时记录系统的后动、重启、关机事件。同样，这个文件也是二进制文件.不能直接用Vi查看，而要使用<strong>last命令</strong>查看.<br><strong>/var/log/utmp</strong>:记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样，这个文件不能直接用Vi查看，而要使用w、who、users等命令查看 </p><p><strong>/var/log/wtmp</strong>是一个二进制文件，记录每个用户的登录次数和持续时间等信息，使用”last -f”查看，如”last -f /var/log/wtmp”;<br><strong>/var/run/utmp</strong>是一个二进制文件，保存当前在本系统中的用户信息，使用”last -f”查看，如”last -f /var/run/utmp”;<br>  </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://linux.cn/article-10096-1.html" target="_blank" rel="noopener">https://linux.cn/article-10096-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月22日 HTML1</title>
      <link href="/exam//8c8ce85/"/>
      <url>/exam//8c8ce85/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/8c8ce85/#考点1-HTML清除浮动" class="header_1">考点1:HTML清除浮动</a>&nbsp;<br><a href="/exam/8c8ce85/#考点2-jQuery的text，html，val，attr方法" class="header_1">考点2:jQuery的text，html，val，attr方法</a>&nbsp;<br><a href="/exam/8c8ce85/#考点3-HTTP协议" class="header_1">考点3:HTTP协议</a>&nbsp;<br><a href="/exam/8c8ce85/#考点4-HTML5组合标题元素" class="header_1">考点4:HTML5组合标题元素</a>&nbsp;<br><a href="/exam/8c8ce85/#考点5-HTML滑块控件" class="header_1">考点5:HTML滑块控件</a>&nbsp;<br><a href="/exam/8c8ce85/#考点6-HTML5相关框架或者类库" class="header_1">考点6:HTML5相关框架或者类库</a>&nbsp;<br><a href="/exam/8c8ce85/#考点7-HTML5" class="header_1">考点7:HTML5</a>&nbsp;<br><a href="/exam/8c8ce85/#考点8-HTML5新增元素" class="header_1">考点8:HTML5新增元素</a>&nbsp;<br><a href="/exam/8c8ce85/#考点9" class="header_1">考点9:</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-HTML清除浮动"><a href="#考点1-HTML清除浮动" class="headerlink" title="考点1:HTML清除浮动"></a>考点1:HTML清除浮动</h1><p>浮动会导致页面的非正常显示,以下几种清除浮动的方法,哪个是不推荐使用的？</p><ul><li>A 在浮动元素末尾添加一个空的标签例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li><li>B 通过设置父元素<code>overflow</code>值为<code>hidden;</code></li><li>C 父元素也设置浮动</li><li>D 给父元素添加<code>clearfix</code>类</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>完美的解答: <a href="https://segmentfault.com/a/1190000004865198" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004865198</a></p><h1 id="考点2-jQuery的text，html，val，attr方法"><a href="#考点2-jQuery的text，html，val，attr方法" class="headerlink" title="考点2:jQuery的text，html，val，attr方法"></a>考点2:jQuery的text，html，val，attr方法</h1><p>jQuery通过哪个方法可以设置或返回表单字段的值:</p><ul><li>A $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>text()</code></li><li>B $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>html()</code></li><li>C $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>val()</code></li><li>D $(&amp;<code>quot;</code>#<code>test</code>&amp;<code>quot;</code>).<code>attr()</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>.value()  用在表单元素上，用来设置获取 input 或 select 的值<br>.html()  设置或返回的是源代码<br>.text()  设置或返回的是纯文本内容<br>.attr()  设置或返回被选元素的属性值</p><h1 id="考点3-HTTP协议"><a href="#考点3-HTTP协议" class="headerlink" title="考点3:HTTP协议"></a>考点3:HTTP协议</h1><p>下列关于HTTP协议的描述中,错误的是()</p><ul><li>A <code>HTTP</code>协议是应用层协议,它的底层基于<code>UDP</code>连接</li><li>B <code>HTTP</code>协议规定了浏览器与服务器通信的四个步骤,依次是:建立连接、发送请求、接收响应、关闭连接</li><li>C <code>HTTP</code>请求报文中,包含请求方式、请求路径、协议版本、消息头等内容</li><li>D <code>HTTP</code>响应报文中,包含状态码、状态名、协议版本、消息头等内容</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>http是一个简单的请求-响应协议，它通常运行在TCP之上，其底层基于TCP。</p><h1 id="考点4-HTML5组合标题元素"><a href="#考点4-HTML5组合标题元素" class="headerlink" title="考点4:HTML5组合标题元素"></a>考点4:HTML5组合标题元素</h1><p>在 HTML5 中,哪个元素用于组合标题元素？()</p><ul><li>A <code>&lt;group&gt;</code></li><li>B <code>&lt;header&gt;</code></li><li>C <code>&lt;headings&gt;</code></li><li>D <code>&lt;hgroup&gt;</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p><a href="https://m.runoob.com/tags/tag-hgroup.html" target="_blank" rel="noopener">https://m.runoob.com/tags/tag-hgroup.html</a></p><h1 id="考点5-HTML滑块控件"><a href="#考点5-HTML滑块控件" class="headerlink" title="考点5:HTML滑块控件"></a>考点5:HTML滑块控件</h1><p>哪种输入类型定义滑块控件？</p><ul><li>A <code>search</code></li><li>B <code>controls</code></li><li>C <code>slider</code></li><li>D <code>range</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>input type  为 range</p><div class="table-container"><table><thead><tr><th style="text-align:left">input type属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">button</td><td style="text-align:left">定义可点击的按钮（大多与 JavaScript 使用来启动脚本）</td></tr><tr><td style="text-align:left">checkbox</td><td style="text-align:left">定义复选框。</td></tr><tr><td style="text-align:left">color</td><td style="text-align:left">定义拾色器。</td></tr><tr><td style="text-align:left">date</td><td style="text-align:left">定义日期字段（带有 calendar 控件）</td></tr><tr><td style="text-align:left">datetime</td><td style="text-align:left">定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td style="text-align:left">datetime-local</td><td style="text-align:left">定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td style="text-align:left">month</td><td style="text-align:left">定义日期字段的月（带有 calendar 控件）</td></tr><tr><td style="text-align:left">week</td><td style="text-align:left">定义日期字段的周（带有 calendar 控件）</td></tr><tr><td style="text-align:left">time</td><td style="text-align:left">定义日期字段的时、分、秒（带有 time 控件）</td></tr><tr><td style="text-align:left">email</td><td style="text-align:left">定义用于 e-mail 地址的文本字段</td></tr><tr><td style="text-align:left">file</td><td style="text-align:left">定义输入字段和 “浏览…” 按钮，供文件上传</td></tr><tr><td style="text-align:left">hidden</td><td style="text-align:left">定义隐藏输入字段</td></tr><tr><td style="text-align:left">image</td><td style="text-align:left">定义图像作为提交按钮</td></tr><tr><td style="text-align:left">number</td><td style="text-align:left">定义带有 spinner 控件的数字字段</td></tr><tr><td style="text-align:left">password</td><td style="text-align:left">定义密码字段。字段中的字符会被遮蔽。</td></tr><tr><td style="text-align:left">radio</td><td style="text-align:left">定义单选按钮。</td></tr><tr><td style="text-align:left">range</td><td style="text-align:left">定义带有 slider 控件的数字字段。</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">定义重置按钮。重置按钮会将所有表单字段重置为初始值。</td></tr><tr><td style="text-align:left">search</td><td style="text-align:left">定义用于搜索的文本字段。</td></tr><tr><td style="text-align:left">submit</td><td style="text-align:left">定义提交按钮。提交按钮向服务器发送数据。</td></tr><tr><td style="text-align:left">tel</td><td style="text-align:left">定义用于电话号码的文本字段。</td></tr><tr><td style="text-align:left">text</td><td style="text-align:left">默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</td></tr><tr><td style="text-align:left">url</td><td style="text-align:left">定义用于 URL 的文本字段。</td></tr></tbody></table></div><h1 id="考点6-HTML5相关框架或者类库"><a href="#考点6-HTML5相关框架或者类库" class="headerlink" title="考点6:HTML5相关框架或者类库"></a>考点6:HTML5相关框架或者类库</h1><p>下列哪些是HTML5相关的框架或类库:(         )</p><ul><li>A <code>spring-core</code></li><li>B <code>RactiveJS</code></li><li>C <code>Dubbo</code></li><li>D <code>Bootstrap</code></li><li>E <code>AngularJS</code></li><li>F <code>Hibernate</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details><p>Bootstrap、AngularJS这三个。<br>查了一下：<br>Spring框架是一个开放源代码的J2EE应用程序框架<br>Dubbo是一款高性能、轻量级的开源Java RPC框架<br>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架</p><h1 id="考点7-HTML5"><a href="#考点7-HTML5" class="headerlink" title="考点7:HTML5"></a>考点7:HTML5</h1><p>下列属于HTML5新元素的是？()</p><ul><li>A <code>header</code></li><li>B <code>nav</code></li><li>C <code>section</code></li><li>D <code>viewport</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>Viewport是属性<br>HTML5中常用的新特性：<br>canvas元素：用于定义图形（图表等），只是图形容器，必须使用脚本来绘制图形。<br>audio：用于音频播放。<br>video：用于视频播放。<br>article：规定独立的自包含内容。<br>header：定义文档的页眉，介绍相关信息。<br>section：定义文档中的节。<br>footer：定义文档的页脚，通常有文档的作者、版权信息、联系方式等。<br>nav：定义导航链接。<br>表单控件：<br>calender<br>date<br>time<br>email<br>url<br>search<br><a href="https://zhuanlan.zhihu.com/p/25445181" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25445181</a></p><h1 id="考点8-HTML5新增元素"><a href="#考点8-HTML5新增元素" class="headerlink" title="考点8:HTML5新增元素"></a>考点8:HTML5新增元素</h1><p>下列选项中哪些标签是HTML5新增的？</p><ul><li>A <code>footer</code></li><li>B <code>content</code></li><li>C <code>section</code></li><li>D <code>header</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9:"></a>考点9:</h1><p>以下哪些HTML标签属于行内元素:</p><ul><li>A p</li><li>B span</li><li>C canvas</li><li>D label</li><li>E img</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDE</details><p>p 、canvas —&gt; 块状元素<br>span 、img 、label —&gt; 内联元素（行内）</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> HTML CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月22日Linux专项练习2</title>
      <link href="/exam//84510f27/"/>
      <url>/exam//84510f27/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/84510f27/#考点1-Linux八进制文件权限" class="header_1">考点1:Linux八进制文件权限</a>&nbsp;<br><a href="/exam/84510f27/#考点2-ls-al" class="header_1">考点2:ls -al</a>&nbsp;<br><a href="/exam/84510f27/#考点3-Linux路由设置" class="header_1">考点3:Linux路由设置</a>&nbsp;<br><a href="/exam/84510f27/#考点4-Linux环境变量" class="header_1">考点4:Linux环境变量</a>&nbsp;<br><a href="/exam/84510f27/#考点5-grep命令" class="header_1">考点5:grep命令</a>&nbsp;<br><a href="/exam/84510f27/#考点6-tar解压参数" class="header_1">考点6:tar解压参数</a>&nbsp;<br><a href="/exam/84510f27/#考点7-软链接硬链接" class="header_1">考点7:软链接硬链接</a>&nbsp;<br><a href="/exam/84510f27/#考点8-环境变量" class="header_1">考点8:环境变量</a>&nbsp;<br><a href="/exam/84510f27/#考点9-shell脚本参数" class="header_1">考点9:shell脚本参数</a>&nbsp;<br><a href="/exam/84510f27/#考点10-进程间通讯方式" class="header_1">考点10:进程间通讯方式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux八进制文件权限"><a href="#考点1-Linux八进制文件权限" class="headerlink" title="考点1:Linux八进制文件权限"></a>考点1:Linux八进制文件权限</h1><p> 权限为765的文件,下列哪个是正确的权限位标记()?</p><ul><li>A <code>-rw-rw-r-x</code></li><li>B <code>-rw-r-xr-r</code></li><li>C <code>-rwxrw-r-x</code></li><li>D <code>-rwxr-xrwx</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>首先在 rwx 中r=4，w=2，x=1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7&#x3D;4+2+1</span><br><span class="line">6&#x3D;4+2</span><br><span class="line">5&#x3D;4+1</span><br></pre></td></tr></table></figure><br>因此是<code>rwxrw-r-x</code>，选C<br>至于最前面那位，如果是文件夹的话为d，否则为-</p><h1 id="考点2-ls-al"><a href="#考点2-ls-al" class="headerlink" title="考点2:ls -al"></a>考点2:ls -al</h1><p>用ls –al 命令列出下面的文件列表,哪个文件是符号连接文件？</p><ul><li>A -rw-rw-rw- 2 hel-s users 56 Sep 09 11:05 hello</li><li>B -rwxrwxrwx 2 hel-s users 56 Sep 09 11:05 goodbye</li><li>C drwxr—r— 1 hel users 1024 Sep 10 08:10 zhang</li><li>D lrwxr—r— 1 hel users 2024 Sep 12 08:12 cheng &gt; peng.yan1</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="ls-l第一列含义"><a href="#ls-l第一列含义" class="headerlink" title="ls -l第一列含义"></a>ls -l第一列含义</h3><p>ls -l的第一列的</p><ul><li>第1个字符表示文件的类型，<ul><li><code>-</code> 表示文件；</li><li><code>d</code> 表示目录directory；</li><li><code>l</code> 表示软链接link。软链接 类似于快捷方式，当源文件丢失时，软链接也失败。</li></ul></li><li>第2，3，4个字符是文件所属主的权限，</li><li>第5，6，7个字符是，所属组的权限，、</li><li>第8，9，10个字符是其他用户的权限</li></ul><p>软链接就类似windows的快捷方式，删掉源文件快捷方式就不能用了。 而硬链接源文件和新文件是同等地位的，删了源文件，用新文件依旧可以访问，只是有一个记录链接数的参数会减一。</p><h1 id="考点3-Linux路由设置"><a href="#考点3-Linux路由设置" class="headerlink" title="考点3:Linux路由设置"></a>考点3:Linux路由设置</h1><p>局域网的网络地址192.168.1.0/24,局域网络连接其它网络的网关地址是192.168.1.1。主机192.168.1.20访问172.16.1.0/24网络时,其路由设置正确的是？</p><ul><li>A route add –net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</li><li>B route add –net 172.16.1.0 gw 192.168.1.1 netmask 255.255.255.0 metric 1</li><li>C route add –net 172.16.1.0 gw 172.16.1.1 netmask 255.255.255.0 metric 1</li><li>D route add default 192.168.1.0 netmask 172.168.1.1 metric 1</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>-net 后面跟的是目标网络，gw就是gateway（网关入口）就是你从哪个网关去到那个目标网络。</p><h1 id="考点4-Linux环境变量"><a href="#考点4-Linux环境变量" class="headerlink" title="考点4:Linux环境变量"></a>考点4:Linux环境变量</h1><p>以下哪个环境变量表示当前路径 () 。</p><ul><li>A <code>PATH</code></li><li>B <code>PWD</code></li><li>C <code>HOME</code></li><li>D <code>ROOT</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h3><p>命令pwd是print working directory的缩写，打印当前工作目录</p><h3 id="PWD环境变量"><a href="#PWD环境变量" class="headerlink" title="PWD环境变量"></a>PWD环境变量</h3><p>大写的PWD代表环境变量，小写的pwd是shell命令输出当前工作目录。</p><h4 id="查看PWD环境变量"><a href="#查看PWD环境变量" class="headerlink" title="查看PWD环境变量:"></a>查看PWD环境变量:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PWD</span><br></pre></td></tr></table></figure><h3 id="PWD和OLDPWD环境变量"><a href="#PWD和OLDPWD环境变量" class="headerlink" title="PWD和OLDPWD环境变量"></a>PWD和OLDPWD环境变量</h3><p><code>PWD</code>记录当前的目录路径，当利用<code>cd</code>命令切换当前目录时，系统自动更新<code>PWD</code>的值，<br><code>OLDPWD</code>记录旧的工作目录，即用户所处的前一个目录。</p><h3 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h3><p>查看系统中所有环境变量可以使用env命令,可以看到PWD的值会随着工作目录变化而变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# env</span><br><span class="line">NVM_RC_VERSION&#x3D;</span><br><span class="line">HOSTNAME&#x3D;localhost</span><br><span class="line">NVM_CD_FLAGS&#x3D;</span><br><span class="line">TERM&#x3D;xterm</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">HISTSIZE&#x3D;1000</span><br><span class="line">SSH_CLIENT&#x3D;192.168.1.4 5694 22</span><br><span class="line">SSH_TTY&#x3D;&#x2F;dev&#x2F;pts&#x2F;5</span><br><span class="line">NVM_DIR&#x3D;&#x2F;root&#x2F;.nvm</span><br><span class="line">JRE_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_281&#x2F;jre</span><br><span class="line">USER&#x3D;root</span><br><span class="line">LS_COLORS&#x3D;rs&#x3D;0:di&#x3D;01;34:ln&#x3D;01;36:mh&#x3D;00:pi&#x3D;40;33:so&#x3D;01;35:do&#x3D;01;35:bd&#x3D;40;33;01:cd&#x3D;40;33;01:or&#x3D;40;31;01:mi&#x3D;01;05;37;41:su&#x3D;37;41:sg&#x3D;30;43:ca&#x3D;30;41:tw&#x3D;30;42:ow&#x3D;34;42:st&#x3D;37;44:ex&#x3D;01;32:*.tar&#x3D;01;31:*.tgz&#x3D;01;31:*.arc&#x3D;01;31:*.arj&#x3D;01;31:*.taz&#x3D;01;31:*.lha&#x3D;01;31:*.lz4&#x3D;01;31:*.lzh&#x3D;01;31:*.lzma&#x3D;01;31:*.tlz&#x3D;01;31:*.txz&#x3D;01;31:*.tzo&#x3D;01;31:*.t7z&#x3D;01;31:*.zip&#x3D;01;31:*.z&#x3D;01;31:*.Z&#x3D;01;31:*.dz&#x3D;01;31:*.gz&#x3D;01;31:*.lrz&#x3D;01;31:*.lz&#x3D;01;31:*.lzo&#x3D;01;31:*.xz&#x3D;01;31:*.bz2&#x3D;01;31:*.bz&#x3D;01;31:*.tbz&#x3D;01;31:*.tbz2&#x3D;01;31:*.tz&#x3D;01;31:*.deb&#x3D;01;31:*.rpm&#x3D;01;31:*.jar&#x3D;01;31:*.war&#x3D;01;31:*.ear&#x3D;01;31:*.sar&#x3D;01;31:*.rar&#x3D;01;31:*.alz&#x3D;01;31:*.ace&#x3D;01;31:*.zoo&#x3D;01;31:*.cpio&#x3D;01;31:*.7z&#x3D;01;31:*.rz&#x3D;01;31:*.cab&#x3D;01;31:*.jpg&#x3D;01;35:*.jpeg&#x3D;01;35:*.gif&#x3D;01;35:*.bmp&#x3D;01;35:*.pbm&#x3D;01;35:*.pgm&#x3D;01;35:*.ppm&#x3D;01;35:*.tga&#x3D;01;35:*.xbm&#x3D;01;35:*.xpm&#x3D;01;35:*.tif&#x3D;01;35:*.tiff&#x3D;01;35:*.png&#x3D;01;35:*.svg&#x3D;01;35:*.svgz&#x3D;01;35:*.mng&#x3D;01;35:*.pcx&#x3D;01;35:*.mov&#x3D;01;35:*.mpg&#x3D;01;35:*.mpeg&#x3D;01;35:*.m2v&#x3D;01;35:*.mkv&#x3D;01;35:*.webm&#x3D;01;35:*.ogm&#x3D;01;35:*.mp4&#x3D;01;35:*.m4v&#x3D;01;35:*.mp4v&#x3D;01;35:*.vob&#x3D;01;35:*.qt&#x3D;01;35:*.nuv&#x3D;01;35:*.wmv&#x3D;01;35:*.asf&#x3D;01;35:*.rm&#x3D;01;35:*.rmvb&#x3D;01;35:*.flc&#x3D;01;35:*.avi&#x3D;01;35:*.fli&#x3D;01;35:*.flv&#x3D;01;35:*.gl&#x3D;01;35:*.dl&#x3D;01;35:*.xcf&#x3D;01;35:*.xwd&#x3D;01;35:*.yuv&#x3D;01;35:*.cgm&#x3D;01;35:*.emf&#x3D;01;35:*.axv&#x3D;01;35:*.anx&#x3D;01;35:*.ogv&#x3D;01;35:*.ogx&#x3D;01;35:*.aac&#x3D;01;36:*.au&#x3D;01;36:*.flac&#x3D;01;36:*.mid&#x3D;01;36:*.midi&#x3D;01;36:*.mka&#x3D;01;36:*.mp3&#x3D;01;36:*.mpc&#x3D;01;36:*.ogg&#x3D;01;36:*.ra&#x3D;01;36:*.wav&#x3D;01;36:*.axa&#x3D;01;36:*.oga&#x3D;01;36:*.spx&#x3D;01;36:*.xspf&#x3D;01;36:</span><br><span class="line">MAIL&#x3D;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;root</span><br><span class="line">PATH&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_281&#x2F;bin:&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_281&#x2F;jre&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;git&#x2F;bin:&#x2F;root&#x2F;bin</span><br><span class="line">PWD&#x3D;&#x2F;root</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk1.8.0_281</span><br><span class="line">LANG&#x3D;zh_CN.UTF-8</span><br><span class="line">HISTCONTROL&#x3D;ignoredups</span><br><span class="line">SHLVL&#x3D;1</span><br><span class="line">HOME&#x3D;&#x2F;root</span><br><span class="line">LOGNAME&#x3D;root</span><br><span class="line">CLASSPATH&#x3D;.:JAVA_HOME&#x2F;lib:JRE_HOME&#x2F;lib:</span><br><span class="line">SSH_CONNECTION&#x3D;192.168.1.4 5694 192.168.1.3 22</span><br><span class="line">LESSOPEN&#x3D;||&#x2F;usr&#x2F;bin&#x2F;lesspipe.sh %s</span><br><span class="line">_&#x3D;&#x2F;usr&#x2F;bin&#x2F;env</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h3 id="PATH环境变量"><a href="#PATH环境变量" class="headerlink" title="PATH环境变量"></a>PATH环境变量</h3><p><code>PATH</code>是<code>Linux</code>中一个极为重要的环境变量，它用于帮助<code>Shell</code>找到用户输入的命令。用户所输入的每个命令实际上是一个源代码文件，计算机执行这个文件里的代码以实现这个命令的功能，这些源代码文件称为可执行文件。可执行文件存在于各种各样的目录下，<code>PATH</code>就记录了一系列的目录列表，<code>Shell</code>为每个输入命令搜索<code>PATH</code>中的目录列表。</p><h3 id="HOME环境变量"><a href="#HOME环境变量" class="headerlink" title="HOME环境变量"></a>HOME环境变量</h3><p><code>HOME</code>记录当前用户的目录，由<code>/etc/passwd</code>的倒数第2个域决定，<code>HOME</code>目录用于保存用户自己的文件。</p><pre>[root@localhost ~]&#35; cat /etc/passwd|grep rootroot:x:0:0:root:<mark>/root</mark>:/bin/bashoperator:x:11:0:operator:/root:/sbin/nologin[root@localhost ~]&#35; </pre><h1 id="考点5-grep命令"><a href="#考点5-grep命令" class="headerlink" title="考点5:grep命令"></a>考点5:grep命令</h1><p>在Linux系统中, 为找到文件try_grep含有以a字母为行开头的内容, 可以使用命令？</p><ul><li>A grep -E #$ try_grep</li><li>B grep -E #a try_grep</li><li>C grep -E ^$ try_grep</li><li>D grep -E ^a try_grep</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p><code>-E</code>参数：表示使用扩展的正则表达式</p><p><code>^</code>：开始行<br><code>$</code>: 结束行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep  -E  ^a  try_grep #匹配以a开头的行</span><br><span class="line">grep  -E  a$  try_grep #匹配以a结束的行</span><br></pre></td></tr></table></figure><h1 id="考点6-tar解压参数"><a href="#考点6-tar解压参数" class="headerlink" title="考点6:tar解压参数"></a>考点6:tar解压参数</h1><p>tar命令用于解压的参数是？</p><ul><li>A -v</li><li>B -x</li><li>C -c</li><li>D -f</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="tar参数"><a href="#tar参数" class="headerlink" title="tar参数"></a>tar参数</h3><p>主要参数：</p><ul><li>c：创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于<strong>打包</strong>。 </li><li>x：从档案文件中释放文件。相当于<strong>拆包</strong>。</li></ul><p>辅助参数：</p><ul><li>z：是否同时具有 gzip 的属性？亦即是否需要用gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz </li><li>j：是否同时具有 bzip2 的属性？亦即是否需要用bzip2 压缩或解压？一般格式为xx.tar.bz2   </li><li>v：压缩的过程中显示文件！这个常用 </li><li>f：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！ </li><li>p：使用原文件的原来属性（属性不会依据使用者而变） </li><li>—exclude FILE：在压缩的过程中，不要将 FILE 打包！ </li></ul><h1 id="考点7-软链接硬链接"><a href="#考点7-软链接硬链接" class="headerlink" title="考点7:软链接硬链接"></a>考点7:软链接硬链接</h1><p>Linux中包括两种链接:硬链接(Hard Link)和软链接(Soft Link),下列说法正确的是()</p><ul><li>A 软链接可以跨文件系统进行连接,硬链接不可以</li><li>B 当删除原文件的时候软链接文件仍然存在,且指向的内容不变</li><li>C 硬链接被删除,磁盘上的数据文件会同时被删除</li><li>D 硬链接会重新建立一个<code>inode</code>,软链接不会</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h3><p>链接操作实际上是给系统中已有的某个文件指定另外一个可用于访问它的名称。对于这个新的文件名，我们可以为之指定不同的</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>硬链接只能引用同一文件系统中的文件。<br>它引用的是文件在文件系统中的物理索引(也称为 inode)。<br>当您移动或删除原始文件时，硬链接不会被破坏，因为它所引用的是文件的物理数据而不是文件在文件结构中的位置。<br>硬链接的文件不需要用户有访问原始文件的权限，也不会显示原始文件的位置，这样有助于文件的安全。<br>如果您删除的文件有相应的硬链接，那么这个文件依然会保留，直到所有对它的引用都被删除。</p><h3 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title="软链接（符号链接）"></a>软链接（符号链接）</h3><p>软链接，其实就是新建立一个文件，这个文件就是专门用来指向别的文件的（那就和windows 下的快捷方式的那个文件有很接近的意味）。<br>软链接产生的是一个新的文件，但这个文件的作用就是专门指向某个文件的，删了这个软链接文件，那就等于不需要这个连接，和原来的存在的实体原文件没有任何关系，<br>但删除原来的文件，则相应的软链接不可用（cat那个软链接文件，则提示“没有该文件或目录“）。</p><h3 id="硬链接与软链接的区别"><a href="#硬链接与软链接的区别" class="headerlink" title="硬链接与软链接的区别"></a>硬链接与软链接的区别</h3><h4 id="硬链接不会创建inode-不可跨越文件系统"><a href="#硬链接不会创建inode-不可跨越文件系统" class="headerlink" title="硬链接不会创建inode 不可跨越文件系统"></a>硬链接不会创建inode 不可跨越文件系统</h4><p>硬链接是不会建立inode的，他只是在文件原来的inode link count域再增加1而已，也因此硬链接是不可以跨越文件系统的。</p><h4 id="软链接会重新创建inode"><a href="#软链接会重新创建inode" class="headerlink" title="软链接会重新创建inode"></a>软链接会重新创建inode</h4><p>相反都是软链接会重新建立一个inode，当然inode的结构跟其他的不一样，他只是一个指明源文件的字符串信息。一旦删除源文件，那么软链接将变得毫无意义。</p><h4 id="删除硬链接的时候-文件可能不会被删除"><a href="#删除硬链接的时候-文件可能不会被删除" class="headerlink" title="删除硬链接的时候 文件可能不会被删除"></a>删除硬链接的时候 文件可能不会被删除</h4><p>而硬链接删除的时候，系统调用会检查inode link count的数值，如果他大于等于1，那么inode不会被回收。因此文件的内容不会被删除。</p><h4 id="硬链接的链接文件和源文件是同一个文件"><a href="#硬链接的链接文件和源文件是同一个文件" class="headerlink" title="硬链接的链接文件和源文件是同一个文件"></a>硬链接的链接文件和源文件是同一个文件</h4><p>硬链接实际上是为文件建一个别名，链接文件和原文件实际上是同一个文件。</p><p>可以通过ls -i来查看一下，这两个文件的inode号是同一个，说明它们是同一个文件；</p><p>而软链接建立的是一个指向，即链接文件内的内容是指向原文件的指针，它们是两个文件。</p><h4 id="软链接可以跨文件系统"><a href="#软链接可以跨文件系统" class="headerlink" title="软链接可以跨文件系统"></a>软链接可以跨文件系统</h4><p>软链接可以跨文件系统，硬链接不可以；</p><h4 id="硬链接的文件必须存在-软链接可以对不存在的文件进行链接"><a href="#硬链接的文件必须存在-软链接可以对不存在的文件进行链接" class="headerlink" title="硬链接的文件必须存在 软链接可以对不存在的文件进行链接"></a>硬链接的文件必须存在 软链接可以对不存在的文件进行链接</h4><p>软链接可以对一个不存在的文件名(filename)进行链接（当然此时如果你vi这个软链接文件，linux会自动新建一个文件名为filename的文件）,<br>硬链接不可以（其文件必须存在，inode必须存在）；</p><h4 id="软链接可以对目录进行链接-硬链接不可以"><a href="#软链接可以对目录进行链接-硬链接不可以" class="headerlink" title="软链接可以对目录进行链接 硬链接不可以"></a>软链接可以对目录进行链接 硬链接不可以</h4><p>软链接可以对目录进行连接，硬链接不可以。</p><h3 id="如何创建链接"><a href="#如何创建链接" class="headerlink" title="如何创建链接"></a>如何创建链接</h3><p>两种链接都可以通过命令ln 来创建。</p><h4 id="创建硬链接ln"><a href="#创建硬链接ln" class="headerlink" title="创建硬链接ln"></a>创建硬链接ln</h4><p><code>ln</code>默认创建的是硬链接。</p><h4 id="创建软链接ls-s"><a href="#创建软链接ls-s" class="headerlink" title="创建软链接ls -s"></a>创建软链接ls -s</h4><p>使用<code>ln -s</code>可以创建软链接。</p><h1 id="考点8-环境变量"><a href="#考点8-环境变量" class="headerlink" title="考点8:环境变量"></a>考点8:环境变量</h1><p>在RHEL5系统中,下面关于shell环境变量配置文件的描述,正确的是(  )</p><ul><li>A 用户登录系统时,<code>bash</code>首先执行<code>/etc/profile</code>配置文件和<code>/etc/profile.d/</code>目录下的配置文件,这些配置文件对所有用户都有效</li><li>B 用户登录系统时,<code>bash</code>首先执行<code>.bash_profile</code>文件和<code>.bashrc</code>文件,这些配置文件对所有用户都有效</li><li>C 用户主目录下的.<code>bashrc</code>设置为每次登录时执行,而<code>.bash_profile</code>则为每次打开新的终端时执行</li><li>D 执行用户主目录下的环境变量配置文件时,不可以重复设置用户登录时配置文件中已经设置的选项</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p><a href="https://www.jianshu.com/p/6d32b166f47d" target="_blank" rel="noopener">https://www.jianshu.com/p/6d32b166f47d</a></p><h3 id="ect-profile"><a href="#ect-profile" class="headerlink" title="/ect/profile"></a>/ect/profile</h3><p>此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从<code>/etc/profile.d</code>目录的配置文件中搜集shell的设置.</p><h3 id="etc-bashrc"><a href="#etc-bashrc" class="headerlink" title="/etc/bashrc"></a>/etc/bashrc</h3><p>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</p><h3 id="bash-profile"><a href="#bash-profile" class="headerlink" title="~/.bash_profile"></a>~/.bash_profile</h3><p>每个用户都可使用该文件输入<br>专用于 自己使用的shell信息,<strong>当用户登录时,该文件仅仅执行一次</strong>!默认情况下,他设置一些环境变量,执行~/.bashrc文件.</p><h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>该文件包含专用于用户的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.</p><h3 id="bash-logout"><a href="#bash-logout" class="headerlink" title="~/.bash_logout"></a>~/.bash_logout</h3><blockquote><p><a href="https://blog.csdn.net/wackycrazy/article/details/47998747" target="_blank" rel="noopener">https://blog.csdn.net/wackycrazy/article/details/47998747</a><br>/etc/profile 文件中设定的环境变量，运行的命令或脚本，针对所有用户有效<br>/etc/bashrc 文件中设定的本地变量，定义的别名，针对所有启动的shell程序的用户有效<br>这两个配置文件是全局的。<br>~/.bash_profile 作用跟/etc/profile是一样的，只不过针对的是某一个用户<br>~/.bashrc的作用跟/etc/bashrc也是一样的，只不过针对的也是某一个用户</p><p><a href="https://blog.csdn.net/ithomer/article/details/6322892" target="_blank" rel="noopener">https://blog.csdn.net/ithomer/article/details/6322892</a><br>（1） /etc/profile： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。<br>（2） /etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取（即每次新开一个终端，都会执行bashrc）。<br>（3） ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次。默认情况下,设置一些环境变量,执行用户的.bashrc文件。<br>（4） ~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。<br>（5） ~/.bash_logout: 当每次退出系统(退出bash shell)时,执行该文件. 另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是”父子”关系。<br>（6） ~/.bash_profile: 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p><p><a href="https://www.linuxprobe.com/diff-bashrcprofile.html" target="_blank" rel="noopener">https://www.linuxprobe.com/diff-bashrcprofile.html</a><br>profile<br>其实看名字就能了解大概了, profile 是某个用户唯一的用来设置环境变量的地方, 因为用户可以有多个 shell 比如 bash, sh, zsh 之类的, 但像环境变量这种其实只需要在统一的一个地方初始化就可以了, 而这就是 profile.<br>bashrc<br>bashrc 也是看名字就知道, 是专门用来给 bash 做初始化的比如用来初始化 bash 的设置, bash 的代码补全, bash 的别名, bash 的颜色. 以此类推也就还会有 shrc, zshrc 这样的文件存在了, 只是 bash 太常用了而已.<br>期望的执行顺序</p><p><a href="https://zhuanlan.zhihu.com/p/25944849" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25944849</a><br>~/.bashrc<br>该文件存储的是专属于个人bash shell的信息，当登录时以及每次打开一个新的shell时,执行这个文件。在这个文件里可以自定义用户专属的个人信息。<br>相关文件的读取顺序<br>在刚登录Linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个，执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。</p><p><a href="http://blog.itpub.net/27040306/viewspace-732343/" target="_blank" rel="noopener">http://blog.itpub.net/27040306/viewspace-732343/</a><br>/etc/profile、/etc/bashrc、~/.bash_profile、~/.bashrc很容易混淆，他们之间有什么区别？它们的作用到底是什么？<br>/etc/profile: 用来设置系统环境参数，比如$PATH. 这里面的环境变量是对系统内所有用户生效的。<br>/etc/bashrc:  这个文件设置系统bash shell相关的东西，对系统内所有用户生效。只要用户运行bash命令，那么这里面的东西就在起作用。<br>~/.bash_profile: 用来设置一些环境变量，功能和/etc/profile 类似，但是这个是针对用户来设定的，也就是说，你在/home/user1/.bash_profile 中设定了环境变量，那么这个环境变量只针对 user1 这个用户生效.<br>~/.bashrc: 作用类似于/etc/bashrc, 只是针对用户自己而言，不对其他用户生效。<br>另外/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是”父子”关系.<br>~/.bash_profile 是交互式、login 方式进入 bash 运行的，意思是只有用户登录时才会生效。<br>~/.bashrc 是交互式 non-login 方式进入 bash 运行的，用户不一定登录，只要以该用户身份运行命令行就会读取该文件。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1148535" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1148535</a></p><blockquote><p>/etc/profile<br>为系统的每个用户设置环境信息和启动程序，当用户第一次登录时，该文件被执行，其配置对所有登录的用户都有效。当被修改时，必须重启才会生效。英文描述：”System wide environment and startup programs, for login setup.”<br>/etc/environment<br>系统的环境变量，/etc/profile是所有用户的环境变量，前者与登录用户无关，后者与登录用户有关，当同一变量在两个文件里有冲突时，以用户环境为准。<br>/etc/bashrc<br>为每个运行 bash shell 的用户执行该文件，当 bash shell 打开时，该文件被执行，其配置对所有使用bash的用户打开的每个bash都有效。当被修改后，不用重启只需要打开一个新的 bash 即可生效。英文描述：”System wide functions and aliases.”<br>~/.bash_profile<br>为当前用户设置专属的环境信息和启动程序，当用户登录时该文件执行一次。默认情况下，它用于设置环境变量，并执行当前用户的 .bashrc 文件。理念类似于 /etc/profile，只不过只对当前用户有效，也需要重启才能生效。(注意：Centos7系统命名为.bash_profile，其他系统可能是.bash_login或.profile。)<br>~/.bashrc<br>为当前用户设置专属的 bash 信息，当每次打开新的shell时，该文件被执行。理念类似于/etc/bashrc，只不过只对当前用户有效，不需要重启只需要打开新的shell即可生效。<br>~/.bash_logout<br>为当前用户，每次退出bash shell时执行该文件，可以把一些清理工作的命令放进这个文件。<br>/etc/profile.d/<br>此文件夹里是除/etc/profile之外其他的”application-specific startup files”。英文描述为”The /etc/profile file sets the environment variables at startup of the Bash shell. The /etc/profile.d directory contains other scripts that contain application-specific startup files, which are also executed at startup time by the shell.” 同时，这些文件”are loaded via /etc/profile which makes them a part of the bash “profile” in the same way anyway.” 因此可以简单的理解为是/etc/profile的一部分，只不过按类别或功能拆分成若干个文件进行配置了（方便维护和理解）。<br>注意事项<br>以上需要重启才能生效的文件，其实可以通过source xxx暂时生效。<br> 文件的执行顺序为：当登录Linux时，首先启动/etc/environment和/etc/profile，然后启动当前用户目录下的/.bash_profile，执行此文件时一般会调用/.bashrc文件，而执行/.bashrc时一般会调用/etc/bashrc，最后退出shell时，执行/.bash_logout。简单来说顺序为：<br>  （登录时）/etc/environment –&gt; /etc/profile(以及/etc/profile.d/里的文件) –&gt; ~/.bash_profile –&gt; （打开shell时）~/.bashrc –&gt; /etc/bashrc –&gt; （退出shell时）~/.bash_logout</p></blockquote><h1 id="考点9-shell脚本参数"><a href="#考点9-shell脚本参数" class="headerlink" title="考点9:shell脚本参数"></a>考点9:shell脚本参数</h1><p>如果参数列表个数为1则执行<script type="math/tex"><1` , 如果参数列表个数为2则执行`$<2<</script> ,其他情况则……,补充下面的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Case (  ) in</span><br><span class="line"><span class="meta">1&gt;</span></span><br><span class="line"><span class="meta">   $</span><span class="bash">&lt;1</span></span><br><span class="line"><span class="meta">2&gt;</span></span><br><span class="line"><span class="meta">   $</span><span class="bash">&lt;2&lt;<span class="variable">$1</span></span></span><br><span class="line">Default &gt; </span><br><span class="line">   echo ……</span><br></pre></td></tr></table></figure></p><ul><li>A $$</li><li>B $#</li><li>C $@</li><li>D $*</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$#</code></td><td style="text-align:left">是传给脚本的参数个数</td></tr><tr><td style="text-align:left"><code>$0</code></td><td style="text-align:left">是脚本本身的名字</td></tr><tr><td style="text-align:left"><code>$1</code></td><td style="text-align:left">是传递给该shell脚本的第一个参数</td></tr><tr><td style="text-align:left"><code>$2</code></td><td style="text-align:left">是传递给该shell脚本的第二个参数</td></tr><tr><td style="text-align:left"><code>$@</code></td><td style="text-align:left">是传给脚本的所有参数的列表</td></tr><tr><td style="text-align:left"><code>$*</code></td><td style="text-align:left">是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</td></tr><tr><td style="text-align:left"><code>$$</code></td><td style="text-align:left">是脚本运行的当前进程ID号</td></tr><tr><td style="text-align:left"><code>$?</code></td><td style="text-align:left">是显示最后命令的退出状态，0表示没有错误，其他表示有错误</td></tr></tbody></table></div><h1 id="考点10-进程间通讯方式"><a href="#考点10-进程间通讯方式" class="headerlink" title="考点10:进程间通讯方式"></a>考点10:进程间通讯方式</h1><p>进程间通讯方式有哪些？</p><ul><li>A 管道</li><li>B 消息队列</li><li>C 共享内存</li><li>D 文件和记录锁定</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h3 id="UNIX的通信方式"><a href="#UNIX的通信方式" class="headerlink" title="UNIX的通信方式"></a>UNIX的通信方式</h3><h4 id="1-文件和记录锁定"><a href="#1-文件和记录锁定" class="headerlink" title="1 文件和记录锁定"></a>1 文件和记录锁定</h4><p>为避免两个进程间同时要求访问同一共享资源而引起访问和操作的混乱，在进程对共享资源进行访问前必须对其进行锁定，该进程访问完后再释放。这是UNIX为共享资源提供的互斥性保障。</p><h4 id="2-管道"><a href="#2-管道" class="headerlink" title="2 管道"></a>2 管道</h4><p>管道一般用于两个不同进程之间的通信。当一个进程创建一个管道，并调用fork创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样 提供了两个进程之间数据流动的一种方式。</p><h4 id="3-FIFO"><a href="#3-FIFO" class="headerlink" title="3 FIFO"></a>3 FIFO</h4><p>FIFO是一种先进先出的队列。它类似于一个管道，只允许数据的单向流动。每个FIFO都有一个名字，允许不相关的进程访问同一个FIFO。因此也成为命名管。</p><h4 id="4-消息队列"><a href="#4-消息队列" class="headerlink" title="4 消息队列"></a>4 消息队列</h4><p>UNIX下不同进程之间可实现共享资源的一种机制；UNIX允许不同进程将格式化的数据流以消息形式发送给任意进程。对消息队列具有操作权限的进程都可以使用msget完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读消息，或为消息安排优先级顺序。</p><h4 id="5-信号灯"><a href="#5-信号灯" class="headerlink" title="5 信号灯"></a>5 信号灯</h4><p>作为进程间通讯的一种方法，它不是用于交换大批数据，而用于多进程之间的同步（协调对共享存储段的存取）。</p><h4 id="6-共享内存"><a href="#6-共享内存" class="headerlink" title="6 共享内存"></a>6 共享内存</h4><p>通过信号灯实现存储共享（类似“红灯停、绿灯行”）</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月22日Linux专项练习3</title>
      <link href="/exam//f3563fb1/"/>
      <url>/exam//f3563fb1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f3563fb1/#考点1-Linux添加用户命令" class="header_1">考点1:Linux添加用户命令</a>&nbsp;<br><a href="/exam/f3563fb1/#考点2-查看线程信息的gdb" class="header_1">考点2:查看线程信息的gdb</a>&nbsp;<br><a href="/exam/f3563fb1/#考点3-Linux查看CPU占用" class="header_1">考点3:Linux查看CPU占用</a>&nbsp;<br><a href="/exam/f3563fb1/#考点4-etc目录下各个文件的作用" class="header_1">考点4:/etc目录下各个文件的作用</a>&nbsp;<br><a href="/exam/f3563fb1/#考点5-Linux系统调用" class="header_1">考点5:Linux系统调用</a>&nbsp;<br><a href="/exam/f3563fb1/#考点6-top-free-proc-meminfo" class="header_1">考点6:top free /proc/meminfo</a>&nbsp;<br><a href="/exam/f3563fb1/#考点7-哪些是子进程从父进程继承得到的" class="header_1">考点7:哪些是子进程从父进程继承得到的</a>&nbsp;<br><a href="/exam/f3563fb1/#考点8-Linux主机负载相关命令" class="header_1">考点8:Linux主机负载相关命令</a>&nbsp;<br><a href="/exam/f3563fb1/#考点9-Linux交换分区" class="header_1">考点9:Linux交换分区</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-Linux添加用户命令"><a href="#考点1-Linux添加用户命令" class="headerlink" title="考点1:Linux添加用户命令"></a>考点1:Linux添加用户命令</h1><p>增加一个用户的命令是什么</p><ul><li>A <code>useradd</code></li><li>B <code>usermod</code></li><li>C <code>groupadd</code></li><li>D <code>userdel</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><ul><li>useradd 增加用户</li><li>usermod 修改用户账号信息</li><li>groupadd 添加组账号</li><li>userdel 删除用户</li></ul><h1 id="考点2-查看线程信息的gdb"><a href="#考点2-查看线程信息的gdb" class="headerlink" title="考点2:查看线程信息的gdb"></a>考点2:查看线程信息的gdb</h1><p>写出完成gdb查看线程信息功能的gdb命令。</p><ul><li>A <code>bt</code></li><li>B <code>info thread</code></li><li>C <code>set scheduler-locking off</code></li><li>D <code>info break</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="backtrace-bt"><a href="#backtrace-bt" class="headerlink" title="backtrace bt"></a>backtrace bt</h3><p>打印当前的函数调用栈的所有信息。</p><h3 id="info-threads"><a href="#info-threads" class="headerlink" title="info threads"></a>info threads</h3><p>显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。前面有*的是当前调试的线程。</p><h3 id="set-scheduler-locking"><a href="#set-scheduler-locking" class="headerlink" title="set scheduler-locking"></a>set scheduler-locking</h3><p>线程调试显示线程状态,off 不锁定任何线程</p><h3 id="info-break"><a href="#info-break" class="headerlink" title="info break"></a>info break</h3><p>可列出所有断点信息，info break 后也可设置要查看的break num</p><h1 id="考点3-Linux查看CPU占用"><a href="#考点3-Linux查看CPU占用" class="headerlink" title="考点3:Linux查看CPU占用"></a>考点3:Linux查看CPU占用</h1><p>linux查看cpu占用的命令是什么？</p><ul><li>A <code>top</code></li><li>B <code>netstat</code></li><li>C <code>free</code></li><li>D <code>df</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">top</td><td style="text-align:left">查看CPU占用、</td></tr><tr><td style="text-align:left">netstat</td><td style="text-align:left">显示网络连接、路由表、网络接口信息、</td></tr><tr><td style="text-align:left">free</td><td style="text-align:left">查看内存使用情况、</td></tr><tr><td style="text-align:left">df</td><td style="text-align:left">检查文件系统的磁盘空间的占用情况</td></tr></tbody></table></div><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 14:55:48 up 1 day,  7:53,  1 user,  load average: 5.39, 5.48, 5.66</span><br><span class="line">Tasks: 459 total,   5 running, 454 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.9 us, 10.5 sy,  0.0 ni, 86.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  3686064 total,   210728 free,  1495188 used,  1980148 buff&#x2F;cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  2154167 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                  </span><br><span class="line">  459 aid_med+  20   0  105704  25716   8812 S  28.6  0.7 525:05.08 mediaserver                                                                                              </span><br><span class="line">18389 root      20   0  112596   2364   1372 R  23.8  0.1   0:00.13 top                                                                                                      </span><br><span class="line">  271 root      rt   0       0      0      0 S   4.8  0.0  20:48.85 cfinteractive                                                                                            </span><br><span class="line"> 3100 root      19  -1       0      0      0 S   4.8  0.0  11:05.56 VosRXThread                                                                                              </span><br><span class="line">    1 root      20   0    1256   1000    396 S   0.0  0.0   1:29.37 init                                                                                                     </span><br><span class="line">    2 root      -2   0       0      0      0 S   0.0  0.0   0:00.25 kthreadd                                                                                                 </span><br><span class="line">    3 root      20   0       0      0      0 S   0.0  0.0   2:26.66 ksoftirqd&#x2F;0                                                                                              </span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:00.10 kworker&#x2F;u16:0                                                                                            </span><br><span class="line">    7 root      20   0       0      0      0 S   0.0  0.0   3:14.78 rcu_preempt                                                                                              </span><br><span class="line">    8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh                                                                                                   </span><br><span class="line">    9 root      20   0       0      0      0 S   0.0  0.0   0:00.68 rcu_sched                                                                                                </span><br><span class="line">   10 root      rt   0       0      0      0 S   0.0  0.0   0:24.56 migration&#x2F;0                                                                                              </span><br><span class="line">   11 root      rt   0       0      0      0 S   0.0  0.0   0:18.06 migration&#x2F;1                                                                                              </span><br><span class="line">   12 root      20   0       0      0      0 S   0.0  0.0   1:50.00 ksoftirqd&#x2F;1                                                                                              </span><br><span class="line">   15 root      rt   0       0      0      0 S   0.0  0.0   0:14.80 migration&#x2F;2                                                                                              </span><br><span class="line">   16 root      20   0       0      0      0 S   0.0  0.0   1:36.11 ksoftirqd&#x2F;2                                                                                              </span><br><span class="line">   19 root      rt   0       0      0      0 S   0.0  0.0   0:13.23 migration&#x2F;3                                                                                              </span><br><span class="line">   20 root      20   0       0      0      0 S   0.0  0.0   1:26.22 ksoftirqd&#x2F;3                                                                                              </span><br><span class="line">   22 root       0 -20       0      0      0 S   0.0  0.0   0:15.00 kworker&#x2F;3:0H                                                                                             </span><br><span class="line">   23 root      rt   0       0      0      0 S   0.0  0.0   0:04.04 migration&#x2F;4                                                                                              </span><br><span class="line">   24 root      20   0       0      0      0 S   0.0  0.0   0:03.91 ksoftirqd&#x2F;4                                                                                              </span><br><span class="line">   26 root       0 -20       0      0      0 S   0.0  0.0   0:00.15 kworker&#x2F;4:0H                                                                                             </span><br><span class="line">   27 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 khelper                                                                                                  </span><br><span class="line">   28 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 netns                                                                                                    </span><br><span class="line">   29 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 wakelock_printk                                                                                          </span><br><span class="line">   30 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 perf                                                                                                     </span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h1 id="考点4-etc目录下各个文件的作用"><a href="#考点4-etc目录下各个文件的作用" class="headerlink" title="考点4:/etc目录下各个文件的作用"></a>考点4:/etc目录下各个文件的作用</h1><p>下列文件中,包含了主机名到IP地址的映射关系的文件是: 。</p><ul><li>A <code>/etc/HOSTNAME</code></li><li>B <code>/etc/hosts</code></li><li>C <code>/etc/resolv.conf</code></li><li>D <code>/etc/networks</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="etc-目录下的文件的作用"><a href="#etc-目录下的文件的作用" class="headerlink" title="/etc/目录下的文件的作用"></a>/etc/目录下的文件的作用</h3><div class="table-container"><table><thead><tr><th style="text-align:left">/etc/文件</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>/etc/resolv.conf</code></td><td style="text-align:left">是<code>DNS</code>配置文件。在网卡配置文件中进行配置，默认情况下 网卡配置文件<code>DNS</code>优先于<code>/etc/resolv.conf</code>。</td></tr><tr><td style="text-align:left"><code>/etc/hostname</code></td><td style="text-align:left">在<code>Centos 7</code>，配置主机名，查看修改。</td></tr><tr><td style="text-align:left"><code>/etc/hosts</code></td><td style="text-align:left"><code>ip</code>与域名对应关系 ，解析域名（主机名），用<code>/etc/hosts</code>搭建网站的测试环境 (虚拟机)。不同服务器之间相互访问。</td></tr><tr><td style="text-align:left"><code>/etc/fstab</code></td><td style="text-align:left"><code>file system table</code> ：文件系统挂载表，开机的时候设备与入口对应关系 开机自动挂载列表。</td></tr><tr><td style="text-align:left"><code>/etc/rc.local</code></td><td style="text-align:left">开机自启</td></tr><tr><td style="text-align:left"><code>/etc/inittab</code>（<code>centos 6</code>）</td><td style="text-align:left">运行级别的配置文件</td></tr><tr><td style="text-align:left"><code>/etc/profile</code></td><td style="text-align:left">环境变量配置文件</td></tr><tr><td style="text-align:left"><code>/etc/bashrc</code></td><td style="text-align:left">命令别名</td></tr><tr><td style="text-align:left"><code>/etc/motd</code></td><td style="text-align:left">文件中的内容 会在用户登录系统之后显示出来</td></tr><tr><td style="text-align:left"><code>/etc/issue /etc/issue.net</code></td><td style="text-align:left">文件中的内容 会在用户登录系统之前显示出来</td></tr></tbody></table></div><h1 id="考点5-Linux系统调用"><a href="#考点5-Linux系统调用" class="headerlink" title="考点5:Linux系统调用"></a>考点5:Linux系统调用</h1><p>linux的系统调用是指</p><ul><li>A 由内核发起的调用</li><li>B <code>glibc</code>函数库里的函数</li><li>C 由系统管理员运行的程序</li><li>D 是用户进程调用内核功能的接口</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>系统调用是指内核提供的，功能十分强大的一系列函数。这些系统调用是在内核中实现的，再通过一定的方式把系统调用给用户，一般通过门（gate）陷入（trap）实现。系统调用是用户程序和内核交互的接口。</p><h3 id="5个系统调用"><a href="#5个系统调用" class="headerlink" title="5个系统调用"></a>5个系统调用</h3><ul><li>open,</li><li>write,</li><li>read,</li><li>close,</li><li>ioctl</li></ul><h1 id="考点6-top-free-proc-meminfo"><a href="#考点6-top-free-proc-meminfo" class="headerlink" title="考点6:top free /proc/meminfo"></a>考点6:top free /proc/meminfo</h1><p>如何查看当前Linux系统的状态,如CPU使用,内存使用,负载情况,下列描述正确的是？</p><ul><li>A 可以使用<code>top</code>命令分析<code>CPU</code>使用,内存使用,负载等情况</li><li>B 可以使用<code>free</code>查看内存整体的使用情况</li><li>C 可以使用<code>cat /proc/meminfo</code>查看内存更详细的情况</li><li>D 以上描述都不正确</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><h3 id="分析CPU使用-内存使用-负载情况-top"><a href="#分析CPU使用-内存使用-负载情况-top" class="headerlink" title="分析CPU使用 内存使用 负载情况 top"></a>分析CPU使用 内存使用 负载情况 top</h3><p>见上述的top</p><h3 id="查看内存整体使用情况-free-h"><a href="#查看内存整体使用情况-free-h" class="headerlink" title="查看内存整体使用情况 free -h"></a>查看内存整体使用情况 free -h</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           3.5G        1.4G        202M        2.8M        1.9G        2.1G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="查看内存详细信息-cat-proc-meminfo"><a href="#查看内存详细信息-cat-proc-meminfo" class="headerlink" title="查看内存详细信息 cat /proc/meminfo"></a>查看内存详细信息 cat /proc/meminfo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;proc&#x2F;meminfo</span><br><span class="line">MemTotal:        3686064 kB</span><br><span class="line">MemFree:          204972 kB</span><br><span class="line">Buffers:          117712 kB</span><br><span class="line">Cached:          1803660 kB</span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">Active:          1754532 kB</span><br><span class="line">Inactive:        1109552 kB</span><br><span class="line">Active(anon):     949128 kB</span><br><span class="line">Inactive(anon):     2440 kB</span><br><span class="line">Active(file):     805404 kB</span><br><span class="line">Inactive(file):  1107112 kB</span><br><span class="line">Unevictable:        5956 kB</span><br><span class="line">Mlocked:               0 kB</span><br><span class="line">SwapTotal:             0 kB</span><br><span class="line">SwapFree:              0 kB</span><br><span class="line">Dirty:                 0 kB</span><br><span class="line">Writeback:            84 kB</span><br><span class="line">AnonPages:        948680 kB</span><br><span class="line">Mapped:           467008 kB</span><br><span class="line">Shmem:              2820 kB</span><br><span class="line">Slab:             150864 kB</span><br><span class="line">SReclaimable:      64912 kB</span><br><span class="line">SUnreclaim:        85952 kB</span><br><span class="line">KernelStack:       38384 kB</span><br><span class="line">PageTables:        35820 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:     1843032 kB</span><br><span class="line">Committed_AS:   86691356 kB</span><br><span class="line">VmallocTotal:   251658176 kB</span><br><span class="line">VmallocUsed:      189540 kB</span><br><span class="line">VmallocChunk:   251341732 kB</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h1 id="考点7-哪些是子进程从父进程继承得到的"><a href="#考点7-哪些是子进程从父进程继承得到的" class="headerlink" title="考点7:哪些是子进程从父进程继承得到的"></a>考点7:哪些是子进程从父进程继承得到的</h1><p>在Linux上,对于多进程,子进程继承了父进程的下列哪些？</p><ul><li>A 进程地址空间</li><li>B 共享内存</li><li>C 信号掩码</li><li>D 已打开的文件描述符</li><li>E 以上都不是</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>参考：</p><ul><li><a href="http://blog.csdn.net/xiaojun111111/article/details/51764389" target="_blank" rel="noopener">http://blog.csdn.net/xiaojun111111/article/details/51764389</a></li><li><a href="http://blog.csdn.net/ygm_linux/article/details/50683877" target="_blank" rel="noopener">http://blog.csdn.net/ygm_linux/article/details/50683877</a></li></ul><h3 id="子进程继承父进程"><a href="#子进程继承父进程" class="headerlink" title="子进程继承父进程"></a>子进程继承父进程</h3><ul><li>用户号UIDs和用户组号GIDs；</li><li>环境Environment；</li><li>堆栈；</li><li>共享内存；</li><li>打开文件的描述符；</li><li>执行时关闭（Close-on-exec）标志；</li><li>信号（Signal）控制设定；</li><li>进程组号；</li><li>当前工作目录；</li><li>根目录；</li><li>文件方式创建屏蔽字；</li><li>资源限制；</li><li>控制终端；</li></ul><h3 id="子进程独有"><a href="#子进程独有" class="headerlink" title="子进程独有"></a>子进程独有</h3><ul><li>进程号PID；</li><li>不同的父进程号；</li><li>自己的文件描述符和目录流的拷贝；</li><li>子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）；</li><li>不继承异步输入和输出；</li></ul><p>父进程和子进程拥有独立的地址空间和PID参数。</p><p>子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。<br>经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”</p><h1 id="考点8-Linux主机负载相关命令"><a href="#考点8-Linux主机负载相关命令" class="headerlink" title="考点8:Linux主机负载相关命令"></a>考点8:Linux主机负载相关命令</h1><p>以下哪些命令可以获取linux主机的负载相关指标</p><ul><li>A <code>uptime</code></li><li>B <code>top</code></li><li>C <code>ls</code></li><li>D <code>sar</code></li><li>E <code>crontab</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">uptime命令</td><td style="text-align:left">能够打印系统总共运行了多长时间和系统的平均负载。可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。</td></tr><tr><td style="text-align:left">top命令</td><td style="text-align:left">是用来监控 Linux 系统状况，比如cpu、内存的使用。</td></tr><tr><td style="text-align:left">ls命令</td><td style="text-align:left">用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</td></tr><tr><td style="text-align:left">sar命令</td><td style="text-align:left">（System ActivityReporter系统活动情况报告）是目前Linux上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等。</td></tr><tr><td style="text-align:left">crontab</td><td style="text-align:left">是用来定期执行程序的命令。crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 15:23:59 up 1 day,  8:21,  1 user,  load average: 5.45, 5.51, 5.51</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h1 id="考点9-Linux交换分区"><a href="#考点9-Linux交换分区" class="headerlink" title="考点9:Linux交换分区"></a>考点9:Linux交换分区</h1><p>关于Linux交换分区的说法正确是(      )</p><ul><li>A 安装<code>Linux</code>系统时必须划分交换分区</li><li>B 交换分区的作用是虚拟内存空间</li><li>C 交换分区的数据存取速度比物理内存慢</li><li>D 计算机内存为8<code>GB</code>,则交换分区的大小通常设置为16<code>GB</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>交换分区一般设置内存的2倍</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年03月22日Linux专项练习1</title>
      <link href="/exam//551d2e1a/"/>
      <url>/exam//551d2e1a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/551d2e1a/#考点1-cat-n" class="header_1">考点1:cat -n</a>&nbsp;<br><a href="/exam/551d2e1a/#考点2-自由软件的定义" class="header_1">考点2:自由软件的定义</a>&nbsp;<br><a href="/exam/551d2e1a/#考点3-多路复用IO监听-套接字描述符-select方法的第一个参数maxfd的取值" class="header_1">考点3:多路复用IO监听 套接字描述符 select方法的第一个参数maxfd的取值</a>&nbsp;<br><a href="/exam/551d2e1a/#考点4-文件权限" class="header_1">考点4:文件权限</a>&nbsp;<br><a href="/exam/551d2e1a/#考点5-显示当前目录的命令" class="header_1">考点5:显示当前目录的命令</a>&nbsp;<br><a href="/exam/551d2e1a/#考点6-bash环境的用户文件" class="header_1">考点6:bash环境的用户文件</a>&nbsp;<br><a href="/exam/551d2e1a/#考点7-死锁的必要条件" class="header_1">考点7:死锁的必要条件</a>&nbsp;<br><a href="/exam/551d2e1a/#考点8-查看Linux系统状态的命令" class="header_1">考点8:查看Linux系统状态的命令</a>&nbsp;<br><a href="/exam/551d2e1a/#考点9-DHCP-获取服务器分配的IP地址的命令" class="header_1">考点9:DHCP 获取服务器分配的IP地址的命令</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-cat-n"><a href="#考点1-cat-n" class="headerlink" title="考点1:cat -n"></a>考点1:cat -n</h1><p><code>cat -n file1 file2</code>命令的意思是？</p><ul><li>A 只会把文件<code>file1</code>的内容输出到屏幕上。</li><li>B 把文件<code>file1</code>和<code>file2</code>连在一起,然后输出到屏幕上。</li><li>C 创建文件<code>file1</code>和<code>file2</code></li><li>D 把<code>file2</code>的内容输出到<code>file1</code>中并保存</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>参数-n 或 —number 表示显示行号，行号从1开始</p><p>上述命令即将file1和file2的文件内容连在一起然后输出到屏幕，并打印行号，file1和file2文件内容不变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat --help</span><br><span class="line">用法：cat [选项]... [文件]...</span><br><span class="line">将[文件]或标准输入组合输出到标准输出。</span><br><span class="line"></span><br><span class="line">  -A, --show-all           等于-vET</span><br><span class="line">  -b, --number-nonblank    对非空输出行编号</span><br><span class="line">  -e                       等于-vE</span><br><span class="line">  -E, --show-ends          在每行结束处显示&quot;$&quot;</span><br><span class="line">  -n, --number             对输出的所有行编号</span><br><span class="line">  -s, --squeeze-blank      不输出多行空行</span><br><span class="line">  -t                       与-vT 等价</span><br><span class="line">  -T, --show-tabs          将跳格字符显示为^I</span><br><span class="line">  -u                       (被忽略)</span><br><span class="line">  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外</span><br><span class="line">      --help        显示此帮助信息并退出</span><br><span class="line">      --version        显示版本信息并退出</span><br><span class="line"></span><br><span class="line">如果没有指定文件，或者文件为&quot;-&quot;，则从标准输入读取。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">  cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。</span><br><span class="line">  cat        将标准输入的内容复制到标准输出。</span><br><span class="line"></span><br><span class="line">GNU coreutils online help: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;coreutils&#x2F;&gt;</span><br><span class="line">请向&lt;http:&#x2F;&#x2F;translationproject.org&#x2F;team&#x2F;zh_CN.html&gt; 报告cat 的翻译错误</span><br><span class="line">要获取完整文档，请运行：info coreutils &#39;cat invocation&#39;</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure></p><h1 id="考点2-自由软件的定义"><a href="#考点2-自由软件的定义" class="headerlink" title="考点2:自由软件的定义"></a>考点2:自由软件的定义</h1><p>说 Linux 是一种”自由软件”的主要理由是 <strong><strong><em>__</em></strong></strong> 。</p><ul><li>A <code>Linux</code>的源代码是公开的</li><li>B <code>Linux</code>是多用户、多任务的操作系统</li><li>C <code>Linux</code>具有可移植性</li><li>D <code>Linux</code>属于<code>GPL</code>软件</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点3-多路复用IO监听-套接字描述符-select方法的第一个参数maxfd的取值"><a href="#考点3-多路复用IO监听-套接字描述符-select方法的第一个参数maxfd的取值" class="headerlink" title="考点3:多路复用IO监听 套接字描述符 select方法的第一个参数maxfd的取值"></a>考点3:多路复用IO监听 套接字描述符 select方法的第一个参数maxfd的取值</h1><p>采用多路复用I/O监听3个套接字的数据时,如果套接字描述符分别是:5,17,19,则<br>select(int maxfd,struct fd_set* rdset,NULL,NULL)<br>中的maxfd应取为()</p><ul><li>A 4</li><li>B 20</li><li>C 5</li><li>D 9</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>Maxfd表示要监视的文件描述符的范围，一般取监视的描述符数的最大值+1</p><h1 id="考点4-文件权限"><a href="#考点4-文件权限" class="headerlink" title="考点4:文件权限"></a>考点4:文件权限</h1><p>某文件的组外成员的权限为只读;所有者有全部权限;组内的权限为读与写,则该文件的权限为<strong> <em> </em></strong> 。</p><ul><li>A ４６７</li><li>B ６７４</li><li>C ４７６</li><li>D ７６４</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="文件权限ugo"><a href="#文件权限ugo" class="headerlink" title="文件权限ugo"></a>文件权限ugo</h3><p>u-g-o：用户-组内用户-其他用户</p><p>r-w-x：用4-2-1表示。</p><p>所有者u有全部权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwx &#x3D; 7</span><br></pre></td></tr></table></figure><br>组内g的权限为读与写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rw- &#x3D; 6</span><br></pre></td></tr></table></figure><br>组外成员o的权限为只读：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r-- = 4</span><br></pre></td></tr></table></figure></p><p>如：<code>-r-xr-x--x为551</code>。<br>最前面的-表示文件类型，</p><ul><li>如果是文件用-表示，</li><li>如果是文件夹用d表示，</li><li>如果是链接文件用l表示。</li></ul><h1 id="考点5-显示当前目录的命令"><a href="#考点5-显示当前目录的命令" class="headerlink" title="考点5:显示当前目录的命令"></a>考点5:显示当前目录的命令</h1><p>用什么命令来显示当前目录？</p><ul><li>A <code>echo $(pwd)</code></li><li>B <code>echo pwd</code></li><li>C <code>$pwd</code></li><li>D <code>pwd | echo</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>考对于命令替换、echo、环境变量、管道的理解。</p><p>A. 将命令替换<code>$()</code>内的的<code>pwd</code>命令执行后，输出结果给到<code>echo</code>，再由<code>echo</code>输出。等效于直接执行命令<code>pwd</code>。<br>B. echo后面的普通字符会被直接默认当做字符串输出。<br>C. 一般来说系统里是不存在<code>$pwd</code>这个环境变量的，而有<code>$PWD</code>、<code>$OLDPWD</code>，这俩环境变量分别是用来打印当前、上一次工作目录的。一般在shell脚本编写里也会使用环境变量<code>$PWD</code>来代替命令<code>$(pwd)</code>获取当前工作目录。<br>D. 由于存在管道符，所以<code>pwd</code>命令的输出传递给了管道后的输入，但<code>echo</code>无法接收该输入，所以就相当于把<code>pwd</code>的结果丢弃了，然后执行<code>echo</code>，就输出为空了。如果想要把通过管道后的输入作为参数传递给<code>echo</code>，则需要加上<code>xargs</code>。像这样<code>pwd | xargs echo</code></p><h1 id="考点6-bash环境的用户文件"><a href="#考点6-bash环境的用户文件" class="headerlink" title="考点6:bash环境的用户文件"></a>考点6:bash环境的用户文件</h1><p>定义bash环境的用户文件是？</p><ul><li>A bash &amp;.bashrc</li><li>B bash &amp; bash_profile</li><li>C bashrc &amp;.bash_profile</li><li>D bashrc &amp;.bash_conf</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">文件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>~/.bash_profile</code></td><td style="text-align:left">每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.此文件类似于/etc/profile，也是需要需要重启才会生效，/etc/profile对所有用户生效，~/.bash_profile只对当前用户生效。</td></tr><tr><td style="text-align:left"><code>~/.bashrc</code></td><td style="text-align:left">该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取.（每个用户都有一个.bashrc文件，在用户目录下）此文件类似于/etc/bashrc，不需要重启生效，重新打开一个bash即可生效， /etc/bashrc对所有用户新打开的bash都生效，但~/.bashrc只对当前用户新打开的bash生效。</td></tr></tbody></table></div><h1 id="考点7-死锁的必要条件"><a href="#考点7-死锁的必要条件" class="headerlink" title="考点7:死锁的必要条件"></a>考点7:死锁的必要条件</h1><p>下面哪些是死锁的必要条件？</p><ul><li>A 互斥</li><li>B 请求保持</li><li>C 不可剥夺</li><li>D 环路</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件：进程已获得的资源，在使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p><h1 id="考点8-查看Linux系统状态的命令"><a href="#考点8-查看Linux系统状态的命令" class="headerlink" title="考点8:查看Linux系统状态的命令"></a>考点8:查看Linux系统状态的命令</h1><p>如何查看当前Linux系统的状态,如CPU使用,内存使用,负载情况,下列描述正确的是？</p><ul><li>A 可以使用<code>top</code>命令分析<code>CPU</code>使用,内存使用,负载等情况</li><li>B 可以使用<code>free</code>查看内存整体的使用情况</li><li>C 可以使用<code>cat /proc/meminfo</code>查看内存更详细的情况</li><li>D 以上描述都不正确</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>top命令：<br>Linux下常用的性能分析工具。能够实时显示系统中各个进程对资源的占用状况。<br>free命令：<br>可以显示Linux系统中空闲的、已用的物理内存及swap内存，及被内核使用的buffer。<br>df命令：<br>用于显示当前在Linux系统上的文件系统的磁盘使用情况的统计信息。</p><h1 id="考点9-DHCP-获取服务器分配的IP地址的命令"><a href="#考点9-DHCP-获取服务器分配的IP地址的命令" class="headerlink" title="考点9:DHCP 获取服务器分配的IP地址的命令"></a>考点9:DHCP 获取服务器分配的IP地址的命令</h1><p>Linux系统中,已经将DHCP服务器架设好,客户端的网络接口eth0,可以通过( )命令获得服务器分配的IP地址。多选</p><ul><li>A <code>dhclient</code></li><li>B <code>ifdown eth0;ifup eth0</code></li><li>C <code>ifconfig</code></li><li>D <code>service network stop;service network start</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2021年03月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月24日 java1</title>
      <link href="/exam//ba60b2f6/"/>
      <url>/exam//ba60b2f6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/ba60b2f6/#考点1-java数组声明" class="header_1">考点1 java数组声明</a>&nbsp;<br><a href="/exam/ba60b2f6/#考点2-java类加载器" class="header_1">考点2 java类加载器</a>&nbsp;<br><a href="/exam/ba60b2f6/#考点3-java抽象类方法默认访问权限" class="header_1">考点3 java抽象类方法默认访问权限</a>&nbsp;<br><a href="/exam/ba60b2f6/#考点4-排序算法复杂度" class="header_1">考点4 排序算法复杂度</a>&nbsp;<br><a href="/exam/ba60b2f6/#考点5-类的修饰符" class="header_1">考点5 类的修饰符</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-java数组声明"><a href="#考点1-java数组声明" class="headerlink" title="考点1 java数组声明"></a>考点1 java数组声明</h1><p>以下二维数组声明合法的是( )</p><ul><li>A <code>char[2][3] ch = new char[][]</code></li><li>B <code>char[2][] ch = new char[][3]</code></li><li>C <code>char[][] ch = new char[2][3]</code></li><li>D <code>char[][] ch = new [2]char[3]</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>定义数组，等号左边不能出现数字，也就是数组的不管什么大小   不能出现在左边</p><h1 id="考点2-java类加载器"><a href="#考点2-java类加载器" class="headerlink" title="考点2 java类加载器"></a>考点2 java类加载器</h1><p>下面有关java classloader说法错误的是?</p><ul><li>A <code>Java</code>默认提供的三个<code>ClassLoader</code>是<code>BootStrap ClassLoader,Extension ClassLoader,App ClassLoader</code></li><li>B <code>ClassLoader</code>使用的是双亲委托模型来搜索类的</li><li>C <code>JVM</code>在判定两个<code>class</code>是否相同时,只用判断类名相同即可,和类加载器无关</li><li>D <code>ClassLoader</code>就是用来动态加载<code>class</code>文件到内存当中用的</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点3-java抽象类方法默认访问权限"><a href="#考点3-java抽象类方法默认访问权限" class="headerlink" title="考点3 java抽象类方法默认访问权限"></a>考点3 java抽象类方法默认访问权限</h1><p>抽象类方法的访问权限默认都是public。(  )</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>JDK 1.8以前，抽象类的方法默认访问权限为protected<br>JDK 1.8时，抽象类的方法默认访问权限变为default<br>JDK 1.8以前，接口中的方法必须是public的<br>JDK 1.8时，接口中的方法可以是public的，也可以是default的<br>JDK 1.9时，接口中的方法可以是private的</p><h1 id="考点4-排序算法复杂度"><a href="#考点4-排序算法复杂度" class="headerlink" title="考点4 排序算法复杂度"></a>考点4 排序算法复杂度</h1><p>在各自最优条件下,对N个数进行排序,哪个算法复杂度最低的是? ()</p><ul><li>A 插入排序</li><li>B 快速排序</li><li>C 堆排序</li><li>D 归并排序</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>插入排序：最佳O（N）<br>快速排序：最佳O（NlogN）<br>堆    排序：最佳O（NlogN）<br>归并排序：最佳O（NlogN）<br>因此选择插入排序。<br><img src="https://uploadfiles.nowcoder.com/images/20190727/5227440_1564208997208_C0C78CE31C2575E39A0EE7AE31E20FB8" alt="排序算法复杂度"></p><h1 id="考点5-类的修饰符"><a href="#考点5-类的修饰符" class="headerlink" title="考点5 类的修饰符"></a>考点5 类的修饰符</h1><p>若需要定义一个类,下列哪些修饰符是允许被使用的？( )</p><ul><li>A <code>static</code></li><li>B <code>package</code></li><li>C <code>private</code></li><li>D <code>public</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><p>普通类(外部类):只能用<code>public</code>、<code>default</code>(不写)、<code>abstract</code>、<code>final</code>修饰。<br>(成员)内部类:可理解为外部类的成员,所以修饰类成员的<code>public</code>、<code>protected</code>、<code>default</code>、<code>private</code>、<code>static</code>等关键字都能使用。<br>局部内部类:出现在方法里的类,不能用上述关键词来修饰。<br>匿名内部类:给的是直接实现,类名都没有,没有修饰符。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月25日 java1</title>
      <link href="/exam//55a2d9c8/"/>
      <url>/exam//55a2d9c8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/55a2d9c8/#考点1-表达式运算" class="header_1">考点1 表达式运算</a>&nbsp;<br><a href="/exam/55a2d9c8/#考点2-java集合List常用方法" class="header_1">考点2 java集合List常用方法</a>&nbsp;<br><a href="/exam/55a2d9c8/#考点3-java位运算-按位与" class="header_1">考点3 java位运算 按位与</a>&nbsp;<br><a href="/exam/55a2d9c8/#考点4-计算机网络-远程方法调用" class="header_1">考点4 计算机网络 远程方法调用</a>&nbsp;<br><a href="/exam/55a2d9c8/#考点5-java垃圾收集器的区别" class="header_1">考点5 java垃圾收集器的区别</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-表达式运算"><a href="#考点1-表达式运算" class="headerlink" title="考点1 表达式运算"></a>考点1 表达式运算</h1><p>如果定义一种表达式结构:(+ 6 3)的值为9,(- 6 3)的值为3,(<em> 6 3)的值为18,(/ 6 3)的值为2;那么对于表达式(</em> (- 16 (* 3 2 2 )) (+ 5 (/ 6 (- 5 3))))输出的结果为<em>__</em>。</p><ul><li>A 44</li><li>B 40</li><li>C 40</li><li>D 32</li><li>E 24</li><li>F 21</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点2-java集合List常用方法"><a href="#考点2-java集合List常用方法" class="headerlink" title="考点2 java集合List常用方法"></a>考点2 java集合List常用方法</h1><p>如果一个list初始化为{5,3,1},执行以下代码后,其结果为()？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p><ul><li>A [5, 3, 1, 6]</li><li>B [4, 3, 1, 6]</li><li>C [4, 3, 6]</li><li>D [5, 3, 6]</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>boolean add(E e)</code></td><td style="text-align:left">将指定的元素追加到此列表的<strong>末尾</strong>(可选操作)。</td></tr><tr><td style="text-align:left"><code>void add(int index, E element)</code></td><td style="text-align:left">将指定的元素插入此列表中的index指定位置(可选操作)。</td></tr><tr><td style="text-align:left"><code>E remove(int index)</code></td><td style="text-align:left">删除该列表中指定位置的元素(可选操作)。</td></tr></tbody></table></div><h1 id="考点3-java位运算-按位与"><a href="#考点3-java位运算-按位与" class="headerlink" title="考点3 java位运算 按位与"></a>考点3 java位运算 按位与</h1><p>Java表达式”13 &amp; 17”的结果是什么?()</p><ul><li>A 30</li><li>B 13</li><li>C 17</li><li>D 1</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>&amp;运算符：两个数都转为二进制，然后从两个数的最高位进行与运算，两个都为真（1），结果才为真（1），否则为假（0）</p><div class="table-container"><table><thead><tr><th style="text-align:left">十进制</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">13</td><td style="text-align:left">01101</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left">10001</td></tr><tr><td style="text-align:left">按位与结果:1</td><td style="text-align:left">00001</td></tr></tbody></table></div><h1 id="考点4-计算机网络-远程方法调用"><a href="#考点4-计算机网络-远程方法调用" class="headerlink" title="考点4 计算机网络 远程方法调用"></a>考点4 计算机网络 远程方法调用</h1><p>默认RMI采用的是什么通信协议？</p><ul><li>A <code>HTTP</code></li><li>B <code>UDP/IP</code></li><li>C <code>TCP/IP</code></li><li>D <code>Multicast</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p><code>RMI(Remote MethodInvocation)</code>远程方法调用是一种计算机之间利用远程对象互相调用实现双方通讯的一种通讯机制。使用这种机制，某一台计算机上的对象可以调用另外一台计算机上的对象来获取远程数据。<code>RMI</code>是<code>EnterpriseJavaBeans</code>的支柱，是建立分布式<code>Java</code>应用程序的方便途径。在过去，<code>TCP/IP</code>套接字通讯是远程通讯的主要手段，但此开发方式没有使用面向对象的方式实现开发，在开发一个如此的通讯机制时往往令程序员感觉到乏味，对此<code>RPC(RemoteProcedureCall</code>）应运而生，它使程序员更容易地调用远程程序，但在面对复杂的信息传讯时，<code>RPC</code>依然未能很好的支持，而且<code>RPC</code>未能做到面向对象调用的开发模式。针对<code>RPC</code>服务遗留的问题，<code>RMI</code>出现在世人面前，它被设计成一种面向对象的通讯方式，允许程序员使用远程对象来实现通信，并且支持多线程的服务，这是一次远程通讯的<em>*</em>，为远程通信开辟新的里程碑。<code>RMI</code>的开发步骤先创建远程接口及声明远程方法，注意这是实现双方通讯的接口，需要继承<code>Remote</code>开发一个类来实现远程接口及远程方法，值得注意的是实现类需要继承<code>UnicastRemoteObject</code>通过<code>javac</code>命令编译文件，通过<code>java -server</code> 命令注册服务，启动远程对象最后客户端查找远程对象，并调用远程方法所以选C</p><h1 id="考点5-java垃圾收集器的区别"><a href="#考点5-java垃圾收集器的区别" class="headerlink" title="考点5 java垃圾收集器的区别"></a>考点5 java垃圾收集器的区别</h1><p>下列哪项不属于jdk1.6垃圾收集器？</p><ul><li>A <code>Serial</code>收集器</li><li>B <code>parNew</code>收集器</li><li>C <code>CMS</code>收集器</li><li>D <code>G1</code>收集器</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p><img src="https://uploadfiles.nowcoder.com/images/20170223/6741161_1487851243302_B9F7B4500368A60BFE23DC6CC3C3F153" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月23日 java1</title>
      <link href="/exam//58bca98f/"/>
      <url>/exam//58bca98f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/58bca98f/#考点1-java集合旧类和新类的区别" class="header_1">考点1 java集合旧类和新类的区别</a>&nbsp;<br><a href="/exam/58bca98f/#考点2-java包装类-数据转换" class="header_1">考点2 java包装类 数据转换</a>&nbsp;<br><a href="/exam/58bca98f/#考点4-java短路逻辑运算符" class="header_1">考点4 java短路逻辑运算符</a>&nbsp;<br><a href="/exam/58bca98f/#考点5-javaEE-JSP生命周期" class="header_1">考点5 javaEE JSP生命周期</a>&nbsp;<br><a href="/exam/58bca98f/#考点6-常用的final类" class="header_1">考点6 常用的final类</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-java集合旧类和新类的区别"><a href="#考点1-java集合旧类和新类的区别" class="headerlink" title="考点1 java集合旧类和新类的区别"></a>考点1 java集合旧类和新类的区别</h1><p>ArrayList和Vector主要区别是什么？</p><ul><li>A <code>Vector</code>与<code>ArrayList</code>一样,也是通过数组实现的,不同的是<code>Vector</code>支持线程的同步</li><li>B <code>Vector</code>与<code>ArrayList</code>一样,也是通过数组实现的,不同的是<code>ArrayList</code>支持线程的同步</li><li>C <code>Vector</code>是通过链表结构存储数据,<code>ArrayList</code>是通过数组存储数据</li><li>D 上述说法都不正确</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="Vector与ArrayList的主要区别"><a href="#Vector与ArrayList的主要区别" class="headerlink" title="Vector与ArrayList的主要区别"></a>Vector与ArrayList的主要区别</h3><ul><li>同步性:<ul><li>Vector是线程安全的，也就是说是同步的而</li><li>ArrayList是线程序不安全的，不是同步的。</li></ul></li><li><p>数据增长:当需要增长时,</p><ul><li>Vector默认增长为原来<strong>一倍</strong>。</li><li>而ArrayList却是原来的<strong>50%</strong>,这样,ArrayList就有利于节约内存空间。</li></ul></li><li><p>如果涉及到堆栈，队列等操作，应该考虑用Vector，</p></li><li>如果需要快速随机访问元素，应该使用ArrayList 。</li></ul><h3 id="Hashtable与HashMap"><a href="#Hashtable与HashMap" class="headerlink" title="Hashtable与HashMap"></a>Hashtable与HashMap</h3><p>Hashtable和HashMap它们的性能方面的比较类似<br>Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。</p><h3 id="ArrayList与LinkedList"><a href="#ArrayList与LinkedList" class="headerlink" title="ArrayList与LinkedList"></a>ArrayList与LinkedList</h3><p>ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，<br>但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：<br>在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,<br>需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；<br>而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。</p><h1 id="考点2-java包装类-数据转换"><a href="#考点2-java包装类-数据转换" class="headerlink" title="考点2 java包装类 数据转换"></a>考点2 java包装类 数据转换</h1><p>关于Float,下列说法错误的是()</p><ul><li>A <code>Float</code>是一个类</li><li>B <code>Float</code>在<code>java.lang</code>包中</li><li>C <code>Float a=1.0</code>是正确的赋值方法</li><li>D <code>Float a= new Float(1.0)</code>是正确的赋值方法</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>Float是类，float不是类.</li><li>查看JDK源码就可以发现Byte，Character，Short，Integer，Long，Float，Double，Boolean都在java.lang包中.</li><li>Float正确复制方式是Float f=1.0f,若不加f会被识别成double型,double无法向float隐式转换.</li><li>Float a= new Float(1.0)是正确的赋值方法，但是在1.5及以上版本引入自动装箱拆箱后，会提示这是不必要的装箱的警告，通常直接使用Float f=1.0f.</li></ul><h1 id="考点4-java短路逻辑运算符"><a href="#考点4-java短路逻辑运算符" class="headerlink" title="考点4 java短路逻辑运算符"></a>考点4 java短路逻辑运算符</h1><p>根据下面的代码,<br>String s = null;<br>会抛出NullPointerException异常的有()。</p><ul><li>A if( (s!=null) &amp; (s.length()&gt;0) )</li><li>B if( (s!=null) &amp;&amp; (s.length()&gt;0) )</li><li>C if( (s==null) | (s.length()==0) )</li><li>D if( (s==null) || (s.length()==0) )</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><ul><li>逻辑运算符：&amp;&amp;和|| 是按照“短路”方式求值的。如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了</li><li>位移运算符：&amp;和| 运算符应用于布尔值，得到的结果也是布尔值，不按“短路”方式计算。即在得到计算结果之前，一定要计算两个操作数的值。</li></ul><h1 id="考点5-javaEE-JSP生命周期"><a href="#考点5-javaEE-JSP生命周期" class="headerlink" title="考点5 javaEE JSP生命周期"></a>考点5 javaEE JSP生命周期</h1><p>关于JSP生命周期的叙述,下列哪些为真?</p><ul><li>A <code>JSP</code>会先解释成<code>Servlet</code>源文件,然后编译成<code>Servlet</code>类文件</li><li>B 每当用户端运行<code>JSP</code>时,<code>jsp init()</code>方法都会运行一次</li><li>C 每当用户端运行<code>JSP</code>时,<code>jsp service()</code>方法都会运行一次</li><li>D 每当用户端运行<code>JSP</code>时,<code>jsp destroy()</code>方法都会运行一次</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>B:init方法:负责初始化Servlet对象。在Servlet的整个生命周期类,init()方法只被调用一次。<br>D:destroy方法:销毁Servlet对象,释放占用的资源,Servlet要被卸载时调用</p><h1 id="考点6-常用的final类"><a href="#考点6-常用的final类" class="headerlink" title="考点6 常用的final类"></a>考点6 常用的final类</h1><p>以下类型为Final类型的为()</p><ul><li>A <code>HashMap</code></li><li>B <code>StringBuffer</code></li><li>C <code>String</code></li><li>D <code>Hashtable</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>StringBuilder , StringBuffer ,String 都是 final 的</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月30日 java1</title>
      <link href="/exam//7205cd4c/"/>
      <url>/exam//7205cd4c/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/7205cd4c/#考点1-JSP内置session对象" class="header_1">考点1 JSP内置session对象</a>&nbsp;<br><a href="/exam/7205cd4c/#考点2-表达式运算" class="header_1">考点2 表达式运算</a>&nbsp;<br><a href="/exam/7205cd4c/#考点3-短路或" class="header_1">考点3 短路或</a>&nbsp;<br><a href="/exam/7205cd4c/#考点4" class="header_1">考点4 </a>&nbsp;<br><a href="/exam/7205cd4c/#考点5-线程安全的操作" class="header_1">考点5 线程安全的操作</a>&nbsp;<br><a href="/exam/7205cd4c/#考点6-逻辑运算符短路或" class="header_1">考点6 逻辑运算符短路或</a>&nbsp;<br><a href="/exam/7205cd4c/#考点7" class="header_1">考点7 </a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-JSP内置session对象"><a href="#考点1-JSP内置session对象" class="headerlink" title="考点1 JSP内置session对象"></a>考点1 JSP内置session对象</h1><p>要在session对象中保存属性,可以使用以下哪个语句(      )</p><ul><li>A <code>session.getAttribute(&quot;key&quot;,&quot;value&quot;)</code></li><li>B <code>session.setAttribute(&quot;key&quot;,&quot;value&quot;)</code></li><li>C <code>session.setAttribute(&quot;key&quot;)</code></li><li>D <code>session.getAttribute(&quot;key&quot;)</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>session.setAttribute()和session.getAttribute()配对使用，作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。<br>设置<br>session.getAttribute(“key”,”value”)<br>获取<br>session.getAttribute(“key”)<br>移除<br>session.removeAttribute(“key”)</p><p>request.getAttribute()表示从request范围取得设置的属性，必须要先setAttribute设置属性，才能通过getAttribute来取得，设置与取得的为Object对象类型。其实表单控件中的Object的 name与value是存放在一个哈希表中的，所以在这里给出Object的name会到哈希表中找出对应它的value。setAttribute()的参数是String和Object。</p><h1 id="考点2-表达式运算"><a href="#考点2-表达式运算" class="headerlink" title="考点2 表达式运算"></a>考点2 表达式运算</h1><p>如果定义一种表达式结构:(+ 6 3)的值为9,(- 6 3)的值为3,(<em> 6 3)的值为18,(/ 6 3)的值为2;那么对于表达式(</em> (- 16 (* 3 2 2 )) (+ 5 (/ 6 (- 5 3))))输出的结果为<em>__</em>。</p><ul><li>A 44</li><li>B 40</li><li>C 40</li><li>D 32</li><li>E 24</li><li>F 21</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>从括号最多的地方开始算</p><h1 id="考点3-短路或"><a href="#考点3-短路或" class="headerlink" title="考点3 短路或"></a>考点3 短路或</h1><p>如下语句通过算术运算和逻辑运算之后i和 j的结果是( )<br>int i=0;<br>int j=0;<br>if((++i&gt;0)||(++j&gt;0))<br>{<br>//打印出i和j的值。<br>}</p><ul><li>A i=0;j=0</li><li>B i=1;j=1</li><li>C i=0;j=1</li><li>D i=1;j=0</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在运行时,由java解释器自动引入,而不用import语句引入的包是()。</p><ul><li>A <code>java.lang</code></li><li>B <code>java.system</code></li><li>C <code>java.io</code></li><li>D <code>java.util</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>java.lang包是java语言的核心包，lang是language的缩写<br>java.lang包定义了一些基本的类型，包括Integer,String之类的，是java程序必备的包，有解释器自动引入，无需手动导入</p><h1 id="考点5-线程安全的操作"><a href="#考点5-线程安全的操作" class="headerlink" title="考点5 线程安全的操作"></a>考点5 线程安全的操作</h1><p>以下多线程对int型变量x的操作,哪个不需要进行同步()</p><ul><li>A ++x</li><li>B x=y</li><li>C x++</li><li>D x=1</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>原子操作:只进行一次的操作。</p><p>前三个都至少需要<strong>先读取</strong>，<strong>再操作</strong>，是非原子操作<br>x++,需要先读取x的值，然后加一，然后再写入x<br>++x,同理<br>x=y，需要先读取y的值，然后写入x<br>D选项:<br>x=1,1是直接量，不许需要读取，直接写入即可<br>直接赋值只需要一次写入操作即可完成</p><h1 id="考点6-逻辑运算符短路或"><a href="#考点6-逻辑运算符短路或" class="headerlink" title="考点6 逻辑运算符短路或"></a>考点6 逻辑运算符短路或</h1><p>Given the following code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">methodB</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        j += k;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b;</span><br><span class="line">        b = i &lt; <span class="number">10</span> | methodB(<span class="number">4</span>);</span><br><span class="line">        b = i &lt; <span class="number">10</span> || methodB(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        methodA(<span class="number">0</span>);</span><br><span class="line">        System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>What is the result?</p><ul><li>A The program prints”0”</li><li>B The program prints”4”</li><li>C The program prints”8”</li><li>D The program prints”12”</li><li>E The code does not complete.</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于对象成员占用内存的说法哪个正确？( )</p><ul><li>A 同一个类的对象共用同一段内存</li><li>B 同一个类的对象使用不同的内存段,但静态成员共享相同的内存空间</li><li>C 对象的方法不占用内存</li><li>D 以上都不对</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><img src="https://uploadfiles.nowcoder.com/images/20170928/6947119_1506597426551_C616C50E6EC7C120A5C060F65822D6FA" alt="java成员内存"></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在校生如何面向面试地学习Java</title>
      <link href="/exam//46ec7757/"/>
      <url>/exam//46ec7757/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/46ec7757/#在校生的困境" class="header_1">在校生的困境</a>&nbsp;<br><a href="/exam/46ec7757/#建议" class="header_1">建议</a>&nbsp;<br><a href="/exam/46ec7757/#1-明确目标，先说下公司面试应届生的标准" class="header_2">1. 明确目标，先说下公司面试应届生的标准</a>&nbsp;<br><a href="/exam/46ec7757/#2-面试中大多数应届生的实际表现" class="header_2">2. 面试中大多数应届生的实际表现</a>&nbsp;<br><a href="/exam/46ec7757/#达不到标准的具体表现" class="header_3">达不到标准的具体表现</a>&nbsp;<br><a href="/exam/46ec7757/#3-哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）" class="header_2">3. 哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）</a>&nbsp;<br><a href="/exam/46ec7757/#面试时需要掌握的最低技能标准" class="header_3">面试时需要掌握的最低技能标准</a>&nbsp;<br><a href="/exam/46ec7757/#-Java-核心常问" class="header_4">`Java`核心常问:</a>&nbsp;<br><a href="/exam/46ec7757/#java核心不常问" class="header_4">java核心不常问</a>&nbsp;<br><a href="/exam/46ec7757/#数据库方面" class="header_4">数据库方面</a>&nbsp;<br><a href="/exam/46ec7757/#框架方面" class="header_4">框架方面</a>&nbsp;<br><a href="/exam/46ec7757/#综合技能方面" class="header_4">综合技能方面</a>&nbsp;<br><a href="/exam/46ec7757/#看招聘要求查缺补漏" class="header_2">看招聘要求查缺补漏</a>&nbsp;<br><a href="/exam/46ec7757/#大学许多知识后面才用到" class="header_2">大学许多知识后面才用到</a>&nbsp;<br><a href="/exam/46ec7757/#4-用一个月的时间了解Java核心部分的内容" class="header_2">4. 用一个月的时间了解Java核心部分的内容</a>&nbsp;<br><a href="/exam/46ec7757/#5-用半个月的时间，以MySQL为例，了解数据库的大致操作" class="header_2">5. 用半个月的时间，以MySQL为例，了解数据库的大致操作</a>&nbsp;<br><a href="/exam/46ec7757/#6、用一个月的时间，了解基于Spring的web框架" class="header_2">6、用一个月的时间，了解基于Spring的web框架</a>&nbsp;<br><a href="/exam/46ec7757/#8、有学习项目经验后，争取找些商业项目的实践机会" class="header_2">8、有学习项目经验后，争取找些商业项目的实践机会</a>&nbsp;<br><a href="/exam/46ec7757/#9、毕业生准备简历的要点" class="header_2">9、毕业生准备简历的要点</a>&nbsp;<br><a href="/exam/46ec7757/#原文链接" class="header_1">原文链接</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="在校生的困境"><a href="#在校生的困境" class="headerlink" title="在校生的困境"></a>在校生的困境</h1><p>对于那些已经工作的同学，哪怕才工作不久，毕竟也能<strong>从项目实践里总结和探索<code>java</code>的学习途径和相关方法</strong>。但在校生同学由于没机会接触实际项目，在学习内容、进阶途径和学成标准这些方面都是两眼一抹黑，而大学里的内容可能偏重于理论，讲述的技术往往也和软件公司里常用的技术不匹配。<br>这就导致了很多上心的在校生，虽然很努力，但到毕业时，才发现自己起早贪黑学成的技能并不能帮他们找到工作。在本文里，就将结合我面试实习生和毕业生的标准，专门给在校生这个群体一些学习<code>Java</code>方面的建议。</p><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><h2 id="1-明确目标，先说下公司面试应届生的标准"><a href="#1-明确目标，先说下公司面试应届生的标准" class="headerlink" title="1. 明确目标，先说下公司面试应届生的标准"></a>1. 明确目标，先说下公司面试应届生的标准</h2><p>我最近可能都在大公司，到毕业季，会到一些学校去校招，校招的标准描述起来很简单：<code>Java</code>方面能干活，或者能经短期帮带后能干活，具体标准如下。</p><ol><li><code>Web</code>框架方面，需要以全栈的形式，了解<code>SSM</code>，或<code>Spring Boot</code>或<code>Spring Cloud</code>从前端到后端的基本语法，<strong>至少能在项目经理短期帮助下，能照着别人的例子写代码</strong>。应届生候选人只要能讲清楚相关框架的语法点和流程即可，最多再附带说明下<code>mybatis</code>等组件的用法，至于<code>redis</code>，<code>dubbo</code>，根本没要求。</li><li>数据库方面，能会基本的增删改查即可，外带一些基本概念，比如事务怎么处理，<code>JDBC</code>里批处理怎么处理。</li><li><code>Java</code>语法（也就是核心方面），其实如果能讲清楚<code>SSM</code>等<code>Web</code>框架技能，这块只要刷题就能过，比如就问些<code>ArrayList</code>和<code>LinkedList</code>的差别，以及多线程等的概念。</li><li>人看上去听话，想法少，学习能力强，责任心强，不是刺头，这块其实大多数人都可以达标。</li></ol><p>以上不要求有商业项目经验，当然如果有，绝对是加分项，而且这还是大公司的面试应届生的标准。<strong>至于一些小公司，或者是一些外包公司，有时候能招到人就阿弥陀佛了</strong>（至于有些能力比较强的一本的应届生愿不愿意去还难说）。有些在招收应届生的时候，不少<strong>小公司</strong>甚至在“项目经验”方面没要求，哪怕没学习项目经验也不要紧，<strong>只会问些网上比较大路的面试题，能说上来即可</strong>。</p><h2 id="2-面试中大多数应届生的实际表现"><a href="#2-面试中大多数应届生的实际表现" class="headerlink" title="2. 面试中大多数应届生的实际表现"></a>2. 面试中大多数应届生的实际表现</h2><p>从面试官角度来看，<strong>招收应届生的标准其实是很低的</strong>，对应的，在招初级开发时，多少都需要有商业项目经验。从这个角度来看，<strong>应届生最好在校期间就找到工作</strong>，毕业后两三个月找不到工作问题还不怎么大，但如果半年后再找不到工作，那么到时候被面试的标准就高于“应届生”的标准了。<br>这里我无意贬低应届生的水平，毕竟我们都是从这个阶段过来的，但从面试情况来看，至少有将近一半的应届生达不到标准。</p><h3 id="达不到标准的具体表现"><a href="#达不到标准的具体表现" class="headerlink" title="达不到标准的具体表现"></a>达不到标准的具体表现</h3><ol><li>没有框架开发的经验，这里最低要求是能自行搭建个<code>SSM</code>项目，但不少同学根本没有。</li><li>数据库方面，就知道理论上的增删改查，甚至不会在<code>MySQL, Oracle</code>和<code>SQL Server</code>平台上运行过<code>SQL</code>语句。</li><li><code>Java</code>核心方面，掌握了一大堆项目里一定不会用的，比如<code>Swing</code>之类的界面编程技术，但<strong>该掌握的多线程集合</strong>等，一些常用的概念也不清楚。</li><li>论动手能力，有些同学甚至没有在<code>Eclipse</code>等<code>IDE</code>上运行通<code>Java</code>代码，或者出了基本的语法错误不知道如何自行解决，至于没有<strong><code>debug</code>调试经验</strong>的，就更加见怪不怪了，而在代码里需要加必要的<code>try...catch</code>异常处理语句，这就更加凤毛麟角了。</li></ol><p>在一些一本大学里，理论和实际操作能力较差的同学虽然不多，但也有，就更别提其它大学和大专了。我也和一些大学老师打过交道，也看过一些大学里用的Java和数据库等编程方面的教材，再结合诸多应届生在面试时的表现，我的感受是，或许<strong>大学阶段更会培养学生的理论素养</strong>，但大学生朋友在读大学阶段，一定要提升实际的编程能力，<strong>包含但不限于（SSM）框架的编程能力，数据库实际操作能力和Java核心部分代码的开发和调试能力</strong> 。</p><h2 id="3-哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）"><a href="#3-哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）" class="headerlink" title="3. 哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）"></a>3. 哪些大学里学到的知识点面试大概率不问（根本不用太费精力看的技术有哪些）</h2><p>这里就将结合具体的知识点，列出面试时需要掌握的最低技能标准，除此之外,大概率不会问的</p><h3 id="面试时需要掌握的最低技能标准"><a href="#面试时需要掌握的最低技能标准" class="headerlink" title="面试时需要掌握的最低技能标准"></a>面试时需要掌握的最低技能标准</h3><h4 id="Java核心常问"><a href="#Java核心常问" class="headerlink" title="Java核心常问:"></a><code>Java</code>核心常问:</h4><ul><li>集合，</li><li>多线程，</li><li>异常处理，</li><li><code>IO</code>，</li><li><code>JDBC</code>，</li><li>面向对象技能，</li></ul><p>这些大概率会问到</p><h4 id="java核心不常问"><a href="#java核心不常问" class="headerlink" title="java核心不常问"></a>java核心不常问</h4><ul><li>图形化界面，</li><li><code>NIO</code>，</li><li><code>Socket</code>网络编程，</li><li>甚至<code>Applet</code>之类的</li></ul><h4 id="数据库方面"><a href="#数据库方面" class="headerlink" title="数据库方面"></a>数据库方面</h4><ul><li>会写增删改查的<code>SQL</code>语句，</li><li>知道存储过程之类的概念，</li><li>会通过索引优化查询条件，</li><li>会建表，</li><li>会些诸如子查询,<code>group by,having</code>，</li><li>表关联查询等基本<code>SQL</code>技能，</li><li><strong>至少得用过一种商业化数据库</strong>。</li></ul><h4 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a>框架方面</h4><p>需要有Spring+Spring MVC+mybatis框架的实际操作能力（不是商业项目开发能力），<br>至于有Spring Boot或Spring Cloud，那更好了。</p><h4 id="综合技能方面"><a href="#综合技能方面" class="headerlink" title="综合技能方面"></a>综合技能方面</h4><ul><li>能知道基本的数据结构知识（线性表外带排序外带一些树的技能），</li><li>基本的操作系统知识（一般仅限于线程进程概念），</li><li>基本网络通讯知识（一般仅限于网络通讯模型和tcp udp协议），</li></ul><p>这些要求是“需要知道”而已。</p><h2 id="看招聘要求查缺补漏"><a href="#看招聘要求查缺补漏" class="headerlink" title="看招聘要求查缺补漏"></a>看招聘要求查缺补漏</h2><p>大家其实也可以通过看各种职位描述和招聘需求，看下哪些技能实际上是不会问的，对于这些知识，就不用学，从而把精力用到学实际Java相关技能上。</p><h2 id="大学许多知识后面才用到"><a href="#大学许多知识后面才用到" class="headerlink" title="大学许多知识后面才用到"></a>大学许多知识后面才用到</h2><p>这里需要说明，在大学阶段学的很多知识，不能说没用。比如网络通讯里的tcp底层通讯细节，这些技能或者要等到工作5年后升级到高级开发或架构师的时候才会用到，而且以高级开发视角观察需要掌握的通讯协议细节知识，绝对要比大学阶段要复杂。</p><p>换句话说，很多技能，在大学阶段也就“需要了解有这事”，以在大学阶段的经历，再多用时间学，估计也无法达到“实际项目的需求”，而且等到有实际项目经验时，再学这类技能也就是一两周的事情。两厢一对比，结论就很明确了：在<strong>校阶段应该更多积累实际开发能力</strong>，因为更得靠这个找工作。</p><h2 id="4-用一个月的时间了解Java核心部分的内容"><a href="#4-用一个月的时间了解Java核心部分的内容" class="headerlink" title="4. 用一个月的时间了解Java核心部分的内容"></a>4. 用一个月的时间了解Java核心部分的内容</h2><ul><li>着重观察<strong>集合</strong>，<strong>面向对象</strong>，<strong>多线程</strong>，<strong>IO处理</strong>，<strong>JDBC</strong>，<strong>异常处理</strong>相关章节，这个阶段，是<strong>以掌握API用法</strong>为主，在这基本上再看下诸如接口，抽象类，异常处理流程，垃圾回收之类的高级知识点。</li><li>在上述基础上，如果可以通过资料的帮助，</li><li><strong>用Java实现堆栈，链表，队列，散列表，树等的数据结构</strong>，</li><li><strong>同时操练各种排序算法</strong>，这对找工作也有些帮助</li></ul><h2 id="5-用半个月的时间，以MySQL为例，了解数据库的大致操作"><a href="#5-用半个月的时间，以MySQL为例，了解数据库的大致操作" class="headerlink" title="5. 用半个月的时间，以MySQL为例，了解数据库的大致操作"></a>5. 用半个月的时间，以MySQL为例，了解数据库的大致操作</h2><p>在数据库方面，最好也去找本书，同时在<code>MYSQL</code>上实践。为什么选<code>MYSQL</code>,因为这比较轻，相比<code>Oracle</code>而言，好安装，当然如果有条件装<code>SQL Server</code>之类的，那就更好了。<br>1、在<code>MySQL</code>数据库上，实践各种增删改查的<code>SQL</code>语句，实践建表，建索引能技巧，同时实践一下诸如子查询，<code>with as</code>等等复杂的<code>SQL</code>语句。<br>2、用<code>JDBC</code>连同<code>MYSQL</code>，在<code>Java</code>代码里做各种<strong>增删改查</strong>的操作。<br>3、在此基础上，了解诸如索引，范式和锁等概念，这时候虽然认识也会很肤浅，但至少不会一头雾水了。</p><p>这样，在数据库方面，好歹有实际操作经验了，这为之后的项目实践，能打下很好的基础。</p><h2 id="6、用一个月的时间，了解基于Spring的web框架"><a href="#6、用一个月的时间，了解基于Spring的web框架" class="headerlink" title="6、用一个月的时间，了解基于Spring的web框架"></a>6、用一个月的时间，了解基于Spring的web框架</h2><p>面试时更看重的是框架经验，这块学习的建议如下。<br>1、先通过运行代码，了解<code>Spring</code>里<code>IOC, AOP</code>，这时应该注意各种配置。<br>2、熟悉<code>Spring</code>的基本概念后，可以尝试跑一个<code>SSM</code>的小例子，这个例子可以非常简答，就一个页面也行，但要包含<code>Spring MVC</code>和<code>Mybatis</code>诸多要素，这样大家好歹能知道框架的构成，在这个基础上，可以继续扩展，加些必要的业务，从而进一步了解这个框架。<br>在这个阶段，还是最好看书上的例子，因为书上的例子一定能通，而且还会带部署和运行的步骤，还是不建议自己敲代码，因为<code>SSM</code>框架相对复杂，在这个阶段如果自己敲，很有可能会因为问题太多而放弃。<br>3、在自己机器上跑通<code>SSM</code>框架的案例后，可以网上找个带业务的系统，比如<strong>图书管理系统</strong>等，从中看些前端和后端交互数据的流程，同时，结合业务看<code>Mybatis</code>里的<code>ORM</code>过程，以及<strong><code>Spring</code>里的常用注解</strong>。</p><h2 id="8、有学习项目经验后，争取找些商业项目的实践机会"><a href="#8、有学习项目经验后，争取找些商业项目的实践机会" class="headerlink" title="8、有学习项目经验后，争取找些商业项目的实践机会"></a>8、有学习项目经验后，争取找些商业项目的实践机会</h2><p>拥有最基本的SSM以及其它Java和数据库相关技能后，要做的绝不是继续积累学习项目经验，而是尽可能去找实习的机会，以积累商业项目的经验。在找实习经验方面，大家可以参照如下的建议。<br>1、在我之前的博文里也提到，大三时，<strong>打听计算机学院里哪些老师和外面公司有合作</strong>，一般<strong>硕导</strong>都有这样的项目，然后直接去找老师，刚开始不要钱，只求经验，或许对各位在校生同学而言，这种方式是比较可行的，本人第一个商业项目经验也是由此得到的。<br>2、一般学校里都会安排实习，实习的过程中，一定要重视，这个是实打实的商业项目经验。<br>3、寒暑假，找软件公司，这可能会比较艰辛，因为在校阶段自己非常难找相关实习机会，但要去找。<br>5、如果实在找不到实习的机会，那么尽可能通过各种渠道，去找商业项目经验的案例</p><p><strong>哪怕实际只干了三个月的商业项目经验，自己的技能也会很大程度提升</strong>，而且实际的商业项目经验，会让大家掌握书本上根本不会多提但项目里一定会用的技能，比如JVM内存调优或多线程并发。从这意义上来讲，只要有条件，大学生朋友应该挤破头去找商业项目的经验，而不是悠哉游哉地坐在机房里敲代码。只要你有商业项目的经验，哪怕就三个月，找工作时你就有代差优势。</p><h2 id="9、毕业生准备简历的要点"><a href="#9、毕业生准备简历的要点" class="headerlink" title="9、毕业生准备简历的要点"></a>9、毕业生准备简历的要点</h2><p>在招聘毕业生时<br>，第一看项目经验，<br>第二看项目里包含的技能，<br>第三再问算法和理论问题，<br>至于逻辑题和情商题，只供参考</p><p>毕业生在简历中，一定得突出做过的项目经验，优先挖掘商业项目经验，<br>实在没有学习项目也行。<br>如果没任何项目经验，那么找工作时会吃力很多</p><h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="https://mp.weixin.qq.com/s/y_ozO8BnH6YkoFh_Oq8M1w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/y_ozO8BnH6YkoFh_Oq8M1w</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试攻略</title>
      <link href="/exam//767b4928/"/>
      <url>/exam//767b4928/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/767b4928/#自我介绍篇" class="header_1">自我介绍篇</a>&nbsp;<br><a href="/exam/767b4928/#我是谁" class="header_2">我是谁</a>&nbsp;<br><a href="/exam/767b4928/#职业相关经历介绍" class="header_2">职业相关经历介绍</a>&nbsp;<br><a href="/exam/767b4928/#我为什么想要这份工作" class="header_2">我为什么想要这份工作</a>&nbsp;<br><a href="/exam/767b4928/#个人其他值得一提的经历" class="header_2">个人其他值得一提的经历</a>&nbsp;<br><a href="/exam/767b4928/#自我评价篇" class="header_1">自我评价篇</a>&nbsp;<br><a href="/exam/767b4928/#你最大的缺点是什么" class="header_2">你最大的缺点是什么?</a>&nbsp;<br><a href="/exam/767b4928/#你的优点是什么" class="header_2">你的优点是什么?</a>&nbsp;<br><a href="/exam/767b4928/#最能概括你的三个词是什么" class="header_2">最能概括你的三个词是什么?</a>&nbsp;<br><a href="/exam/767b4928/#谈谈你某次失败的经历" class="header_2">谈谈你某次失败的经历</a>&nbsp;<br><a href="/exam/767b4928/#求职意愿篇" class="header_1">求职意愿篇</a>&nbsp;<br><a href="/exam/767b4928/#你为什么想来这里工作" class="header_2">你为什么想来这里工作?</a>&nbsp;<br><a href="/exam/767b4928/#你如何评价这份工作" class="header_2">你如何评价这份工作?</a>&nbsp;<br><a href="/exam/767b4928/#你觉得你有什么优势" class="header_2">你觉得你有什么优势?</a>&nbsp;<br><a href="/exam/767b4928/#你能接受加班吗" class="header_2">你能接受加班吗?</a>&nbsp;<br><a href="/exam/767b4928/#职业规划篇" class="header_1">职业规划篇</a>&nbsp;<br><a href="/exam/767b4928/#说说你对行业内热点事件/热门现象的看法" class="header_2">说说你对行业内热点事件/热门现象的看法?</a>&nbsp;<br><a href="/exam/767b4928/#说说你对行业、技术发展趋势的看法" class="header_2">说说你对行业、技术发展趋势的看法?</a>&nbsp;<br><a href="/exam/767b4928/#你的职业规划是怎样的" class="header_2">你的职业规划是怎样的?</a>&nbsp;<br><a href="/exam/767b4928/#就你所申请的这个职位-你认为你还欠缺什么" class="header_2">就你所申请的这个职位,你认为你还欠缺什么?</a>&nbsp;<br><a href="/exam/767b4928/#临场压力篇" class="header_1">临场压力篇</a>&nbsp;<br><a href="/exam/767b4928/#你并非毕业于名校" class="header_2">你并非毕业于名校?</a>&nbsp;<br><a href="/exam/767b4928/#从简历上看-你的学习成绩似乎并不突出" class="header_2">从简历上看,你的学习成绩似乎并不突出?</a>&nbsp;<br><a href="/exam/767b4928/#你还有什么问题要问吗" class="header_2">你还有什么问题要问吗?</a>&nbsp;<br><a href="/exam/767b4928/#当你遇到真的无法回答的问题时" class="header_2">当你遇到真的无法回答的问题时</a>&nbsp;<br><a href="/exam/767b4928/#群面篇" class="header_1">群面篇</a>&nbsp;<br><a href="/exam/767b4928/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="自我介绍篇"><a href="#自我介绍篇" class="headerlink" title="自我介绍篇"></a>自我介绍篇</h1><p>可包含如下信息:</p><h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>例如我是小明,毕业于xxxx大学xxxx专业,今天面试的岗位为xxxxx.</p><h2 id="职业相关经历介绍"><a href="#职业相关经历介绍" class="headerlink" title="职业相关经历介绍"></a>职业相关经历介绍</h2><p>提示<br>举出几个<strong>与面试职位相关的经历</strong>,结合具体事例,善用数字。<br>例如“在实习的两个月内先后帮助同事完成了xxxx,xxx和xxx三个项目/报告,为公司带来xx利润。<br>“我被破例允许以实习生的身份在毎天的晨会上做宏观经济简报</p><h2 id="我为什么想要这份工作"><a href="#我为什么想要这份工作" class="headerlink" title="我为什么想要这份工作"></a>我为什么想要这份工作</h2><p>提示结合工作要求,谈谈你为什么能胜任这个工作。<br>例如xxx是我的强项,这份工作和我一直以来所做的以及职业生涯的发展非常匹配。</p><h2 id="个人其他值得一提的经历"><a href="#个人其他值得一提的经历" class="headerlink" title="个人其他值得一提的经历"></a>个人其他值得一提的经历</h2><p>提示<br>能够给面试官留下深刻印象的个人经历。<br>例如<br>我曾经做过义工,我曾经骑行去过西藏。</p><h1 id="自我评价篇"><a href="#自我评价篇" class="headerlink" title="自我评价篇"></a>自我评价篇</h1><p>可包含如下信息:</p><h2 id="你最大的缺点是什么"><a href="#你最大的缺点是什么" class="headerlink" title="你最大的缺点是什么?"></a>你最大的缺点是什么?</h2><p>提示<br>说出自己的缺点及改正它的过程。<br>例如<br>工作经验较少,需要学习和掌握的知识很多,所以有些不够自信,但是一定会加倍努力。</p><h2 id="你的优点是什么"><a href="#你的优点是什么" class="headerlink" title="你的优点是什么?"></a>你的优点是什么?</h2><p>提示<br>自己觉得还不错且和工作有关的的优点。<br>例如<br>处事能力类——沉着冷静、条理清矬;<br>优秀品质类—一不怕困难、喜欢挑战;<br>团队精神类乐于助人、关心他人。</p><h2 id="最能概括你的三个词是什么"><a href="#最能概括你的三个词是什么" class="headerlink" title="最能概括你的三个词是什么?"></a>最能概括你的三个词是什么?</h2><p>提示<br>不仅给出关键词,还应举出具体例子说明。<br>例如“我的适应能力强,有责任心和做事有始终”,并结合具体例子解释</p><h2 id="谈谈你某次失败的经历"><a href="#谈谈你某次失败的经历" class="headerlink" title="谈谈你某次失败的经历"></a>谈谈你某次失败的经历</h2><p>提示<br>应表达出曾做过的努力,并介绍从失败中总结出的经验,及如何处理、克服和改变。<br>例如<br>虽然方杗没有通过,但是拢到了存在的问题,并以更饱满的热情面对之后的工作。</p><h1 id="求职意愿篇"><a href="#求职意愿篇" class="headerlink" title="求职意愿篇"></a>求职意愿篇</h1><p>可包含如下信息:</p><h2 id="你为什么想来这里工作"><a href="#你为什么想来这里工作" class="headerlink" title="你为什么想来这里工作?"></a>你为什么想来这里工作?</h2><p>提示<br>可以从<strong>行业</strong>、<strong>平台</strong>和<strong>岗位</strong>这三个角度来回答。<br>例如<br>依据行业大环境与局部小环境的具体了解详细回答,充分表达自对于用人单位的向往和长期的职业规划等,突出自己与这份工作的契合点。</p><h2 id="你如何评价这份工作"><a href="#你如何评价这份工作" class="headerlink" title="你如何评价这份工作?"></a>你如何评价这份工作?</h2><p>提示<br>可以回答对工作环境很向往,对工作内容很感兴趣。<br>例如<br>之前受到从事过类似工作的前辈对自己产生的积极影晌,加上自己亲身的学习与实践体会,觉得这份工作的确有与众不同之处。</p><h2 id="你觉得你有什么优势"><a href="#你觉得你有什么优势" class="headerlink" title="你觉得你有什么优势?"></a>你觉得你有什么优势?</h2><p>提示充分了解招聘单位期待这个职位所能发挥的作用,根据自己的实际情况和优势,站在招聘单位的角度表明“我能做什么语句尽量简短有力,语气自信笃定。</p><h2 id="你能接受加班吗"><a href="#你能接受加班吗" class="headerlink" title="你能接受加班吗?"></a>你能接受加班吗?</h2><p>提示面试官提出这样的问题,通常是想看你愿不愿意为单位付出、奉献<br>例如<br>根据实际情况作答。或者表达出“我会提高效率,减少不必要的卩班类的意思。</p><h1 id="职业规划篇"><a href="#职业规划篇" class="headerlink" title="职业规划篇"></a>职业规划篇</h1><p>可包含如下信息:</p><h2 id="说说你对行业内热点事件-热门现象的看法"><a href="#说说你对行业内热点事件-热门现象的看法" class="headerlink" title="说说你对行业内热点事件/热门现象的看法?"></a>说说你对行业内热点事件/热门现象的看法?</h2><p>提示热点事件与热门现象往往众说纷纭,所以不必过度纠结持哪种见解。<br>回答问题时,理由要支撑观点,井依循一定的要点,有逻辑、有条理、有节奏地说出自己的想法。</p><h2 id="说说你对行业、技术发展趋势的看法"><a href="#说说你对行业、技术发展趋势的看法" class="headerlink" title="说说你对行业、技术发展趋势的看法?"></a>说说你对行业、技术发展趋势的看法?</h2><p>提示在面试前充分了解你所在行业的新近热点与发屐趋势,并在思考后整理出相对独特的见解。<br>聪明的求职者往往对所要涉足的领域预先了解很多,用人单位更青睐“知己”,而不是盲人</p><h2 id="你的职业规划是怎样的"><a href="#你的职业规划是怎样的" class="headerlink" title="你的职业规划是怎样的?"></a>你的职业规划是怎样的?</h2><p>提示这个问题涉及个人定位,回答时可以多侧重对于<strong>进步的渴望</strong>。未来规划是否是空想,是否能清楚地意识到风险的存在等,都会在规划中得到体现。因此要慎重考虑回答。</p><h2 id="就你所申请的这个职位-你认为你还欠缺什么"><a href="#就你所申请的这个职位-你认为你还欠缺什么" class="headerlink" title="就你所申请的这个职位,你认为你还欠缺什么?"></a>就你所申请的这个职位,你认为你还欠缺什么?</h2><p>可以通过个人经历的不足之处,以<strong>自省</strong>为角度回答问题可以表达“我相信自己可以胜任这份工作,目前只是缺验,我可以进入公司后以最短的解决,我的学习能力很强,相信可以很快融入单位,进入工作状态。</p><h1 id="临场压力篇"><a href="#临场压力篇" class="headerlink" title="临场压力篇"></a>临场压力篇</h1><p>可包含如下信息</p><h2 id="你并非毕业于名校"><a href="#你并非毕业于名校" class="headerlink" title="你并非毕业于名校?"></a>你并非毕业于名校?</h2><p>提示<br>没必要被这类问题激怒,要强调比学历更重要的是能力,并举列说明自己的优势。而且要强调你目前所掌握的技能可以匹配招聘需求。</p><h2 id="从简历上看-你的学习成绩似乎并不突出"><a href="#从简历上看-你的学习成绩似乎并不突出" class="headerlink" title="从简历上看,你的学习成绩似乎并不突出?"></a>从简历上看,你的学习成绩似乎并不突出?</h2><p>提示<br>突出与应聘岗位相关的高分课程;突出实习、兼职或社囫经历通过实践证明面试者的综合素质和能力;突出自己在大学长期坚持的某项爱好及取得的成绩。</p><h2 id="你还有什么问题要问吗"><a href="#你还有什么问题要问吗" class="headerlink" title="你还有什么问题要问吗?"></a>你还有什么问题要问吗?</h2><p>提示<br>根据个人情况作答,可以适当体现自己的个性,也可以表达自己的学习热情及上进心。<br>例如“贵单位对新入职的员工么培训项目?”“贵单位的xxx部门或产品)是怎样运生的?</p><h2 id="当你遇到真的无法回答的问题时"><a href="#当你遇到真的无法回答的问题时" class="headerlink" title="当你遇到真的无法回答的问题时"></a>当你遇到真的无法回答的问题时</h2><p>提示<br>不要着急回答,先要做认真思考,以示自己的认真态度与这个问题的难度诚恳向对方表明自己在这个问题上只知道皮毛,从来不知道深意;适时将问题抛给对方,表示出愿意聆听教导的诚意。</p><h1 id="群面篇"><a href="#群面篇" class="headerlink" title="群面篇"></a>群面篇</h1><p>提示<br>无论扮演的角色是什么,群面考察的本质上都是<strong>个人的气度礼仪、表达能力、沟通能力及合作能力</strong>等。<br>1提前熟悉队友:<br>群面是一次团队合作,沟通非常重要。在面试前与队友简单交流、相互熟悉,讨论的氛围会变得更加融洽;<br>2.善于倾听他人:<br>注意聆听别人的发言,一方面可以结合自己的思考推陈出新,另一方面可以通过总结让自己的发言更加全面;<br>3.逻辑清晰:<br>发言务必要有逻辑、有要点,力争让人能够及时理解你的观点、你的理由,提前列出框架会对你更有帮助;<br>4.学会及时应变:<br>在规定时间内达成共识,是群面中重要的考核点。适当妥协,勇于受更加合理的建议在群面中也是加分项。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.weibo.cn/detail/4448389053509435" target="_blank" rel="noopener">https://m.weibo.cn/detail/4448389053509435</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月17日 java1</title>
      <link href="/exam//c8b56ff4/"/>
      <url>/exam//c8b56ff4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c8b56ff4/#考点1-JSP内置对象" class="header_1">考点1 JSP内置对象</a>&nbsp;<br><a href="/exam/c8b56ff4/#考点2-集合-异常-接口-继承" class="header_1">考点2 集合 异常 接口 继承</a>&nbsp;<br><a href="/exam/c8b56ff4/#考点3-静态成员和普通成员的执行顺序" class="header_1">考点3 静态成员和普通成员的执行顺序</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-JSP内置对象"><a href="#考点1-JSP内置对象" class="headerlink" title="考点1 JSP内置对象"></a>考点1 JSP内置对象</h1><p>下面有关JSP内置对象的描述,说法错误的是？</p><ul><li>A <code>session</code>对象:<code>session</code>对象指的是客户端与服务器的一次会话,从客户连到服务器的一个<code>WebApplication</code>开始,直到客户端与服务器断开连接为止</li><li>B <code>request</code>对象:客户端的请求信息被封装在<code>request</code>对象中,通过它才能了解到客户的需求,然后做出响应</li><li>C <code>application</code>对象:多个<code>application</code>对象实现了用户间数据的共享,可存放全局变量</li><li>D <code>response</code>对象:<code>response</code>对象包含了响应客户请求的有关信息</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>application对象是共享的，多个用户共享一个，以此实现数据共享和通信<br>JSP内置对象和属性列举如下：<br>1.request对象<br>客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>2.response对象<br>response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>3.session对象<br>session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>4.out对象<br>out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>5.page对象<br>page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>6.application对象<br>application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>7.exception对象<br>exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p><h1 id="考点2-集合-异常-接口-继承"><a href="#考点2-集合-异常-接口-继承" class="headerlink" title="考点2 集合 异常 接口 继承"></a>考点2 集合 异常 接口 继承</h1><p>下面叙述那个是正确的？()</p><ul><li>A <code>java</code>中的集合类(如<code>Vector</code>)可以用来存储任何类型的对象,且大小可以自动调整。但需要事先知道所存储对象的类型,才能正常使用。</li><li>B 在<code>java</code>中,我们可以用违例(<code>Exception</code>)来抛出一些并非错误的消息,但这样比直接从函数返回一个结果要更大的系统开销。</li><li>C <code>java</code>接口包含函数声明和变量声明。</li><li>D <code>java</code>中,子类不可以访问父类的私有成员和受保护的成员。</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="创建对象比方法调用内存开销大"><a href="#创建对象比方法调用内存开销大" class="headerlink" title="创建对象比方法调用内存开销大"></a>创建对象比方法调用内存开销大</h3><p>B选项说的情况就是我们自定义异常的情况，因为函数调用是入栈出栈，栈是在寄存器之下的速度最快，且占的空间少，而自定义异常是存在堆中，肯定异常的内存开销大！所以B对。</p><h3 id="接口中只有常量定义-没有变量声明"><a href="#接口中只有常量定义-没有变量声明" class="headerlink" title="接口中只有常量定义 没有变量声明"></a>接口中只有常量定义 没有变量声明</h3><p>C选项说的是接口包含方法声明和变量声明。因为接口中方法默认是<br>abstract public,所以在接口只写函数声明是符合语法规则。但是变量默认是用public<br>final static 修饰的，意思它是<strong>静态常量</strong>，常量不管在接口中还是类中必须在声明时初始化！所以C的后半句是错的，必须在声明时并给出初始化！</p><h1 id="考点3-静态成员和普通成员的执行顺序"><a href="#考点3-静态成员和普通成员的执行顺序" class="headerlink" title="考点3 静态成员和普通成员的执行顺序"></a>考点3 静态成员和普通成员的执行顺序</h1><p>以下代码的输出结果是？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t1 = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> B t2 = <span class="keyword">new</span> B();</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B t = <span class="keyword">new</span> B();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 静态块 构造块 构造块 构造块</li><li>B 构造块 静态块 构造块 构造块</li><li>C 构造块 构造块 静态块 构造块</li><li>D 构造块 构造块 构造块 静态块</li></ul><h2 id="解析-多个静态成员按顺序执行"><a href="#解析-多个静态成员按顺序执行" class="headerlink" title="解析 多个静态成员按顺序执行"></a>解析 多个静态成员按顺序执行</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月16日 java1</title>
      <link href="/exam//1d7732bf/"/>
      <url>/exam//1d7732bf/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/1d7732bf/#考点1-case穿透" class="header_1">考点1 case穿透</a>&nbsp;<br><a href="/exam/1d7732bf/#考点2-servlet内置对象" class="header_1">考点2 servlet内置对象</a>&nbsp;<br><a href="/exam/1d7732bf/#考点3-运算符优先级" class="header_1">考点3 运算符优先级</a>&nbsp;<br><a href="/exam/1d7732bf/#考点4-持久区jvm堆内存溢出" class="header_1">考点4 持久区jvm堆内存溢出</a>&nbsp;<br><a href="/exam/1d7732bf/#考点5-CMS垃圾回收器" class="header_1">考点5 CMS垃圾回收器</a>&nbsp;<br><a href="/exam/1d7732bf/#考点6-序列化" class="header_1">考点6 序列化</a>&nbsp;<br><a href="/exam/1d7732bf/#考点7-网络编程" class="header_1">考点7 网络编程</a>&nbsp;<br><a href="/exam/1d7732bf/#考点8-HashMap" class="header_1">考点8 HashMap</a>&nbsp;<br><a href="/exam/1d7732bf/#考点9-补码运算" class="header_1">考点9 补码运算</a>&nbsp;<br><a href="/exam/1d7732bf/#考点10-反射机制" class="header_1">考点10 反射机制</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-case穿透"><a href="#考点1-case穿透" class="headerlink" title="考点1 case穿透"></a>考点1 case穿透</h1><p>给定代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchTest</span></span>&#123;<span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//2</span></span><br><span class="line">System.out.println(<span class="string">"value="</span>+switchit(<span class="number">4</span>));<span class="comment">//3</span></span><br><span class="line">&#125;<span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">switchit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:j++;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:j++;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:j++;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:j++;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:j++;</span><br><span class="line"><span class="keyword">default</span>:j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j+x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>第三行将输出什么？</p><ul><li>A <code>value=6</code></li><li>B <code>value=8</code></li><li>C <code>value=3</code></li><li>D <code>value=5</code></li><li>E <code>value=4</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点2-servlet内置对象"><a href="#考点2-servlet内置对象" class="headerlink" title="考点2 servlet内置对象"></a>考点2 servlet内置对象</h1><p>从以下哪一个选项中可以获得Servlet的初始化参数?</p><ul><li>A <code>Servlet</code></li><li>B <code>ServletContext</code></li><li>C <code>ServletConfig</code></li><li>D <code>GenericServlet</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>通过ServletConfig接口的getInitParameter(java.lang.String name)方法</p><h1 id="考点3-运算符优先级"><a href="#考点3-运算符优先级" class="headerlink" title="考点3 运算符优先级"></a>考点3 运算符优先级</h1><p>下面的程序将来打印什么?()<br>public class TestIncr {<br>    public static void main(String args[]) {<br>        int i = 0;<br>        i = i++ + i;<br>        System.out.println(“I =” +i);<br>    }<br>}</p><ul><li>A <code>I = 1</code></li><li>B <code>I = 2</code></li><li>C <code>I = 3</code></li><li>D 编译出错</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点4-持久区jvm堆内存溢出"><a href="#考点4-持久区jvm堆内存溢出" class="headerlink" title="考点4 持久区jvm堆内存溢出"></a>考点4 持久区jvm堆内存溢出</h1><p>下面哪种情况会导致持久区jvm堆内存溢出？</p><ul><li>A 循环上万次的字符串处理</li><li>B 在一段代码内申请上百M甚至上G的内存</li><li>C 使用<code>CGLib</code>技术直接操作字节码运行,生成大量的动态类</li><li>D 不断创建对象</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p><a href="http://blog.csdn.net/sivyer123/article/details/17139443" target="_blank" rel="noopener">http://blog.csdn.net/sivyer123/article/details/17139443</a></p><h1 id="考点5-CMS垃圾回收器"><a href="#考点5-CMS垃圾回收器" class="headerlink" title="考点5 CMS垃圾回收器"></a>考点5 CMS垃圾回收器</h1><p>CMS垃圾回收器在那些阶段是没用用户线程参与的</p><ul><li>A 初始标记</li><li>B 并发标记</li><li>C 重新标记</li><li>D 并发清理</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><h1 id="考点6-序列化"><a href="#考点6-序列化" class="headerlink" title="考点6 序列化"></a>考点6 序列化</h1><p>transient 变量和下面哪一项有关？   </p><ul><li>A <code>Cloneable</code></li><li>B <code>Serializable</code></li><li>C <code>Runnable</code></li><li>D <code>Comparable</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点7-网络编程"><a href="#考点7-网络编程" class="headerlink" title="考点7 网络编程"></a>考点7 网络编程</h1><p>关于 Socket 通信编程,以下描述错误的是:( )</p><ul><li>A 服务器端通过<code>new ServerSocket()</code>创建<code>TCP</code>连接对象</li><li>B 服务器端通过<code>TCP</code>连接对象调用<code>accept()</code>方法创建通信的<code>Socket</code>对象</li><li>C 客户端通过<code>new Socket()</code>方法创建通信的<code>Socket</code>对象</li><li>D 客户端通过<code>new ServerSocket()</code>创建<code>TCP</code>连接对象</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点8-HashMap"><a href="#考点8-HashMap" class="headerlink" title="考点8 HashMap"></a>考点8 HashMap</h1><p>下面有关java hashmap的说法错误的是？</p><ul><li>A <code>HashMap</code> 的实例有两个参数影响其性能:”初始容量” 和 “加载因子”。</li><li>B <code>HashMap</code> 的实现不是同步的,意味着它不是线程安全的</li><li>C <code>HashMap</code>通过开放地址法解决哈希冲突</li><li>D <code>HashMap</code>中的<code>key-value</code>都是存储在<code>Entry</code>数组中的</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 注：<br>链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br>   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。<br>沿此序列逐个单元地查找，直到找到给定<br>的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中<br>。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数<br>组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p><h1 id="考点9-补码运算"><a href="#考点9-补码运算" class="headerlink" title="考点9 补码运算"></a>考点9 补码运算</h1><p>变量a是一个64位有符号的整数,初始值用16进制表示为:0Xf000000000000000; 变量b是一个64位有符号的整数,初始值用16进制表示为:0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？()</p><ul><li>A 1</li><li>B -(2^62+2^61+2^60+1)</li><li>C 2^62+2^61+2^60+1</li><li>D 2^59+(2^55+2^54+…+2^2+2^1+2^0)</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点10-反射机制"><a href="#考点10-反射机制" class="headerlink" title="考点10 反射机制"></a>考点10 反射机制</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述,哪些是错误的:(    )</p><ul><li>A <code>Java</code>反射主要涉及的类如<code>Class, Method, Filed</code>,等,他们都在<code>java.lang.reflet</code>包下</li><li>B 通过反射可以动态的实现一个接口,形成一个新的类,并可以用这个类创建对象,调用对象方法</li><li>C 通过反射,可以突破<code>Java</code>语言提供的对象成员、类成员的保护机制,访问一般方式不能访问的成员</li><li>D <code>Java</code>反射机制提供了字节码修改的技术,可以动态的修剪一个类</li><li>E <code>Java</code>的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li><li>F <code>Java</code>反射机制一般会带来效率问题,效率问题主要发生在查找类的方法和字段对象,因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details><ul><li>A选项错误，类Class在java.lang包下，类Method、Filed在java.lang.reflet包下。</li><li>D选项错误，反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而<strong>不是修剪类</strong>，</li><li>F选项错误，使用了<strong>反射的效率都会降低</strong>，就算加了缓存</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月14日 java1</title>
      <link href="/exam//1982e282/"/>
      <url>/exam//1982e282/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'1982e282'/#考点1-进制加权展开" class="header_1">考点1 进制加权展开</a>&nbsp;<br><a href="/exam/'1982e282'/#考点2-字符流-字节流" class="header_1">考点2 字符流 字节流</a>&nbsp;<br><a href="/exam/'1982e282'/#考点3-字符集" class="header_1">考点3 字符集</a>&nbsp;<br><a href="/exam/'1982e282'/#考点4-EJB" class="header_1">考点4 EJB</a>&nbsp;<br><a href="/exam/'1982e282'/#考点5-中间件" class="header_1">考点5 中间件</a>&nbsp;<br><a href="/exam/'1982e282'/#考点6-存根类-适配器模式" class="header_1">考点6 存根类 适配器模式 </a>&nbsp;<br><a href="/exam/'1982e282'/#考点7-静态方法" class="header_1">考点7 静态方法</a>&nbsp;<br><a href="/exam/'1982e282'/#考点8-lambda表达式" class="header_1">考点8 lambda表达式</a>&nbsp;<br><a href="/exam/'1982e282'/#考点9-Servlet过滤器" class="header_1">考点9 Servlet过滤器</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-进制加权展开"><a href="#考点1-进制加权展开" class="headerlink" title="考点1 进制加权展开"></a>考点1 进制加权展开</h1><p>以下哪个式子有可能在某个进制下成立()？</p><ul><li>A 13*14=204</li><li>B 12*34=568</li><li>C 14*14=140</li><li>D 1+1=3</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>（1<em>n+3）</em>(1<em>n+4)=2</em>n^2+4;<br>解得:  n=-1或n=8; 进制不为负数，所以 n=8成立</p><h1 id="考点2-字符流-字节流"><a href="#考点2-字符流-字节流" class="headerlink" title="考点2 字符流 字节流"></a>考点2 字符流 字节流</h1><p>下面的类哪些可以处理Unicode字符?</p><ul><li>A <code>InputStreamReader</code></li><li>B <code>BufferedReader</code></li><li>C <code>Writer</code></li><li>D <code>PipedInputStream</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><h1 id="考点3-字符集"><a href="#考点3-字符集" class="headerlink" title="考点3 字符集"></a>考点3 字符集</h1><p>在Java语言中,下列关于字符集编码(Character set encoding)和国际化(i18n)的问题,哪些是正确的？</p><ul><li>A 每个中文字符占用2个字节,每个英文字符占用1个字节</li><li>B 假设数据库中的字符是以<code>GBK</code>编码的,那么显示数据库数据的网页也必须是<code>GBK</code>编码的。</li><li>C <code>Java</code>的<code>char</code>类型,通常以<code>UTF-16 Big Endian</code>的方式保存一个字符。</li><li>D 实现国际化应用常用的手段是利用<code>ResourceBundle</code>类</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><p>A 显然是错误的，Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。<br>B 也是不正确的，不同的编码之间是可以转换的，通常流程如下：<br>将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。<br>例：String newUTF8Str = new<br>String(oldGBKStr.getBytes(“GBK”), “UTF8”);<br>C 是正确的。Java虚拟机中通常使用UTF-16的方式保存一个字符<br>D 也是正确的。ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。<br>综上所述，答案是 C 和 D。</p><h1 id="考点4-EJB"><a href="#考点4-EJB" class="headerlink" title="考点4 EJB"></a>考点4 EJB</h1><p>下列说法正确的是()</p><ul><li>A <code>WebLogic</code>中开发消息<code>Bean</code>的<code>non</code>－<code>persistent</code> 方式可以保证消息的可靠</li><li>B <code>EJB</code>容器发生错误,<code>non-persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li><li>C <code>EJB</code>容器发生错误,<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li><li>D <code>EJB</code>容器发生错误,两种方式下<code>JMS</code>容器仍会在<code>MDB</code>可用的时候将消息发送</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>weblogic中开发消息Bean时的persistent与non-persisten的差别：<br>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来。<br>non-persistent方式的消息将被丢弃。</p><h1 id="考点5-中间件"><a href="#考点5-中间件" class="headerlink" title="考点5 中间件"></a>考点5 中间件</h1><p>关于中间件特点的描述.不正确的是()</p><ul><li>A 中间件运行于客户机/服务器的操作系统内核中,提高内核运行效率</li><li>B 中间件应支持标准的协议和接口</li><li>C 中间件可运行于多种硬件和操作系统平台上</li><li>D 跨越网络,硬件,操作系统平台的应用或服务可通过中间件透明交互</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>中间件是一种独立的<strong>系统软件或服务程序</strong>，分布式应用软件借助这种软件在不同的技术之间共享资源。<br><strong>中间件位于</strong>客户机/服务器的<strong>操作系统之上</strong>，<strong>应用软件之下</strong>，用来管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。</p><p>（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）</p><p>中间件位于操作系统之上，应用软件之下，而不是操作系统内核中</p><h1 id="考点6-存根类-适配器模式"><a href="#考点6-存根类-适配器模式" class="headerlink" title="考点6 存根类 适配器模式"></a>考点6 存根类 适配器模式</h1><p>存根(Stub)与以下哪种技术有关</p><ul><li>A 交换</li><li>B 动态链接</li><li>C 动态加载</li><li>D 磁盘调度</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="什么是存根类"><a href="#什么是存根类" class="headerlink" title="什么是存根类"></a>什么是存根类</h3><p>存根类是一个类，它实现了一个接口，但是实现后的每个方法都是空的。 </p><h3 id="存根类的作用"><a href="#存根类的作用" class="headerlink" title="存根类的作用"></a>存根类的作用</h3><p>如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦</p><h1 id="考点7-静态方法"><a href="#考点7-静态方法" class="headerlink" title="考点7 静态方法"></a>考点7 静态方法</h1><p>阅读如下代码。 请问,对语句行 test.hello(). 描述正确的有()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> NowCoder;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Test test=<span class="keyword">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 能编译通过,并正确运行</li><li>B 因为使用了未初始化的变量,所以不能编译通过</li><li>C 以错误的方式访问了静态方法</li><li>D 能编译通过,但因变量为null,不能正常运行</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>类方法不依附与对象。所以可以正常运行</p><h1 id="考点8-lambda表达式"><a href="#考点8-lambda表达式" class="headerlink" title="考点8 lambda表达式"></a>考点8 lambda表达式</h1><p>下面哪些写法能在 java8 中编译执行()</p><ul><li>A <code>dir.listFiles((File f)-&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li><li>B <code>dir.listFiles((File f)=&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li><li>C <code>dir.listFiles((_.getName().endsWith(&quot;.Java&quot;)));</code></li><li>D <code>dir.listFiles( f-&gt;f.getName().endsWith(&quot;.Java&quot;));</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>Lanbda表达式的主要作用就是代替匿名内部类的繁琐语法, 它由三部分组成:</p><ol><li>形参列表。<ul><li>形参列表<strong>允许省略形参类型</strong>。</li><li>如果形参列表中只有一个参数,甚至连<strong>形参列表的圆括号也可以省略</strong>。</li></ul></li><li>箭头(-&gt;)。必须通过英文减法符号和大于符号组成。</li><li>代码块。<ul><li>如果代码块只包含一条语句,Lambda表达式允许省略代码块的花括号,那么那条语句就不要用花括号表示语句结束。</li><li>Lambda代码块只有一条return语句,甚至可以省略return关键字。</li><li>Lambda表达式需要返回值,而它的代码块中仅有一条省略了return的语句。Lambda表达式会自动返回这条语句的值。</li></ul></li></ol><h1 id="考点9-Servlet过滤器"><a href="#考点9-Servlet过滤器" class="headerlink" title="考点9 Servlet过滤器"></a>考点9 Servlet过滤器</h1><p>在J2EE中,使用Servlet过滤器,需要在web.xml中配置()元素</p><ul><li>A <code>&lt;filter&gt;</code></li><li>B <code>&lt;filter-mapping&gt;</code></li><li>C <code>&lt;servlet-filter&gt;</code></li><li>D <code>&lt;filter-config&gt;</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details><p>Servlet过滤器的配置包括两部分：<br>第一部分是过滤器在Web应用中的定义，由<filter>元素表示，包括<filter-name>和<filter-class>两个必需的子元素<br>第二部分是过滤器映射的定义，由<filter-mapping>元素表示,<br>有<filter-name>和<url-pattern>两个子元素<br>可以将一个过滤器映射到一个或者多个Servlet或JSP文件，也可以采用url-pattern将过滤器映射到任意特征的URL。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字符编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><br>没有<servlet-filter>和<filter-config></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月13日 java1</title>
      <link href="/exam//fb5ef9fb/"/>
      <url>/exam//fb5ef9fb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/fb5ef9fb/#考点1-二维数组的遍历" class="header_1">考点1 二维数组的遍历</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点2-main方法的书写" class="header_1">考点2 main方法的书写</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点3-数据库-事务隔离级别" class="header_1">考点3 数据库 事务隔离级别</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点4-子类调用父类构造器" class="header_1">考点4 子类调用父类构造器</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点5-检查异常" class="header_1">考点5 检查异常</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点6-排序-快速排序" class="header_1">考点6 排序 快速排序</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点7-线程" class="header_1">考点7 线程</a>&nbsp;<br><a href="/exam/fb5ef9fb/#考点8-java编译" class="header_1">考点8 java编译</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-二维数组的遍历"><a href="#考点1-二维数组的遍历" class="headerlink" title="考点1 二维数组的遍历"></a>考点1 二维数组的遍历</h1><p>下面程序段执行完成后,则变量sum的值是(    )。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  b[][]=&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[i].length;j++) &#123;</span><br><span class="line">        sum+=b[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 32</li><li>B 11</li><li>C 2</li><li>D 3</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点2-main方法的书写"><a href="#考点2-main方法的书写" class="headerlink" title="考点2 main方法的书写"></a>考点2 main方法的书写</h1><p>main 方法是 Java Application 程序执行的入口点,以下描述哪项是合法的()。</p><ul><li>A <code>public static void main( )</code></li><li>B <code>public static void main( String args[] )</code></li><li>C <code>public static int main(String [] arg )</code></li><li>D <code>public void main(String arg[] )</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点3-数据库-事务隔离级别"><a href="#考点3-数据库-事务隔离级别" class="headerlink" title="考点3 数据库 事务隔离级别"></a>考点3 数据库 事务隔离级别</h1><p>事务隔离级别是由谁实现的？</p><ul><li>A <code>Java</code>应用程序</li><li>B <code>Hibernate</code></li><li>C 数据库系统</li><li>D <code>JDBC</code>驱动程序</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点4-子类调用父类构造器"><a href="#考点4-子类调用父类构造器" class="headerlink" title="考点4 子类调用父类构造器"></a>考点4 子类调用父类构造器</h1><p>根据以下代码段,执行new Child(“John”, 10); 要使数据域data得到10,则子类空白处应该填写(    )。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123; data = d; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String s, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        ___________________</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>data = d;</code></li><li>B <code>super.data = d;</code></li><li>C <code>Parent(d);</code></li><li>D <code>super(d);</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>子父类存在<strong>同名成员</strong>时，<strong>子类中默认访问子类的成员</strong>，可通过super指定访问父类的成员，格式：super.xx<br>创建子类对象时，默认会调用父类的无参构造方法，但是，如果父类中提供了带参构造函数，却没有提供无参构造器，则子类构造函数必须显示调用父类带参构造器。</p><h1 id="考点5-检查异常"><a href="#考点5-检查异常" class="headerlink" title="考点5 检查异常"></a>考点5 检查异常</h1><p>Thread. sleep()是否会抛出checked exception?</p><ul><li>A 会</li><li>B 不会</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>Thread.sleep() 和 Object.wait(),都可以抛出 InterruptedException。这个异常是不能忽略的,因为它是一个检查异常(checked exception)</p><h1 id="考点6-排序-快速排序"><a href="#考点6-排序-快速排序" class="headerlink" title="考点6 排序 快速排序"></a>考点6 排序 快速排序</h1><p>下面程序的输出结果是什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2</span></span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">    doSomething(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a.length-<span class="number">1</span>;i++)</span><br><span class="line">    System.out.print(a[i]+<span class="string">" "</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=core(a,start,end);</span><br><span class="line">        doSomething(a,start,p-<span class="number">1</span>);</span><br><span class="line">        doSomething(a,p+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">core</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=a[end];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;=end-<span class="number">1</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;=x)&#123;</span><br><span class="line">            swap(a,i,j);</span><br><span class="line">            i++;<span class="comment">//交换了几次 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//把最大的放到最后</span></span><br><span class="line">    swap(a,i,end);<span class="comment">//把最大的放到i的位置 </span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=a[i];</span><br><span class="line">    a[i]=a[j];</span><br><span class="line">    a[j]=tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 找到最大值</li><li>B 找到最小值</li><li>C 从大到小的排序</li><li>D 从小到大的排序</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点7-线程"><a href="#考点7-线程" class="headerlink" title="考点7 线程"></a>考点7 线程</h1><p>当我们需要所有线程都执行到某一处,才进行后面的的代码执行我们可以使用？</p><ul><li>A <code>CountDownLatch</code></li><li>B <code>CyclicBarrier</code></li><li>C <code>Semaphore</code></li><li>D <code>Future</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>CountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完。<br>CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完。</p><h1 id="考点8-java编译"><a href="#考点8-java编译" class="headerlink" title="考点8 java编译"></a>考点8 java编译</h1><p>下列说法正确的有( )</p><ul><li>A 环境变量可在编译<code>source code</code>时指定</li><li>B 在编译程序时,所能指定的环境变量不包括<code>class path</code></li><li>C <code>javac</code>一次可同时编译数个<code>Java</code>源文件</li><li>D <code>javac.exe</code>能指定编译结果要置于哪个目录(<code>directory</code>)</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月13日 java2</title>
      <link href="/exam//6257a841/"/>
      <url>/exam//6257a841/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/6257a841/#考点1-修饰符混用" class="header_1">考点1 修饰符混用</a>&nbsp;<br><a href="/exam/6257a841/#考点2-求余运算" class="header_1">考点2 求余运算</a>&nbsp;<br><a href="/exam/6257a841/#考点3-java只有值传递" class="header_1">考点3 java只有值传递</a>&nbsp;<br><a href="/exam/6257a841/#考点4-多态-编译看左边-运行看右边" class="header_1">考点4 多态 编译看左边 运行看右边</a>&nbsp;<br><a href="/exam/6257a841/#考点5" class="header_1">考点5 </a>&nbsp;<br><a href="/exam/6257a841/#考点6-Math-round四舍五入-舍变小入变大" class="header_1">考点6 Math.round四舍五入 舍变小入变大</a>&nbsp;<br><a href="/exam/6257a841/#考点7-Log4j" class="header_1">考点7 Log4j</a>&nbsp;<br><a href="/exam/6257a841/#考点8-默认构造器" class="header_1">考点8 默认构造器</a>&nbsp;<br><a href="/exam/6257a841/#考点9-线程安全集合" class="header_1">考点9 线程安全集合</a>&nbsp;<br><a href="/exam/6257a841/#考点10-java内存区域" class="header_1">考点10 java内存区域</a>&nbsp;<br><a href="/exam/6257a841/#考点11-编译原理-循环优化" class="header_1">考点11 编译原理 循环优化</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-修饰符混用"><a href="#考点1-修饰符混用" class="headerlink" title="考点1 修饰符混用"></a>考点1 修饰符混用</h1><p>下列关于修饰符混用的说法,错误的是( )</p><ul><li>A <code>abstract</code>不能与<code>final</code>并列修饰同一个类</li><li>B <code>abstract</code>类中不应该有<code>private</code>的成员</li><li>C <code>abstract</code>方法必须在<code>abstract</code>类或接口中</li><li>D <code>static</code>方法中能直接调用类里的非<code>static</code>的属性</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>abstract类中的确<strong>不应该</strong>有private的成员,但是是可以有的</p><h1 id="考点2-求余运算"><a href="#考点2-求余运算" class="headerlink" title="考点2 求余运算"></a>考点2 求余运算</h1><p>以下代码段执行后的输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A -1</li><li>B 2</li><li>C 1</li><li>D -2</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Y(被除数) % X(除数) 当除数与被除数的符号相同时，取余和取模的结果是完全相同的； 当除数与被除数的符号不相同时，结果不同。具体说，<strong>取余结果的符号与%前面的数的符号(被除数)相同</strong>；</p><h1 id="考点3-java只有值传递"><a href="#考点3-java只有值传递" class="headerlink" title="考点3 java只有值传递"></a>考点3 java只有值传递</h1><p>关于Java中参数传递的说法,哪个是错误的？</p><ul><li>A 在方法中,修改一个基础类型的参数不会影响原始参数值</li><li>B 在方法中,改变一个对象参数的引用不会影响到原始引用</li><li>C 在方法中,修改一个对象的属性会影响原始对象参数</li><li>D 在方法中,修改集合和<code>Maps</code>的元素不会影响原始集合参数</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点4-多态-编译看左边-运行看右边"><a href="#考点4-多态-编译看左边-运行看右边" class="headerlink" title="考点4 多态 编译看左边 运行看右边"></a>考点4 多态 编译看左边 运行看右边</h1><p>下列代码输出结果为(      )<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;动物可以移动&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    public void move()&#123;</span><br><span class="line">        System.out.println(&quot;狗可以跑和走&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void bark()&#123;</span><br><span class="line">        System.out.println(&quot;狗可以吠叫&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestDog&#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        Animal a &#x3D; new Animal();</span><br><span class="line">        Animal b &#x3D; new Dog(); </span><br><span class="line">        a.move();</span><br><span class="line">        b.move();</span><br><span class="line">        b.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">狗可以跑和走</span><br><span class="line">狗可以吠叫</span><br></pre></td></tr></table></figure></li><li>B<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动物可以移动</span><br><span class="line">动物可以移动</span><br><span class="line">狗可以吠叫</span><br></pre></td></tr></table></figure></li><li>C 运行错误</li><li>D 编译错误</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>假设num已经被创建为一个ArrayList对象,并且最初包含以下整数值:[0,0,4,2,5,0,3,0]。 执行下面的方法numQuest(),最终的输出结果是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; nums;</span><br><span class="line"><span class="comment">//precondition: nums.size() &gt; 0</span></span><br><span class="line"><span class="comment">//nums contains Integer objects</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">numQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    Integer zero = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (k &lt; nums.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.get(k).equals(zero))nums.remove(k);</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A [3, 5, 2, 4, 0, 0, 0, 0]</li><li>B [0, 0, 0, 0, 4, 2, 5, 3]</li><li>C [0, 0, 4, 2, 5, 0, 3, 0]</li><li>D [0, 4, 2, 5, 3]</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>List中的 get ( i )指的是获取下标（索引）为 i 的元素，也就是第 i+1 个元素<br>本题：<br>zero==0，如果get(k)==0,执行remove(k); ;<br> size==8 ; k==0 , 因此第一次remove(0) ，删除索引为0的元素也就是第一个元素0，然后k++, size()—;<br>此时集合元素为 ：[0，4，2，5，0，3，0]<br> size==7; k==1，因此get(1)==4 !=0 , 不执行remove(); k++,因没有删除元素，size()不变，<br>此时集合元素为：[0，4，2，5，0，3，0]<br> size==7;k==2，k++;<br> size==7;k==3，k++;<br> size==7;k==4，get(4)==0，remove(4) ; k++, size()—;<br>此时集合元素为： [0，4，2，5，3，0]<br> size==6;k==5，get(5)==0，remove(5)；k++, size()—;<br>此时集合元素为： [0，4，2，5，3]<br> size==5; k==6 ;退出循环；最终输出此时集合元素为 [0，4，2，5，3] ；<br>一般更改删除集合元素，使用iterator()迭代器，不推荐使用这种；</p><p>此方法的目地就是排除重复元素</p><h1 id="考点6-Math-round四舍五入-舍变小入变大"><a href="#考点6-Math-round四舍五入-舍变小入变大" class="headerlink" title="考点6 Math.round四舍五入 舍变小入变大"></a>考点6 Math.round四舍五入 舍变小入变大</h1><p>Math.round(11.5) 等于多少 (). Math.round(-11.5) 等于多少 (  ).</p><ul><li>A 11 ,-11</li><li>B 11 ,-12</li><li>C 12 ,-11</li><li>D 12 ,-12</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>floor : 意为地板,指向下取整,返回不大于它的最大整数<br>ceil : 意为天花板,指向上取整,返回不小于它的最小整数<br>round: 意为大约,表示”四舍五入”,而四舍五入，入是<strong>往数值大数的方向入</strong>。<br>Math.round(11.5)的结果为12,12＞11.5<br>Math.round(-11.5)的结果为-11。-11＞-11.5</p><h1 id="考点7-Log4j"><a href="#考点7-Log4j" class="headerlink" title="考点7 Log4j"></a>考点7 Log4j</h1><p>下列语句哪一个是不正确的()</p><ul><li>A <code>Log4j</code>支持按分钟为间隔生成新的日志文件</li><li>B <code>Log4j</code>是一个打印日志用的组件</li><li>C <code>Log4j</code>支持按年为间隔生成新的日志文件</li><li>D <code>Log4j</code>的日志打印级别可以在运行时重新设置</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Log4j在运行期间不可重置</p><h1 id="考点8-默认构造器"><a href="#考点8-默认构造器" class="headerlink" title="考点8 默认构造器"></a>考点8 默认构造器</h1><p>It is an important feature of the Java language that it always provides a default constructor to a class.</p><ul><li>A <code>FALSE</code></li><li>B <code>TRUE</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>只有在不显示声明构造方法时，系统才提供默认无参构造方法</p><h1 id="考点9-线程安全集合"><a href="#考点9-线程安全集合" class="headerlink" title="考点9 线程安全集合"></a>考点9 线程安全集合</h1><p>下面哪些具体实现类可以用于存储键,值对,并且方法调用提供了基本的多线程安全支持:()</p><ul><li>A <code>java.util.ConcurrentHashMap</code></li><li>B <code>java.util.Map</code></li><li>C <code>java.util.TreeMap</code></li><li>D <code>java.util.SortMap</code></li><li>E <code>java.util.Hashtable</code></li><li>F <code>java.util.HashMap</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AE</details><h3 id="线程安全的map"><a href="#线程安全的map" class="headerlink" title="线程安全的map"></a>线程安全的map</h3><p>HashTable,<br>SynchronizedMap,<br>ConcurrentHashMap</p><h1 id="考点10-java内存区域"><a href="#考点10-java内存区域" class="headerlink" title="考点10 java内存区域"></a>考点10 java内存区域</h1><p>关于Java内存区域下列说法不正确的有哪些</p><ul><li>A 程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的信号指示器,每个线程都需要一个独立的程序计数器.</li><li>B <code>Java</code>虚拟机栈描述的是<code>java</code>方法执行的内存模型,每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表、<code>类信息</code>、动态链接等信息</li><li>C <code>Java</code>堆是<code>java</code>虚拟机所管理的内存中最大的一块,每个线程都拥有一块内存区域,所有的对象实例以及数组都在这里分配内存。</li><li>D 方法区是各个线程共享的内存区域,它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>B错误. java虚拟机栈没有类信息，<strong>类信息是在方法区</strong>中<br>C错误. java堆<code>线程共享</code>，主要是存放对象实例和数组</p><h1 id="考点11-编译原理-循环优化"><a href="#考点11-编译原理-循环优化" class="headerlink" title="考点11 编译原理 循环优化"></a>考点11 编译原理 循环优化</h1><p>下列哪些方法是针对循环优化进行的</p><ul><li>A 强度削弱</li><li>B 删除归纳变量</li><li>C 删除多余运算</li><li>D 代码外提</li></ul><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>常见的代码优化技术有:复写传播,删除死代码, 强度削弱,归纳变量删除<br>有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>职场就业面试最常问的50题</title>
      <link href="/exam//c17e8611/"/>
      <url>/exam//c17e8611/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c17e8611/#1到10题" class="header_1">1到10题</a>&nbsp;<br><a href="/exam/c17e8611/#Q1请自我介绍一下" class="header_2">Q1请自我介绍一下</a>&nbsp;<br><a href="/exam/c17e8611/#Q2你最大的优点和缺点" class="header_2">Q2你最大的优点和缺点</a>&nbsp;<br><a href="/exam/c17e8611/#Q3你是否能够接受加班" class="header_2">Q3你是否能够接受加班?</a>&nbsp;<br><a href="/exam/c17e8611/#Q4你对薪资的要求" class="header_2">Q4你对薪资的要求</a>&nbsp;<br><a href="/exam/c17e8611/#Q5在五年的时间内-你的职业规划" class="header_2">Q5在五年的时间内,你的职业规划</a>&nbsp;<br><a href="/exam/c17e8611/#Q6我们为什么要聘用你" class="header_2">Q6我们为什么要聘用你</a>&nbsp;<br><a href="/exam/c17e8611/#Q7你对于我们公司了解多少" class="header_2">Q7你对于我们公司了解多少</a>&nbsp;<br><a href="/exam/c17e8611/#Q8你为什么愿意到我们公司来工作" class="header_2">Q8你为什么愿意到我们公司来工作</a>&nbsp;<br><a href="/exam/c17e8611/#Q9就你申请的这个职位-你认为自己欠缺什么" class="header_2">Q9就你申请的这个职位,你认为自己欠缺什么</a>&nbsp;<br><a href="/exam/c17e8611/#Q10在完成某项顶工作时-你觉得领导的指示不对-你会怎么做" class="header_2">Q10在完成某项顶工作时,你觉得领导的指示不对,你会怎么做?</a>&nbsp;<br><a href="/exam/c17e8611/#11到20题" class="header_1">11到20题</a>&nbsp;<br><a href="/exam/c17e8611/#Q11你缺乏工作经验-如何能胜任这项工作" class="header_2">Q11你缺乏工作经验,如何能胜任这项工作?</a>&nbsp;<br><a href="/exam/c17e8611/#Q12如果我们没有录取你-你下步有什么打算" class="header_2">Q12如果我们没有录取你,你下步有什么打算?</a>&nbsp;<br><a href="/exam/c17e8611/#Q13如果你的工作出现失误-给公司造成损失-你认为该怎么办" class="header_2">Q13如果你的工作出现失误,给公司造成损失,你认为该怎么办?</a>&nbsp;<br><a href="/exam/c17e8611/#Q14如果你的工作成绩很突出;得到领导肯定-但却发现同事们因此孤立你-你如何处理" class="header_2">Q14如果你的工作成绩很突出;得到领导肯定,但却发现同事们因此孤立你,你如何处理?</a>&nbsp;<br><a href="/exam/c17e8611/#Q15工作中如果难以和同事、上司相处-你该怎么办" class="header_2">Q15工作中如果难以和同事、上司相处,你该怎么办?</a>&nbsp;<br><a href="/exam/c17e8611/#Q16你何时可以入职" class="header_2">Q16你何时可以入职?</a>&nbsp;<br><a href="/exam/c17e8611/#Q17你选离职的原因是什么" class="header_2">Q17你选离职的原因是什么?</a>&nbsp;<br><a href="/exam/c17e8611/#Q18你并排毕业于名牌学校" class="header_2">Q18你并排毕业于名牌学校?</a>&nbsp;<br><a href="/exam/c17e8611/#Q19我怎样相信你是这个职位最好的人选呢" class="header_2">Q19我怎样相信你是这个职位最好的人选呢?</a>&nbsp;<br><a href="/exam/c17e8611/#Q20为什么你还没有找到工作" class="header_2">Q20为什么你还没有找到工作?</a>&nbsp;<br><a href="/exam/c17e8611/#21到30题" class="header_1">21到30题</a>&nbsp;<br><a href="/exam/c17e8611/#Q21你认为你在学校属于好学生吗" class="header_2">Q21你认为你在学校属于好学生吗?</a>&nbsp;<br><a href="/exam/c17e8611/#Q22你在大学里的学习成绩、不敢恭维-你如何解释呢" class="header_2">Q22你在大学里的学习成绩、不敢恭维,你如何解释呢?</a>&nbsp;<br><a href="/exam/c17e8611/#Q23假如我们聘用你-但有时需要做些倒茶端水的杂务-你会反对吗" class="header_2">Q23假如我们聘用你,但有时需要做些倒茶端水的杂务,你会反对吗?</a>&nbsp;<br><a href="/exam/c17e8611/#Q24假如你流落荒岛-可以拥有一本书-你会选择哪一本-为什么" class="header_2">Q24假如你流落荒岛,可以拥有一本书,你会选择哪一本?为什么?</a>&nbsp;<br><a href="/exam/c17e8611/#Q25你有哪些兴趣爱好" class="header_2">Q25你有哪些兴趣爱好?</a>&nbsp;<br><a href="/exam/c17e8611/#Q26你人生中最令你受挫的事情是什么" class="header_2">Q26你人生中最令你受挫的事情是什么?</a>&nbsp;<br><a href="/exam/c17e8611/#Q27你朋友对你的评价" class="header_2">Q27你朋友对你的评价?</a>&nbsp;<br><a href="/exam/c17e8611/#Q28谈谈你过去做过的成功案例" class="header_2">Q28谈谈你过去做过的成功案例?</a>&nbsp;<br><a href="/exam/c17e8611/#Q29如果你做的一顶工作受到上级领导的表扬-但你主管领导却说是他做的-你该怎样" class="header_2">Q29如果你做的一顶工作受到上级领导的表扬,但你主管领导却说是他做的,你该怎样?</a>&nbsp;<br><a href="/exam/c17e8611/#Q30你能为我们公司带来什么呢" class="header_2">Q30你能为我们公司带来什么呢?</a>&nbsp;<br><a href="/exam/c17e8611/#31到40题" class="header_1">31到40题</a>&nbsp;<br><a href="/exam/c17e8611/#Q31喜欢这份工作的哪点" class="header_2">Q31喜欢这份工作的哪点?</a>&nbsp;<br><a href="/exam/c17e8611/#Q32说你对行业、技术发展趋势的看法" class="header_2">Q32说你对行业、技术发展趋势的看法?</a>&nbsp;<br><a href="/exam/c17e8611/#Q33说说你的家庭" class="header_2">Q33说说你的家庭?</a>&nbsp;<br><a href="/exam/c17e8611/#Q34谈你对别槽的看法" class="header_2">Q34谈你对别槽的看法?</a>&nbsp;<br><a href="/exam/c17e8611/#Q35你工作的期望与目标" class="header_2">Q35你工作的期望与目标?</a>&nbsp;<br><a href="/exam/c17e8611/#Q36如果你被录用了-但工作一段你发现你并不适合这个职位-你怎么办" class="header_2">Q36如果你被录用了,但工作一段你发现你并不适合这个职位,你怎么办?</a>&nbsp;<br><a href="/exam/c17e8611/#Q37你和别人发生过争执吗-你是怎样解决的" class="header_2">Q37你和别人发生过争执吗?你是怎样解决的?</a>&nbsp;<br><a href="/exam/c17e8611/#Q38你会如何处理别人的批评" class="header_2">Q38你会如何处理别人的批评?</a>&nbsp;<br><a href="/exam/c17e8611/#Q39你很努力-但客户始终不满意并投诉-你怎么做" class="header_2">Q39你很努力,但客户始终不满意并投诉,你怎么做?</a>&nbsp;<br><a href="/exam/c17e8611/#Q40对这项工作-你有哪些可预见的困难" class="header_2">Q40对这项工作,你有哪些可预见的困难?</a>&nbsp;<br><a href="/exam/c17e8611/#41到50题" class="header_1">41到50题</a>&nbsp;<br><a href="/exam/c17e8611/#Q41如果我录用你-你将怎样开展工作" class="header_2">Q41如果我录用你,你将怎样开展工作?</a>&nbsp;<br><a href="/exam/c17e8611/#Q42你希望与什么样的上级共事" class="header_2">Q42你希望与什么样的上级共事?</a>&nbsp;<br><a href="/exam/c17e8611/#Q43怎样看待学历和能力" class="header_2">Q43怎样看待学历和能力?</a>&nbsp;<br><a href="/exam/c17e8611/#Q44你做的哪件事最自豪" class="header_2">Q44你做的哪件事最自豪?</a>&nbsp;<br><a href="/exam/c17e8611/#Q45假如你要送同学去机场可单位临时有事非你办不可-怎么办" class="header_2">Q45假如你要送同学去机场可单位临时有事非你办不可,怎么办?</a>&nbsp;<br><a href="/exam/c17e8611/#Q46为什么选择这个职务" class="header_2">Q46为什么选择这个职务?</a>&nbsp;<br><a href="/exam/c17e8611/#Q47对这个职务的期许" class="header_2">Q47对这个职务的期许?</a>&nbsp;<br><a href="/exam/c17e8611/#Q48谈谈如何适应新环境" class="header_2">Q48谈谈如何适应新环境?</a>&nbsp;<br><a href="/exam/c17e8611/#Q49除了本公司外-还应聘了哪些公司" class="header_2">Q49除了本公司外,还应聘了哪些公司?</a>&nbsp;<br><a href="/exam/c17e8611/#Q50请问你还有问题要问吗" class="header_2">Q50请问你还有问题要问吗?</a>&nbsp;<br><a href="/exam/c17e8611/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="1到10题"><a href="#1到10题" class="headerlink" title="1到10题"></a>1到10题</h1><h2 id="Q1请自我介绍一下"><a href="#Q1请自我介绍一下" class="headerlink" title="Q1请自我介绍一下"></a>Q1请自我介绍一下</h2><p>不要只是简单读简历,企业最希望通过这个问题了解你是否能胜任工作,要介绍自己最强的技能、最深入硏究的领域、个性中最积极的部分等,简短但要能突出自己的能力。</p><h2 id="Q2你最大的优点和缺点"><a href="#Q2你最大的优点和缺点" class="headerlink" title="Q2你最大的优点和缺点"></a>Q2你最大的优点和缺点</h2><p>优点可以答沉着冷静、条理清楚、立场坚定、顽强向上、乐于助人和关心他人、适应能力和幽默感、乐观和友爱等;从自己的优点说起,中间加一些小缺点,最后再把问题转回到优点上,突出优点的部分。</p><h2 id="Q3你是否能够接受加班"><a href="#Q3你是否能够接受加班" class="headerlink" title="Q3你是否能够接受加班?"></a>Q3你是否能够接受加班?</h2><p>你可以回答:“我愿额接受挑战在自己责任范围内的工作,不能算是加班。”<br>但是也要强调,会努力提高工作效率,因为能力低、完成工作慢造成的加班,并不是一件好事。</p><h2 id="Q4你对薪资的要求"><a href="#Q4你对薪资的要求" class="headerlink" title="Q4你对薪资的要求"></a>Q4你对薪资的要求</h2><p>如果你要求太低,那显然贬低自己的能力;<br>如果要求太高,又会显得公司受用不起。<br>HR第一次提出的价钱往往是他们所能给予的最高价钱,他们问你只不过想证实一下这笔钱是否足以引起你对该职位的兴趣。</p><h2 id="Q5在五年的时间内-你的职业规划"><a href="#Q5在五年的时间内-你的职业规划" class="headerlink" title="Q5在五年的时间内,你的职业规划"></a>Q5在五年的时间内,你的职业规划</h2><p>最普通的回答是“我准备在技术领域有所作为”或“我希望能按公司的管理思路发展”,也可以说出一些你感兴趣的职位。HR总是喜欢有进取心的应聘者。</p><h2 id="Q6我们为什么要聘用你"><a href="#Q6我们为什么要聘用你" class="headerlink" title="Q6我们为什么要聘用你"></a>Q6我们为什么要聘用你</h2><p>测试你的沉着与自信。可以根据自己的实际情况和优势加以说明,而一个简短、有礼貌但非常笃定的收尾也很重要.<br>比如,“我能做好我要做的事情”,“我相信自己”。</p><h2 id="Q7你对于我们公司了解多少"><a href="#Q7你对于我们公司了解多少" class="headerlink" title="Q7你对于我们公司了解多少"></a>Q7你对于我们公司了解多少</h2><p>面试之前,一定要做好功课,可以在网上查一下该公司<strong>主营业务</strong>,<strong>发展方向</strong>、<strong>近期重大战略调整</strong>等。</p><h2 id="Q8你为什么愿意到我们公司来工作"><a href="#Q8你为什么愿意到我们公司来工作" class="headerlink" title="Q8你为什么愿意到我们公司来工作"></a>Q8你为什么愿意到我们公司来工作</h2><p>可以回答一些详细的原因,像“贵公司的高技术开发环境很吸引我”、<br>“贵公司在近几年来在市场上很有竞争力”、<br>“贵公司能够给我提供一个与众不同的发展道路”。<br>这都显示出你已经做了一些调查,也说明你有较为具体的职业规划。</p><h2 id="Q9就你申请的这个职位-你认为自己欠缺什么"><a href="#Q9就你申请的这个职位-你认为自己欠缺什么" class="headerlink" title="Q9就你申请的这个职位,你认为自己欠缺什么"></a>Q9就你申请的这个职位,你认为自己欠缺什么</h2><p>你可以重新强调自己的优势,然后说“对于这个职位和我的能力来说,我相信自己是可以胜任的,只是缺乏经验。我的学习能力很强,我相信可以很快融入公司的企业文化,进入工作状态。”</p><h2 id="Q10在完成某项顶工作时-你觉得领导的指示不对-你会怎么做"><a href="#Q10在完成某项顶工作时-你觉得领导的指示不对-你会怎么做" class="headerlink" title="Q10在完成某项顶工作时,你觉得领导的指示不对,你会怎么做?"></a>Q10在完成某项顶工作时,你觉得领导的指示不对,你会怎么做?</h2><p>原则上我会尊重和服从领导的工作安排,私底下以请教的口吻表达自己的想法。如果领导没有采纳我的建议,我同样会按要求认真完成工作,但如果领导要求的方式违背原则,我会提出反对意见。</p><h1 id="11到20题"><a href="#11到20题" class="headerlink" title="11到20题"></a>11到20题</h1><h2 id="Q11你缺乏工作经验-如何能胜任这项工作"><a href="#Q11你缺乏工作经验-如何能胜任这项工作" class="headerlink" title="Q11你缺乏工作经验,如何能胜任这项工作?"></a>Q11你缺乏工作经验,如何能胜任这项工作?</h2><p>要体现出诚思、机智、果敢及敬业。如“作为应届毕业生,在工作经验方面的确会有所欠缺,因此在读书期间我一直利用各种机会在这个行业里做兼职和实习。实际工作远比书本复杂,但我有较强的责任心、适应能力和学习能力,而且很勤奋,所以是一个优秀的实习生,也积累了一些经验。请放心,学校所学及兼职的工作经验使我一定能胜任这个职位。”</p><h2 id="Q12如果我们没有录取你-你下步有什么打算"><a href="#Q12如果我们没有录取你-你下步有什么打算" class="headerlink" title="Q12如果我们没有录取你,你下步有什么打算?"></a>Q12如果我们没有录取你,你下步有什么打算?</h2><p>可以表示会认直总结这次面试的经验,找原因,找差距,但也不会就此气馁,会把这次的不成功当作历练积累</p><h2 id="Q13如果你的工作出现失误-给公司造成损失-你认为该怎么办"><a href="#Q13如果你的工作出现失误-给公司造成损失-你认为该怎么办" class="headerlink" title="Q13如果你的工作出现失误,给公司造成损失,你认为该怎么办?"></a>Q13如果你的工作出现失误,给公司造成损失,你认为该怎么办?</h2><p>首先强调,本意是为公司努力工作,如果造成经济损失,首要的是想方设法弥补或挽回。如果确实是工作失误所致,愿意承担责任。同时应该补充,之后会总结经验教训。</p><h2 id="Q14如果你的工作成绩很突出-得到领导肯定-但却发现同事们因此孤立你-你如何处理"><a href="#Q14如果你的工作成绩很突出-得到领导肯定-但却发现同事们因此孤立你-你如何处理" class="headerlink" title="Q14如果你的工作成绩很突出;得到领导肯定,但却发现同事们因此孤立你,你如何处理?"></a>Q14如果你的工作成绩很突出;得到领导肯定,但却发现同事们因此孤立你,你如何处理?</h2><p>以后会更加努力;<br>检讨自己是不是忽略了与同事的交往,或者有什么事情做得不妥当,产生了误会;<br>会更注意工作方法,多换位思考。</p><h2 id="Q15工作中如果难以和同事、上司相处-你该怎么办"><a href="#Q15工作中如果难以和同事、上司相处-你该怎么办" class="headerlink" title="Q15工作中如果难以和同事、上司相处,你该怎么办?"></a>Q15工作中如果难以和同事、上司相处,你该怎么办?</h2><p>会服从领号指挥,配合同事的工作如果发生问题,<br>首先从自身找原因,努力改正;<br>如果难以发现原因,会积极和他们沟通,请他们指出我的不足;<br>即使在一段时间内,领导和同事对我不理解,也会做好本职工作,以诚待人。</p><h2 id="Q16你何时可以入职"><a href="#Q16你何时可以入职" class="headerlink" title="Q16你何时可以入职?"></a>Q16你何时可以入职?</h2><p>最好回答“如果被录用的话,到职日可按公司要求的时间入职”。如果做不到,可以告知用人单位,但需要表明愿意在能力所及范围内尽快到岗。</p><h2 id="Q17你选离职的原因是什么"><a href="#Q17你选离职的原因是什么" class="headerlink" title="Q17你选离职的原因是什么?"></a>Q17你选离职的原因是什么?</h2><p>不能表现出对上一份工作的怨言,最好从自身发展来表明离职原因,比如,遭遇职业的天花板,或前份工作与自己的长期职业生涯规划不合等,也可以表明应聘的新职位对自己是很好的机会。</p><h2 id="Q18你并排毕业于名牌学校"><a href="#Q18你并排毕业于名牌学校" class="headerlink" title="Q18你并排毕业于名牌学校?"></a>Q18你并排毕业于名牌学校?</h2><p>不卑不亢地回应,比如,我认为是否毕业于名牌院校并不是最重要的,重要的是我目前掌握的技能完全可以胜任工作。而且我的经历让我比一些名牌院校毕业生的动手能力更强,我想我更适合这个职位</p><h2 id="Q19我怎样相信你是这个职位最好的人选呢"><a href="#Q19我怎样相信你是这个职位最好的人选呢" class="headerlink" title="Q19我怎样相信你是这个职位最好的人选呢?"></a>Q19我怎样相信你是这个职位最好的人选呢?</h2><p>根据要求,说出自己应聘的优势。比如,“根据这个职位的性质和我们刚才的谈话,我推断您需要的是工作积极、能够设定目标,不惧怕挑战的人,我就具有这些品质”。然后再介绍一些经历来说明。</p><h2 id="Q20为什么你还没有找到工作"><a href="#Q20为什么你还没有找到工作" class="headerlink" title="Q20为什么你还没有找到工作?"></a>Q20为什么你还没有找到工作?</h2><p>没有找到工作并不是因为能力不行,而是在寻找更好的机会。比如,“我正在谨慎选择我的工作,也有一些工作可以选择,但并不是非常满意</p><h1 id="21到30题"><a href="#21到30题" class="headerlink" title="21到30题"></a>21到30题</h1><h2 id="Q21你认为你在学校属于好学生吗"><a href="#Q21你认为你在学校属于好学生吗" class="headerlink" title="Q21你认为你在学校属于好学生吗?"></a>Q21你认为你在学校属于好学生吗?</h2><p>如果成绩好,可以说:“是的,但判断一个学生是不是好学生有很多标准,还包括思想道德、实践经验、团队精神、沟通能力等我是一个全面发展的学生。”<br>如果成绩不尽理想可以说:“我认为好学生的标准是多元化的我的学习成绩还可以,在其他方面我的表现也很突出,比如我去很多地方实习过,我在学生会组织过许多活动,有比较强的团队合作精神和组织能力。”</p><h2 id="Q22你在大学里的学习成绩、不敢恭维-你如何解释呢"><a href="#Q22你在大学里的学习成绩、不敢恭维-你如何解释呢" class="headerlink" title="Q22你在大学里的学习成绩、不敢恭维,你如何解释呢?"></a>Q22你在大学里的学习成绩、不敢恭维,你如何解释呢?</h2><p>这类问题往往是一种“压追法”的面试技巧,提到的弱点不是问题关键所在,HR是为了看你在压力下如何反应,所以应沉着应付,想办法扭转劣势,表现出自己的急才与修养。</p><h2 id="Q23假如我们聘用你-但有时需要做些倒茶端水的杂务-你会反对吗"><a href="#Q23假如我们聘用你-但有时需要做些倒茶端水的杂务-你会反对吗" class="headerlink" title="Q23假如我们聘用你,但有时需要做些倒茶端水的杂务,你会反对吗?"></a>Q23假如我们聘用你,但有时需要做些倒茶端水的杂务,你会反对吗?</h2><p>这是一个试探性问题,目的是判断你对工作的态度。可以回答:“如果需要,我不会斤斤计较,这些杂务只是我的工作内容的小部分而已</p><h2 id="Q24假如你流落荒岛-可以拥有一本书-你会选择哪一本-为什么"><a href="#Q24假如你流落荒岛-可以拥有一本书-你会选择哪一本-为什么" class="headerlink" title="Q24假如你流落荒岛,可以拥有一本书,你会选择哪一本?为什么?"></a>Q24假如你流落荒岛,可以拥有一本书,你会选择哪一本?为什么?</h2><p>这是假设性问题,来测试应试者的想象力、解决问题的能力,目的看你有没有急才,思想有没有条理,说清理由即可。</p><h2 id="Q25你有哪些兴趣爱好"><a href="#Q25你有哪些兴趣爱好" class="headerlink" title="Q25你有哪些兴趣爱好?"></a>Q25你有哪些兴趣爱好?</h2><p>回答的兴趣爱好可以体现自己积极主动的性格、团队合作的精神、深入学习的意愿等。</p><h2 id="Q26你人生中最令你受挫的事情是什么"><a href="#Q26你人生中最令你受挫的事情是什么" class="headerlink" title="Q26你人生中最令你受挫的事情是什么?"></a>Q26你人生中最令你受挫的事情是什么?</h2><p>这个问题是为了解你对挫折的容忍度及调节方式。可以说让你受挫的经历,但更重要的是你如何处理、克服或改变。</p><h2 id="Q27你朋友对你的评价"><a href="#Q27你朋友对你的评价" class="headerlink" title="Q27你朋友对你的评价?"></a>Q27你朋友对你的评价?</h2><p>“我的朋友都说我是一个可以信赖的人。因为我一旦答应别人的事情,就一定会做到。如果我做不到,我就不会轻易许诺\”;或“我的朋友都说我是一个比较随和的人,与不同的人都可以友好相处,我总是能站在别人的角度考虑问题。</p><h2 id="Q28谈谈你过去做过的成功案例"><a href="#Q28谈谈你过去做过的成功案例" class="headerlink" title="Q28谈谈你过去做过的成功案例?"></a>Q28谈谈你过去做过的成功案例?</h2><p>举一个你最有把握的例子,把来龙去脉说清楚。切忌夸大其词,把别人的功劳说成自己的。</p><h2 id="Q29如果你做的一顶工作受到上级领导的表扬-但你主管领导却说是他做的-你该怎样"><a href="#Q29如果你做的一顶工作受到上级领导的表扬-但你主管领导却说是他做的-你该怎样" class="headerlink" title="Q29如果你做的一顶工作受到上级领导的表扬,但你主管领导却说是他做的,你该怎样?"></a>Q29如果你做的一顶工作受到上级领导的表扬,但你主管领导却说是他做的,你该怎样?</h2><p>首先,理性地看待这个事情,不能因为这件事影响工作态度。而且平时工作中,领导确实帮助过我,这项工作理应有领导的功劳。但我还是会在适当的时候找领导委婉表达态度,相信领导会明事理。</p><h2 id="Q30你能为我们公司带来什么呢"><a href="#Q30你能为我们公司带来什么呢" class="headerlink" title="Q30你能为我们公司带来什么呢?"></a>Q30你能为我们公司带来什么呢?</h2><p>应再次重复自己的优势,然后说:“就我的能力,我可以给组织带来高效率和更多的收益”。</p><h1 id="31到40题"><a href="#31到40题" class="headerlink" title="31到40题"></a>31到40题</h1><h2 id="Q31喜欢这份工作的哪点"><a href="#Q31喜欢这份工作的哪点" class="headerlink" title="Q31喜欢这份工作的哪点?"></a>Q31喜欢这份工作的哪点?</h2><p>不要太直接地把自己的心里话说出来,如果能仔细思考这份工作的与众不同之处,会大大加分。</p><h2 id="Q32说你对行业、技术发展趋势的看法"><a href="#Q32说你对行业、技术发展趋势的看法" class="headerlink" title="Q32说你对行业、技术发展趋势的看法?"></a>Q32说你对行业、技术发展趋势的看法?</h2><p>面试前可以在网上查找该<strong>行业</strong>、该<strong>企业</strong>的相关信息,做足功课,包括<strong>公司各个部门发展情况</strong>。企业欢迎的是“知己”,而不是“盲人</p><h2 id="Q33说说你的家庭"><a href="#Q33说说你的家庭" class="headerlink" title="Q33说说你的家庭?"></a>Q33说说你的家庭?</h2><p>可以回答:虽然我的父母亲都是普通人,但是从小我就看到父亲起早贪黑,工作认真负责,我母亲为人善良,特别乐于助人,父母的一言一行一直在教导我做人做事的道理。</p><h2 id="Q34谈你对别槽的看法"><a href="#Q34谈你对别槽的看法" class="headerlink" title="Q34谈你对别槽的看法?"></a>Q34谈你对别槽的看法?</h2><p>正常的跳槽能促进人才合理流动应该支持;<br>频繁的跳槽对单位和个人双方都不利,应该反对。</p><h2 id="Q35你工作的期望与目标"><a href="#Q35你工作的期望与目标" class="headerlink" title="Q35你工作的期望与目标?"></a>Q35你工作的期望与目标?</h2><p>回答最好有<strong>针对性</strong>,如应聘业务员,“我的目标是成为一个超级业务员,将公司的产品广泛推销出去,达到最好的业绩成效。”</p><h2 id="Q36如果你被录用了-但工作一段你发现你并不适合这个职位-你怎么办"><a href="#Q36如果你被录用了-但工作一段你发现你并不适合这个职位-你怎么办" class="headerlink" title="Q36如果你被录用了,但工作一段你发现你并不适合这个职位,你怎么办?"></a>Q36如果你被录用了,但工作一段你发现你并不适合这个职位,你怎么办?</h2><p>首先强调,申请这个职位是你经过了<strong>深思熟虑和全面了解</strong>的决定,所谓的不适应可能是业务不熟练导致的。而后表明态度,如果发现短时间内能力与职位有差距,你会不断学习,虚心向领导和同事请教经验,力争减少差距。</p><h2 id="Q37你和别人发生过争执吗-你是怎样解决的"><a href="#Q37你和别人发生过争执吗-你是怎样解决的" class="headerlink" title="Q37你和别人发生过争执吗?你是怎样解决的?"></a>Q37你和别人发生过争执吗?你是怎样解决的?</h2><p>千万不要说任何人的过错,成功解决矛盾是一个协作团体中成员所必备的能力,HR希望看到你<strong>成熟且乐于奉献</strong>。在没有外界干涉的情况下,通过妥协的方式来解决,是较好的答案。</p><h2 id="Q38你会如何处理别人的批评"><a href="#Q38你会如何处理别人的批评" class="headerlink" title="Q38你会如何处理别人的批评?"></a>Q38你会如何处理别人的批评?</h2><p>沉默是金,不必说什么,否则情况更糟,我会等大家冷静下来再讨论,也会接受建设性的批评。</p><h2 id="Q39你很努力-但客户始终不满意并投诉-你怎么做"><a href="#Q39你很努力-但客户始终不满意并投诉-你怎么做" class="headerlink" title="Q39你很努力,但客户始终不满意并投诉,你怎么做?"></a>Q39你很努力,但客户始终不满意并投诉,你怎么做?</h2><p>首先,我会保持冷静,积极应对;<br>其次,我会反思原因,一是看自己在解决问题上是否有考虑不周之处,二是看客户是否不了解情况,三是看客户是否故意刁难;<br>再次如果自己确有不周,按照规定作出合理安排;<br>如果是客户不了解情况,我会做解释;<br>如果是客户的要求不符合规定,我会明确指出;<br>把处理情况向领导汇报,不会因客户投诉而丧失工作热情。</p><h2 id="Q40对这项工作-你有哪些可预见的困难"><a href="#Q40对这项工作-你有哪些可预见的困难" class="headerlink" title="Q40对这项工作,你有哪些可预见的困难?"></a>Q40对这项工作,你有哪些可预见的困难?</h2><p>不宜直接说出具体困难,否则可能令HR怀疑你能力。可尝试迂回战术,说出对困难所持有的态度:</p><ul><li>工作中出现一些困难是难免的,但是只要有坚忍不拔的毅力、良好的作精神以及周密而充分的准备,任何困难都可以克服。</li></ul><h1 id="41到50题"><a href="#41到50题" class="headerlink" title="41到50题"></a>41到50题</h1><h2 id="Q41如果我录用你-你将怎样开展工作"><a href="#Q41如果我录用你-你将怎样开展工作" class="headerlink" title="Q41如果我录用你,你将怎样开展工作?"></a>Q41如果我录用你,你将怎样开展工作?</h2><p>最好不要直接说出具体办法,而是“首先听取领导的要求,然后就有关情况进行了解,接下来制定工作计划并报领导批准,最后根据计划开展工作”</p><h2 id="Q42你希望与什么样的上级共事"><a href="#Q42你希望与什么样的上级共事" class="headerlink" title="Q42你希望与什么样的上级共事?"></a>Q42你希望与什么样的上级共事?</h2><p>最好回避对上级具体的希望,多谈对自己的要求。如“作为刚步入社会的新人,我应该多要求自己尽快适应环境,而不应该对环境提要求,只要能发挥能力,做好工作即可<br>或“希望我的上级能够在工作中对我多指导对我工作中的错误能够立即指出。”</p><h2 id="Q43怎样看待学历和能力"><a href="#Q43怎样看待学历和能力" class="headerlink" title="Q43怎样看待学历和能力?"></a>Q43怎样看待学历和能力?</h2><p>可以试这样回答“我认为一个人能力的高低,不是看你学了多少知识,而是看你在这个领域上如何发挥。学历只是进入一个企业的敲门砖,工作能力直接决定其职场命运”。</p><h2 id="Q44你做的哪件事最自豪"><a href="#Q44你做的哪件事最自豪" class="headerlink" title="Q44你做的哪件事最自豪?"></a>Q44你做的哪件事最自豪?</h2><p>描述一件能体现你潜在能力的事情</p><h2 id="Q45假如你要送同学去机场可单位临时有事非你办不可-怎么办"><a href="#Q45假如你要送同学去机场可单位临时有事非你办不可-怎么办" class="headerlink" title="Q45假如你要送同学去机场可单位临时有事非你办不可,怎么办?"></a>Q45假如你要送同学去机场可单位临时有事非你办不可,怎么办?</h2><p>如果时间能错开最好<br>如果工作不是很紧急,跟领导打声招呼,先去机场然后回来加班;<br>如果工作很紧急,试试能否请其他同事帮忙,实在无法平衡,就打电话给朋友解释一下。</p><h2 id="Q46为什么选择这个职务"><a href="#Q46为什么选择这个职务" class="headerlink" title="Q46为什么选择这个职务?"></a>Q46为什么选择这个职务?</h2><p>表明这一职务一直是自己的兴趣和专长,也累积了一定的经验及人脉,相信自己一定能胜任。<br>可以适时举出过去取得的成绩,但避免过于夸张或流于炫耀。</p><h2 id="Q47对这个职务的期许"><a href="#Q47对这个职务的期许" class="headerlink" title="Q47对这个职务的期许?"></a>Q47对这个职务的期许?</h2><p>说明自己希望能借此发挥所学及专长同时也吸收公司在这方面的经验。</p><h2 id="Q48谈谈如何适应新环境"><a href="#Q48谈谈如何适应新环境" class="headerlink" title="Q48谈谈如何适应新环境?"></a>Q48谈谈如何适应新环境?</h2><p>遵守规章制度,不迟到不早退,不擅自离岗;<br>根据领导指示和工作安排,制定工作计划,提前预备,并按计划完成;<br>多请示并及时汇报,遇到不明白的要虚心请教;<br>多学习,努力提高自己的业务水平。</p><h2 id="Q49除了本公司外-还应聘了哪些公司"><a href="#Q49除了本公司外-还应聘了哪些公司" class="headerlink" title="Q49除了本公司外,还应聘了哪些公司?"></a>Q49除了本公司外,还应聘了哪些公司?</h2><p>就算不便说出公司名称,也应回答“销售同种产品的公司”,如果应聘的其他公司是不同<strong>业界</strong>,容易让HR觉得你求职意向不明确。</p><h2 id="Q50请问你还有问题要问吗"><a href="#Q50请问你还有问题要问吗" class="headerlink" title="Q50请问你还有问题要问吗?"></a>Q50请问你还有问题要问吗?</h2><p>不要说没有问题,<br>可以将没有机会提的问题提出来,<br>可以强调你没有机会谈到的个人优势,<br>可以询问何时能得到面试结果,也可以借机表达“我很想得到这份工作,我完全能够胜任,请给我这个机会”。<br>最后,记得跟HR握手致谢。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.weibo.cn/detail/4448391272434927" target="_blank" rel="noopener">https://m.weibo.cn/detail/4448391272434927</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月12日 java1</title>
      <link href="/exam//149c92c5/"/>
      <url>/exam//149c92c5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/149c92c5/#考点1-GUI" class="header_1">考点1 GUI</a>&nbsp;<br><a href="/exam/149c92c5/#考点2-JDBC" class="header_1">考点2 JDBC</a>&nbsp;<br><a href="/exam/149c92c5/#考点3-EJB" class="header_1">考点3 EJB</a>&nbsp;<br><a href="/exam/149c92c5/#考点4-多线程" class="header_1">考点4 多线程</a>&nbsp;<br><a href="/exam/149c92c5/#考点5-线程生命周期" class="header_1">考点5 线程生命周期</a>&nbsp;<br><a href="/exam/149c92c5/#考点6-标识符命名" class="header_1">考点6 标识符命名</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-GUI"><a href="#考点1-GUI" class="headerlink" title="考点1 GUI"></a>考点1 GUI</h1><p>AWT 中用来表示文本框的类是 ( )</p><ul><li>A <code>TextField</code></li><li>B <code>Menu</code></li><li>C <code>Label</code></li><li>D <code>List</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点2-JDBC"><a href="#考点2-JDBC" class="headerlink" title="考点2 JDBC"></a>考点2 JDBC</h1><p>下面哪个不是标准Statement类？</p><ul><li>A <code>Statement</code></li><li>B <code>PreparedStatement</code></li><li>C <code>CallableStatement</code></li><li>D <code>BatchedStatement</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p><code>Statement</code>在<code>JDBC</code>中相当于<code>SQL</code>语句的载体<br>A,<code>Statement</code>是最基本的用法,采用字符串拼接的方式,存在注入漏洞<br>B,<code>PreparedStatement</code>对<code>Statement</code>中的<code>SQL</code>语句进行预编译,同时检查合法性,效率高<br>C,<code>CallableStatement</code>接口扩展<br><code>PreparedStatement</code>,用来调用存储过程,它提供了对输出和输入/输出参数的支持。<code>CallableStatement</code> 接口还具有对<br><code>PreparedStatement</code> 接口提供的输入参数的支持。<br>D,不是标准的<code>Statement</code>类</p><h1 id="考点3-EJB"><a href="#考点3-EJB" class="headerlink" title="考点3 EJB"></a>考点3 EJB</h1><p>下列说法正确的是()</p><ul><li>A <code>WebLogic</code>中开发消息<code>Bean</code>的<code>non</code>－<code>persistent</code> 方式可以保证消息的可靠</li><li>B <code>EJB</code>容器发生错误,<code>non</code>－<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li><li>C <code>EJB</code>容器发生错误,<code>persistent</code>方式下<code>JMS</code>容器仍然会将消息发送</li><li>D <code>EJB</code>容器发生错误,两种方式下<code>JMS</code>容器仍会在<code>MDB</code>可用的时候将消息发送</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点4-多线程"><a href="#考点4-多线程" class="headerlink" title="考点4 多线程"></a>考点4 多线程</h1><p>假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量,则线程 1 和线程 2 同时执行下面的代码,最终 a 的结果不可能是()<br>boolean isOdd = false;<br>for(int i=1;i&lt;=2;++i)<br>{<br>if(i%2==1)isOdd = true;<br>else isOdd = false;<br>a+=i*(isOdd?1:-1);<br>}</p><ul><li>A -1</li><li>B -2</li><li>C 0</li><li>D 1</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点5-线程生命周期"><a href="#考点5-线程生命周期" class="headerlink" title="考点5 线程生命周期"></a>考点5 线程生命周期</h1><p>在Java线程状态转换时,下列转换不可能发生的有()？</p><ul><li>A 初始态-&gt;运行态</li><li>B 就绪态-&gt;运行态</li><li>C 阻塞态-&gt;运行态</li><li>D 运行态-&gt;就绪态</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p><img src="https://uploadfiles.nowcoder.com/images/20180228/8843251_1519785902007_ACED241801E307EE7A39612F85A94EBF" alt="图片"></p><h1 id="考点6-标识符命名"><a href="#考点6-标识符命名" class="headerlink" title="考点6 标识符命名"></a>考点6 标识符命名</h1><p>在java中,下列标识符不合法的有( )</p><ul><li>A <code>new</code></li><li>B $<code>Usdollars</code></li><li>C 1234</li><li>D <code>car.taxi</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACD</details><ul><li>字母数字下划线美元符</li><li>数字不能开头</li><li>不能是关键字</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月10日 java3</title>
      <link href="/exam//fe6723d4/"/>
      <url>/exam//fe6723d4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/fe6723d4/#考点1-数组声明" class="header_1">考点1 数组声明</a>&nbsp;<br><a href="/exam/fe6723d4/#考点2-异常处理" class="header_1">考点2 异常处理</a>&nbsp;<br><a href="/exam/fe6723d4/#考点3-异常继承树" class="header_1">考点3 异常继承树</a>&nbsp;<br><a href="/exam/fe6723d4/#考点4-数据表述范围-值传递" class="header_1">考点4 数据表述范围 值传递</a>&nbsp;<br><a href="/exam/fe6723d4/#考点5-设计模式-单例模式" class="header_1">考点5 设计模式 单例模式</a>&nbsp;<br><a href="/exam/fe6723d4/#考点6-final关键字-异常处理" class="header_1">考点6 final关键字 异常处理</a>&nbsp;<br><a href="/exam/fe6723d4/#考点7-循环-等差数列" class="header_1">考点7 循环 等差数列</a>&nbsp;<br><a href="/exam/fe6723d4/#考点8-JVM内存分类" class="header_1">考点8 JVM内存分类</a>&nbsp;<br><a href="/exam/fe6723d4/#考点9" class="header_1">考点9 </a>&nbsp;<br><a href="/exam/fe6723d4/#考点10-JVM堆内存" class="header_1">考点10 JVM堆内存</a>&nbsp;<br><a href="/exam/fe6723d4/#考点11-Hibernate" class="header_1">考点11 Hibernate</a>&nbsp;<br><a href="/exam/fe6723d4/#考点12-Struts" class="header_1">考点12 Struts</a>&nbsp;<br><a href="/exam/fe6723d4/#考点13-hibernate-POJO" class="header_1">考点13 hibernate POJO</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-数组声明"><a href="#考点1-数组声明" class="headerlink" title="考点1 数组声明"></a>考点1 数组声明</h1><p>Which of the following statements are valid array declaration?<br>(A) int number();<br>(B) float average[];<br>(C) double[] marks;<br>(D) counter int[];</p><ul><li>A (B) &amp; (C)</li><li>B (A)</li><li>C (A) &amp; (C)</li><li>D (D)</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>valid有效的</p><h1 id="考点2-异常处理"><a href="#考点2-异常处理" class="headerlink" title="考点2 异常处理"></a>考点2 异常处理</h1><p>try块后必须有catch块。()</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><code>try</code>的形式有如下三种:</p><ul><li>try-catch</li><li><code>try-finally</code></li><li><code>try-catch-finally</code></li></ul><p>但<code>catch</code>和<code>finally</code>语句不能同时省略</p><h1 id="考点3-异常继承树"><a href="#考点3-异常继承树" class="headerlink" title="考点3 异常继承树"></a>考点3 异常继承树</h1><p>有时为了避免某些未识别的异常抛给更高的上层应用,在某些接口实现中我们通常需要捕获编译运行期所有的异常, catch 下述哪个类的实例才能达到目的:()</p><ul><li>A <code>Error</code></li><li>B <code>Exception</code></li><li>C <code>RuntimeException</code></li><li>D <code>Throwable</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><code>error</code>是系统出错,<code>catch</code>是无法处理的,难以修复的,<code>RuntimeException</code>不需要程序员进行捕获处理,<br><code>error</code>和<code>exception</code>都是<code>throwable</code>的子类,我们只需要对<code>exception</code>的实例进行捕获即可</p><h1 id="考点4-数据表述范围-值传递"><a href="#考点4-数据表述范围-值传递" class="headerlink" title="考点4 数据表述范围 值传递"></a>考点4 数据表述范围 值传递</h1><p>如下代码,执行test()函数后,屏幕打印结果为()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Byte b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        b = b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Byte a = <span class="number">127</span>;</span><br><span class="line">        Byte b = <span class="number">127</span>;</span><br><span class="line">        add(++a);</span><br><span class="line">        System.out.print(a + <span class="string">" "</span>);</span><br><span class="line">        add(b);</span><br><span class="line">        System.out.print(b + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 127 127</li><li>B 128 127</li><li>C 129 128</li><li>D 以上都不对</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><ul><li>A 127 127</li><li>B 128 127</li><li>C 129 128</li><li>D 以上都不对</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Byte类型值大小为-128~127之间。<br>add(++a);这里++a会越界，a的值变为-128<br>add(b); 前面说了，add不起任何作用，b还是127<br>add()方法里面的修改值并不会起作用，而add(++a)会使a数值越界成-128，所以输出为-128 127</p><h1 id="考点5-设计模式-单例模式"><a href="#考点5-设计模式-单例模式" class="headerlink" title="考点5 设计模式 单例模式"></a>考点5 设计模式 单例模式</h1><p>单例模式中,两个基本要点是</p><ul><li>A 构造函数私有</li><li>B 静态工厂方法</li><li>C 以上都不对</li><li>D 唯一实例</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><p>1.懒汉方式。指全局的单例实例在第一次被使用时构建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 INSTANCE=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><p>2.饿汉方式。指全局的单例实例在类装载时构建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="考点6-final关键字-异常处理"><a href="#考点6-final关键字-异常处理" class="headerlink" title="考点6 final关键字 异常处理"></a>考点6 final关键字 异常处理</h1><p>下列有关JAVA异常处理的叙述中正确的是()</p><ul><li>A <code>finally</code>是为确保一段代码不管是否捕获异常都会被执行的一段代码</li><li>B <code>throws</code>是用来声明一个成员方法可能抛出的各种非运行异常情况</li><li>C <code>final</code>用于可以声明属性和方法,分别表示属性的不可变及方法的不可继承</li><li>D <code>throw</code>是用来明确地抛出一个异常情况</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p><code>throws</code>用于在方法上声明该方法不需要处理的异常类型,用在方法上后面跟异常类名 可以是多个异常类<br> <code>throw</code>用于抛出具体异常类的对象,用在方法内 后面跟异常对象只能是一个异常类型实体.<br> <code>try</code>块必须和<code>catch</code>块或和<code>finally</code>同在,不能单独存在,二者必须出现一个.<br><code>finally</code>块总会执行,不论是否有错误出现.但是若<code>try</code>语句块或会执行的<code>catch</code>语句块使用了<code>JVM</code>系统退出语句,<code>finally</code>块就不会被执行了.<br>一般我们把关闭资源的代码放在<code>finally</code>里面 保证资源总是能关闭<br>然后再看这一题 A肯定对了，C根本就跟异常处理没有关系，所以不选。就算有关系也错了<br><code>final</code>用于声明属性、方法、类。分别表示</p><ul><li>属性不可更改、</li><li>方法不能被覆盖、</li><li>类不能被继承。</li></ul><p>所以C选项说<code>final</code>方法不能被继承是错误的,<code>final</code>方法可以继承,但是不能覆盖,</p><h1 id="考点7-循环-等差数列"><a href="#考点7-循环-等差数列" class="headerlink" title="考点7 循环 等差数列"></a>考点7 循环 等差数列</h1><p>下面是findSum(int m.int n)方法的定义,方法调用findSum(1,5)的返回结果是( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSum</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 1</li><li>B 5</li><li>C 10</li><li>D 15</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>1+2+3+4+5=(1+5)×5÷2=15</p><h1 id="考点8-JVM内存分类"><a href="#考点8-JVM内存分类" class="headerlink" title="考点8 JVM内存分类"></a>考点8 JVM内存分类</h1><p>JVM内存不包含如下哪个部分( )</p><ul><li>A <code>Stacks</code></li><li>B <code>PC</code>寄存器</li><li>C <code>Heap</code></li><li>D <code>Heap Frame</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="JVM内存五大区域"><a href="#JVM内存五大区域" class="headerlink" title="JVM内存五大区域"></a>JVM内存五大区域</h3><p><img src="https://uploadfiles.nowcoder.com/images/20190606/291053_1559812298987_4E467FB794A7AF7967F62555B4F0B6A6" alt="图片"><br>栈有帧堆没帧<br>方法区 堆 pc计数器 本地方法栈 虚拟机栈</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>如果一个list初始化为{5,3,1},执行以下代码后,其结果为()？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums.add(<span class="number">6</span>);</span><br><span class="line">nums.add(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">nums.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><ul><li>A [5, 3, 1, 6]</li><li>B [4, 3, 1, 6]</li><li>C [4, 3, 6]</li><li>D [5, 3, 6]</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>list{5,3,1}<br>nums.add(6); //往后边加一个6，{5，3，1，6}<br>nums.add(0,4);//往下标为0的数加一个4，{4，5，3，1，6}<br>nums.remove(1); // 移除下标为1 的元素，{4，3，1，6}</p><h1 id="考点10-JVM堆内存"><a href="#考点10-JVM堆内存" class="headerlink" title="考点10 JVM堆内存"></a>考点10 JVM堆内存</h1><p>以下哪个不属于JVM堆内存中的区域()？</p><ul><li>A <code>survivor</code>区</li><li>B 常量池</li><li>C <code>eden</code>区</li><li>D <code>old</code>区</li></ul><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>堆中的内存可以为了新生代和老年代,新生代由可以分为一个<code>Survivor</code>和两个<code>Eden(From,To)</code>,默认比例8:1:1。<br>其实这个题有问题,从<code>JDK7</code>开始,常量池就从方法区中被移了到了堆(<code>Hotspot</code>叫做永久代),<code>JDK8</code>的时候,永久代被元空间代替。但是这个字符串常量池可是一直都在堆中的。<br>这里先说一下,方法区和永久代只是针对于<code>HotSpot</code>而言,在<code>JDK7</code>之前是一个概念,对于别的虚拟机而言,可没有什么永久代,只有方法区。<br>为什么<code>HotSpot</code>把永久代取消了呢,主要是因为这块地方的<code>GC</code>机制和堆邦定在一起,但是因为它不是堆,所以每一个<code>GC</code>收集器都需要有很大一部分代码去专门实现这个区域的垃圾,其次,每次一开始为永久代分配内存的时候,因为无法估量对象的大小,所以总是很难分配合适的内存,还容易出现<code>OOM</code>,所以取代成了元空间。元空间的话相当于一个内地内存,所以基本不会出现什么<code>OOM</code>,但是内存泄漏还是有的。</p><h1 id="考点11-Hibernate"><a href="#考点11-Hibernate" class="headerlink" title="考点11 Hibernate"></a>考点11 Hibernate</h1><p>下面哪一项不属于优化Hibernate所鼓励的？</p><ul><li>A 使用单向一对多关联,不使用双向一对多</li><li>B 不用一对一,用多对一取代</li><li>C 配置对象缓存,不使用集合缓存</li><li>D 继承类使用显式多态</li></ul><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>优化Hibernate所鼓励的7大措施：<br>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit”<br>避免查处所有对象<br>7.消除大表，使用二级缓存</p><p>1、什么是延迟加载？<br>定义：延迟加载(lazy load)是Hibernate3 关联关系对象默认的加载方式，延迟加载机制是为了避免一些无谓的性能开销而提出来的。就是只有当真正需要数据时，才真正的执行数据加载操作。延迟加载是 hibernate 中用于提高查询效率的一种措施，它的对立面是 立即加载。<br>2、如何实现延迟加载？<br>Hibernate 2 实现延迟加载有 2 种方式：<br>实体对象<br>集合<br>Hibernate 3 又引入了一种新的加载方式：属性的延迟加载<br>一般使用load()的方法来实现延迟加载：<br>当调用load方法加载对象时，返回<em>*</em>对象，等到真正用到对象的内容时才发出sql语句<br>3、Hibernate 其他介绍<br>Hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性<br>Hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<br>4、优化 Hibernate 所鼓励的 7 大措施<br>1.尽量使用多对一，避免使用单项一对多<br>2.灵活使用单向一对多<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag ，多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存</p><h1 id="考点12-Struts"><a href="#考点12-Struts" class="headerlink" title="考点12 Struts"></a>考点12 Struts</h1><p>在Struts框架中如果要使用Validation作验证的话,需要使用以下哪个Form？</p><ul><li>A <code>ActionForm</code></li><li>B <code>ValidatorActionForm</code></li><li>C <code>ValidatorForm</code></li><li>D <code>DynaValidatorActionForm</code></li></ul><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>有空了解一下<br>DynaValidatorActionForm 动态验证表单 Validation 确认的意思</p><h1 id="考点13-hibernate-POJO"><a href="#考点13-hibernate-POJO" class="headerlink" title="考点13 hibernate POJO"></a>考点13 hibernate POJO</h1><p>在 hibernate 开发中,关于 POJO 类对象的状态说法正确的是()。</p><ul><li>A 自由状态(<code>Transient</code>):实体在内存中自由存在,与数据库中的记录无关</li><li>B 持久状态(<code>Persistent</code>):实体处于由<code>Hibernate</code>框架所管理的状态,对应了数据库中的一条记录,同时与某个<code>session</code>实例发生了关联</li><li>C 游离状态(<code>Detached</code>):在<code>session</code> 关闭之后,可以使对象从持久状态转换到游离状态。</li><li>D 不能将对象从游离状态转换成持久态</li></ul><h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月11日 java2</title>
      <link href="/exam//fe6723d4/"/>
      <url>/exam//fe6723d4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/fe6723d4/#考点1-异常处理-catch顺序" class="header_1">考点1 异常处理 catch顺序</a>&nbsp;<br><a href="/exam/fe6723d4/#考点2-JSP编码" class="header_1">考点2 JSP编码</a>&nbsp;<br><a href="/exam/fe6723d4/#考点3-异常处理-finally返回值会覆盖try的返回值" class="header_1">考点3 异常处理 finally返回值会覆盖try的返回值</a>&nbsp;<br><a href="/exam/fe6723d4/#考点4-重写要求" class="header_1">考点4 重写要求</a>&nbsp;<br><a href="/exam/fe6723d4/#考点5-网络编程socket" class="header_1">考点5 网络编程socket</a>&nbsp;<br><a href="/exam/fe6723d4/#考点6-Integer缓存" class="header_1">考点6 Integer缓存</a>&nbsp;<br><a href="/exam/fe6723d4/#考点7-queue的实现类" class="header_1">考点7 queue的实现类</a>&nbsp;<br><a href="/exam/fe6723d4/#考点8-反射" class="header_1">考点8 反射</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-异常处理-catch顺序"><a href="#考点1-异常处理-catch顺序" class="headerlink" title="考点1 异常处理 catch顺序"></a>考点1 异常处理 catch顺序</h1><p>下列类在多重catch中同时出现时,哪一个异常类应最后一个列出()</p><ul><li>A <code>ArithmeticException</code></li><li>B <code>NumberFormatException</code></li><li>C <code>Exception</code></li><li>D <code>ArrayIndexOutOfBoundException</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>这是多重catch块的顺序问题，由于异常处理系统就近寻找匹配异常处理程序，应先子类后父类。</p><h1 id="考点2-JSP编码"><a href="#考点2-JSP编码" class="headerlink" title="考点2 JSP编码"></a>考点2 JSP编码</h1><p>通过HttpServletRequest. getParameter获取的参数.</p><ul><li>A 总是采用<code>UTF-8</code>编码</li><li>B 总是采用<code>lS08859-1</code>编码</li><li>C 由客户端浏览器和<code>Web</code>容器配置共同决定编码</li><li>D 由服务器所在的操作系统决定编码</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>编码格式由浏览器决定，浏览器根据html中指定的编码格式进行编码，tomcat根据指定的格式进行解码，另外get请求和post请求对编码格式的处理也是不同的</p><h1 id="考点3-异常处理-finally返回值会覆盖try的返回值"><a href="#考点3-异常处理-finally返回值会覆盖try的返回值" class="headerlink" title="考点3 异常处理 finally返回值会覆盖try的返回值"></a>考点3 异常处理 finally返回值会覆盖try的返回值</h1><p>以下代码执行后输出结果为( )<br>public class Test {<br>    public static void main(String[] args) {<br>        System.out.println(“return value of getValue(): “ +<br>        getValue());<br>    }<br>     public static int getValue() {<br>         try {<br>             return 0;<br>         } finally {<br>             return 1;<br>         }<br>     }<br> }</p><ul><li>A <code>return value of getValue(): 1</code></li><li>B <code>return value of getValue(): 0</code></li><li>C <code>return value of getValue(): 0return value of getValue(): 1</code></li><li>D <code>return value of getValue(): 1return value of getValue(): 0</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>根据官方的JVM规范：<br>如果try语句里有return，返回的是try语句块中变量值。<br>详细执行过程如下：</p><ul><li>如果try语句块有返回值，就把try的返回值保存到局部变量中；</li><li>执行jsr指令跳到finally语句里执行；执行完finally语句后，<ul><li>如果finally语句没有返回值，则返回之前保存在局部变量表里的值。</li><li>如果finally语句里有return，忽略try的return，而使用finally的return.</li></ul></li></ul><h1 id="考点4-重写要求"><a href="#考点4-重写要求" class="headerlink" title="考点4 重写要求"></a>考点4 重写要求</h1><p>根据以下接口和类的定义,要使代码没有语法错误,则类Hero中应该定义方法(    )。<br>interface Action{<br>    void fly();<br>}<br>class Hero implements Action{  //……  }</p><ul><li>A <code>private void fly()</code>{}</li><li>B <code>void fly()</code>{}</li><li>C <code>protected void fly()</code>{}</li><li>D <code>public void fly()</code>{}</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="继承中方法重写要求"><a href="#继承中方法重写要求" class="headerlink" title="继承中方法重写要求"></a>继承中方法重写要求</h3><ul><li>两同 参数列表相同，方法名相同</li><li>两小 抛出异常子类小，子类返回值和父类返回值相同或比父类小</li><li>一大 访问控制权限子类比父类大或相等</li></ul><p>接口中的方法默认public abstract修饰 故子类重写时只能用public作为访问控制权限修饰符</p><h1 id="考点5-网络编程socket"><a href="#考点5-网络编程socket" class="headerlink" title="考点5 网络编程socket"></a>考点5 网络编程socket</h1><p>socket编程中,以下哪个socket的操作是不属于服务端操作的()？</p><ul><li>A <code>accept</code></li><li>B <code>listen</code></li><li>C <code>connect</code></li><li>D <code>close</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p><a href="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC" target="_blank" rel="noopener">图片</a></p><h1 id="考点6-Integer缓存"><a href="#考点6-Integer缓存" class="headerlink" title="考点6 Integer缓存"></a>考点6 Integer缓存</h1><p>下面的代码返回结果为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">Integer c = <span class="number">500</span>;</span><br><span class="line">Integer d = <span class="number">500</span>;</span><br></pre></td></tr></table></figure><br>System.out.print(a == b);<br>System.out.print(c == d);</p><ul><li>A <code>true</code>、<code>true</code></li><li>B <code>true</code>、<code>false</code></li><li>C <code>false</code>、<code>true</code></li><li>D <code>false</code>、<code>false</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>Interger的缓存[-128,127]这个范围内的Interger对象，创建在这个范围内的Integer对象时，不会创建新的Interger对象，而是返回缓存好了的对象，所以<br>在[-128,127]范围内比较相等返回为true，<br>超过范围返回false</p><h1 id="考点7-queue的实现类"><a href="#考点7-queue的实现类" class="headerlink" title="考点7 queue的实现类"></a>考点7 queue的实现类</h1><p>下面几个关于Java里queue的说法哪些是正确的()？</p><ul><li>A <code>LinkedBlockingQueue</code>是一个可选有界队列,不允许<code>null</code>值</li><li>B <code>PriorityQueue,LinkedBlockingQueue</code>都是线程不安全的</li><li>C <code>PriorityQueue</code>是一个无界队列,不允许<code>null</code>值,入队和出队的时间复杂度是<code>O(log(n))</code></li><li>D <code>PriorityQueue,ConcurrentLinkedQueue</code>都遵循<code>FIFO</code>原则</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>有空了解一下</p><h1 id="考点8-反射"><a href="#考点8-反射" class="headerlink" title="考点8 反射"></a>考点8 反射</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述,哪些是错误的:(    )</p><ul><li>A <code>Java</code>反射主要涉及的类如<code>Class, Method, Filed</code>,等,他们都在<code>java.lang.reflet</code>包下</li><li>B 通过反射可以动态的实现一个接口,形成一个新的类,并可以用这个类创建对象,调用对象方法</li><li>C 通过反射,可以突破<code>Java</code>语言提供的对象成员、类成员的保护机制,访问一般方式不能访问的成员</li><li>D <code>Java</code>反射机制提供了字节码修改的技术,可以动态的修剪一个类</li><li>E <code>Java</code>的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li><li>F <code>Java</code>反射机制一般会带来效率问题,效率问题主要发生在查找类的方法和字段对象,因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details><p>A选项错误:<br>类Class在java.lang包下，<br>类Method、Filed在java.lang.reflet包下<br>D选项错误:<strong>反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法</strong>，而不是修剪类，<br>F选项错误:<strong>使用了反射的效率都会降低，就算加了缓存</strong></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月10日 java2</title>
      <link href="/exam//89601342/"/>
      <url>/exam//89601342/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'89601342'/#考点1-正则表达式" class="header_1">考点1 正则表达式</a>&nbsp;<br><a href="/exam/'89601342'/#考点2-抽象类和接口" class="header_1">考点2 抽象类和接口</a>&nbsp;<br><a href="/exam/'89601342'/#考点3-java内存区域" class="header_1">考点3 java内存区域</a>&nbsp;<br><a href="/exam/'89601342'/#考点4-Spring依赖注入方式" class="header_1">考点4 Spring依赖注入方式</a>&nbsp;<br><a href="/exam/'89601342'/#考点5-整型除法结果为整型" class="header_1">考点5 整型除法结果为整型</a>&nbsp;<br><a href="/exam/'89601342'/#考点6-基本数据类型占用字节数" class="header_1">考点6 基本数据类型占用字节数</a>&nbsp;<br><a href="/exam/'89601342'/#考点7-jsp页面导入" class="header_1">考点7 jsp页面导入</a>&nbsp;<br><a href="/exam/'89601342'/#考点8-queue" class="header_1">考点8 queue</a>&nbsp;<br><a href="/exam/'89601342'/#考点9-字符串-字符" class="header_1">考点9 字符串 字符</a>&nbsp;<br><a href="/exam/'89601342'/#考点10-异常处理" class="header_1">考点10 异常处理</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-正则表达式"><a href="#考点1-正则表达式" class="headerlink" title="考点1 正则表达式"></a>考点1 正则表达式</h1><p>正则表达式中,表示匹配非数字字符的字符是()？</p><ul><li>A \b</li><li>B \d</li><li>C \B</li><li>D \D</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>元字符描述<br>\<br>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。<br>^<br>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。<br>$<br>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。<br><em><br>匹配前面的子表达式任意次。例如，zo</em>能匹配“z”，也能匹配“zo”以及“zoo”。<em>等价于o{0,}<br>+<br>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。<br>?<br>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。<br>{n}<br>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。<br>{n,}<br>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o</em>”。<br>{n,m}<br>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。<br>?<br>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]<br>.点<br>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。<br>(pattern)<br>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。<br>(?:pattern)<br>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。<br>(?=pattern)<br>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)<br>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。<br>(?&lt;=pattern)<br>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。<br>(?&lt;!pattern)<br>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题<br>此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配<br>x|y<br>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。<br>[xyz]<br>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。<br><sup><a href="#fn_xyz" id="reffn_xyz">xyz</a></sup><br>负值字符集合。匹配未包含的任意字符。例如，“<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>”可以匹配“plain”中的“plin”。<br>[a-z]<br>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。<br>注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.<br><sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup><br>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“<sup><a href="#fn_a-z" id="reffn_a-z">a-z</a></sup>”可以匹配任何不在“a”到“z”范围内的任意字符。<br>\b<br>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。<br>\B<br>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。<br>\cx<br>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。<br>\d<br>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持<br>\D<br>匹配一个非数字字符。等价于<sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup>。grep要加上-P，perl正则支持<br>\f<br>匹配一个换页符。等价于\x0c和\cL。<br>\n<br>匹配一个换行符。等价于\x0a和\cJ。<br>\r<br>匹配一个回车符。等价于\x0d和\cM。<br>\s<br>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。<br>\S<br>匹配任何可见字符。等价于<sup><a href="#fn_ \f\n\r\t\v" id="reffn_ \f\n\r\t\v"> \f\n\r\t\v</a></sup>。<br>\t<br>匹配一个制表符。等价于\x09和\cI。<br>\v<br>匹配一个垂直制表符。等价于\x0b和\cK。<br>\w<br>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9<em>]”，这里的”单词”字符使用Unicode字符集。<br>\W<br>匹配任何非单词字符。等价于“[^A-Za-z0-9</em>]”。</p><h1 id="考点2-抽象类和接口"><a href="#考点2-抽象类和接口" class="headerlink" title="考点2 抽象类和接口"></a>考点2 抽象类和接口</h1><p>关于抽象类与接口,下列说法正确的有？</p><ul><li>A 优先选用接口,尽量少用抽象类</li><li>B 抽象类可以被声明使用,接口不可以被声明使用</li><li>C 抽象类和接口都不能被实例化。</li><li>D 以上说法都不对</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><ol><li>一个子类只能继承一个抽象类,但能实现多个接口</li><li>抽象类可以有构造方法,接口没有构造方法</li><li>抽象类可以有普通成员变量,接口没有普通成员变量</li><li>抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)</li><li>抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法</li><li>抽象类可以有静态方法,接口不能有静态方法</li><li>抽象类中的方法可以是public、protected;接口方法只有public</li></ol><h1 id="考点3-java内存区域"><a href="#考点3-java内存区域" class="headerlink" title="考点3 java内存区域"></a>考点3 java内存区域</h1><p>关于Java内存区域下列说法不正确的有哪些</p><ul><li>A 程序计数器是一块较小的内存空间,它的作用可以看做是当前线程所执行的字节码的信号指示器,每个线程都需要一个独立的程序计数器.</li><li>B <code>Java</code>虚拟机栈描述的是<code>java</code>方法执行的内存模型,每个方法被执行的时候都会创建一个栈帧,用于存储局部变量表、类信息、动态链接等信息</li><li>C <code>Java</code>堆是<code>java</code>虚拟机所管理的内存中最大的一块,每个线程都拥有一块内存区域,所有的对象实例以及数组都在这里分配内存。</li><li>D 方法区是各个线程共享的内存区域,它用于存储已经被虚拟机加载的常量、即时编译器编译后的代码、静态变量等数据。</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>有空了解一下<br>A.程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器（偏移地址），Java编译过程中产生的字节码有点类似编译原理的指令，程序计数器的内存空间存储的是当前执行的字节码的偏移地址，每一个线程都有一个独立的程序计数器（程序计数器的内存空间是线程私有的），因为当执行语句时，改变的是程序计数器的内存空间，因此它不会发生内存溢出 ，并且程序计数器是jvm虚拟机规范中唯一一个没有规定 OutOfMemoryError 异常 的区域；<br>B.java虚拟机栈：线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。  没有类信息，类信息是在方法区中<br>C.java堆：对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组<br>D.方法区：属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>上面部分内容从下面文章中总结：<br><a href="https://blog.csdn.net/qq_41701956/article/details/81664921" target="_blank" rel="noopener">https://blog.csdn.net/qq_41701956/article/details/81664921</a></p><h1 id="考点4-Spring依赖注入方式"><a href="#考点4-Spring依赖注入方式" class="headerlink" title="考点4 Spring依赖注入方式"></a>考点4 Spring依赖注入方式</h1><p>下面关于依赖注入(DI)的说法不正确的是()</p><ul><li>A 只有通过<code>Spring</code>才能实现依赖注入(<code>DI</code>)</li><li>B 依赖注入的主要目的是解耦合</li><li>C 常见的依赖注入方式有<code>Setter</code>和构造方法</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>Spring依赖注入(DI)的三种方式,分别为:</p><ol><li>接口注入</li><li>Setter方法注入</li><li>构造方法注入</li></ol><h1 id="考点5-整型除法结果为整型"><a href="#考点5-整型除法结果为整型" class="headerlink" title="考点5 整型除法结果为整型"></a>考点5 整型除法结果为整型</h1><p>设三个整型变量 x = 1 , y = 2 , z = 3,则表达式 y+=z—/++x 的值是(      )。</p><ul><li>A 3</li><li>B 3.5</li><li>C 4</li><li>D 5</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>整型出发结果只取整数部分，小数部分丢弃，或者说向下取整。</p><h1 id="考点6-基本数据类型占用字节数"><a href="#考点6-基本数据类型占用字节数" class="headerlink" title="考点6 基本数据类型占用字节数"></a>考点6 基本数据类型占用字节数</h1><p>以下程序段执行后将有()个字节被写入到文件afile.txt中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"afile.txt"</span>);</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">    dos.writeInt(<span class="number">3</span>);</span><br><span class="line">    dos.writeChar(<span class="number">1</span>);</span><br><span class="line">    dos.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 3</li><li>B 5</li><li>C 6</li><li>D 不确定,与软硬件环境相关</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>int占用4字节</p><p>char占用2字节</p><h1 id="考点7-jsp页面导入"><a href="#考点7-jsp页面导入" class="headerlink" title="考点7 jsp页面导入"></a>考点7 jsp页面导入</h1><p>java采用的uincode编码，两个字节表示一个字符，因此char型在java中占两个字节<br>给定includel.isp文件代码片段，如下：<br>  &lt;% pageContext.setAttribute(“User”,”HAHA”);%&gt;<br><strong>__</strong> // 此处填写代码<br>  给定include2.jsp文件代码片段如下：<br>  &lt;%=pageContext.getAttribute(“User”)%&gt;<br>  要求运行include1.jsp时，浏览器上输出：HAHA</p><p>A <jsp:include page=”include2.jsp” flash=”true”><br>B &lt;%@include file=”include2.jsp”%&gt;<br>C <jsp:forward page=”include2.jsp”><br>D &lt;% response.sendRedirect(“include2.jsp”); %&gt;</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>B选项是<strong>静态包含</strong>，相当于讲include2.jsp页面内容拷贝到此处，因此可以输出User属性值<br>D选项是<strong>转发重定向</strong>，转发的时候pageContent内的属性值不能被传递，因此得不到User属性值</p><h1 id="考点8-queue"><a href="#考点8-queue" class="headerlink" title="考点8 queue"></a>考点8 queue</h1><p>下面几个关于Java里queue的说法哪些是正确的()？</p><ul><li>A <code>LinkedBlockingQueue</code>是一个可选有界队列,不允许<code>null</code>值</li><li>B <code>PriorityQueue,LinkedBlockingQueue</code>都是线程不安全的</li><li>C <code>PriorityQueue</code>是一个无界队列,不允许<code>null</code>值,入队和出队的时间复杂度是<code>O(log(n))</code></li><li>D <code>PriorityQueue,ConcurrentLinkedQueue</code>都遵循<code>FIFO</code>原则</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>有空了解一下</p><h1 id="考点9-字符串-字符"><a href="#考点9-字符串-字符" class="headerlink" title="考点9 字符串 字符"></a>考点9 字符串 字符</h1><p>java中 String str = “hello world”下列语句错误的是？</p><ul><li>A <code>str+=&#39; a&#39;</code></li><li>B <code>int strlen = str.length</code></li><li>C <code>str=100</code></li><li>D <code>str=str+100</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABC</details><p>A选项错误:str += ‘a’   和 str +=”a”都是对的，单引号表示字符里面，只能放一个字符。只有双引号里面才能写多个字符，表示字符串。所以如果a前面加一个空格，那么只能用双引号了。代表字符串<br>B选项错误:数组才有length属性，字符串是length()方法<br>C选项错误:int 无法直接转成String类型</p><h1 id="考点10-异常处理"><a href="#考点10-异常处理" class="headerlink" title="考点10 异常处理"></a>考点10 异常处理</h1><p>以下关于JAVA语言异常处理描述正确的有？</p><ul><li>A <code>throw</code>关键字可以在方法上声明该方法要抛出的异常。</li><li>B <code>throws</code>用于抛出异常对象。</li><li>C <code>try</code>是用于检测被包住的语句块是否出现异常,如果有异常,则抛出异常,并执行<code>catch</code>语句。</li><li>D <code>finally</code>语句块是不管有没有出现异常都要执行的内容。</li><li>E 在<code>try</code>块中不可以抛出异常</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><p>throws用于声明要抛出的异常，一般以s结尾的用于声明，比如extens, implements。<br>throw用于抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月10日 java1</title>
      <link href="/exam//6b20adaa/"/>
      <url>/exam//6b20adaa/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/6b20adaa/#考点1-java包的用途" class="header_1">考点1 java包的用途</a>&nbsp;<br><a href="/exam/6b20adaa/#考点2-构造器的修饰符" class="header_1">考点2 构造器的修饰符</a>&nbsp;<br><a href="/exam/6b20adaa/#考点3-抽象" class="header_1">考点3 抽象</a>&nbsp;<br><a href="/exam/6b20adaa/#考点4" class="header_1">考点4 </a>&nbsp;<br><a href="/exam/6b20adaa/#考点5-图形界面" class="header_1">考点5 图形界面</a>&nbsp;<br><a href="/exam/6b20adaa/#考点6" class="header_1">考点6 </a>&nbsp;<br><a href="/exam/6b20adaa/#考点7-Java标识符" class="header_1">考点7 Java标识符</a>&nbsp;<br><a href="/exam/6b20adaa/#考点8-循环语句" class="header_1">考点8 循环语句</a>&nbsp;<br><a href="/exam/6b20adaa/#考点9-构造器修饰符-native-import" class="header_1">考点9 构造器修饰符 native import</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1-java包的用途"><a href="#考点1-java包的用途" class="headerlink" title="考点1 java包的用途"></a>考点1 java包的用途</h1><p>进行Java基本的GUI设计需要用到的包是()</p><ul><li>A <code>java.io</code></li><li>B <code>java.sql</code></li><li>C <code>java.awt</code></li><li>D <code>java.rmi</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>图形用户界面（Graphical User Interface，简称 GUI）是指采用图形方式显示的计算机操作用户界面。<br>java.io提供了全面的IO接口。包括：文件读写、标准设备输出等。<br>java.sql提供使用 Java 编程语言访问并处理存储在数据源中的数据的 API。此 API<br>包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。<br>java.awt是一个软件包，包含用于创建用户界面和绘制图形图像的所有分类。功能：包含用于创建用户界面和绘制图形图像的所有类。<br>java.rmi提供 RMI 包。RMI 指的是<strong>远程方法调用</strong> (Remote Method Invocation)。它是一种机制，能够<strong>让在某个Java虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法</strong>。</p><h1 id="考点2-构造器的修饰符"><a href="#考点2-构造器的修饰符" class="headerlink" title="考点2 构造器的修饰符"></a>考点2 构造器的修饰符</h1><p>Which of the following can be applied to constructors:</p><ul><li>A <code>final</code></li><li>B <code>static</code></li><li>C <code>synchronized</code></li><li>D <code>native</code></li><li>E <code>None of these.</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: E</details><p>1.构造器不是通过继承得到的,所以没有必要把它声明为final的。<br>2.同理,一个抽象的构造器将永远不会被实现。(所以也不能声明为abstract的)<br>3.构造器总是关联一个对象而被调用,所以把它声明为static是没有意义的。<br>4.没有实际的需要把构造器定义成同步的,因为它将会在构造的时候锁住该对象,直到所有的构造器完成它们的工作,这个构造的过程对其它线程来说,通常是不可访问的。 (synchronized)<br>5.本地化的方法情况特别复杂，所以JVM调用起来非常麻烦，需要考虑很多种情况，如果构造器使用native关键字的话，JVM实现起来比较困难。</p><p>构造器只能被public、private、protected这3个修饰</p><h1 id="考点3-抽象"><a href="#考点3-抽象" class="headerlink" title="考点3 抽象"></a>考点3 抽象</h1><p>在jdk1.8之前,下列哪一种叙述是正确的( )</p><ul><li>A <code>abstract</code>修饰符可修饰字段、方法和类</li><li>B 抽象方法的<code>body</code>部分必须用一对大括号{ }包住</li><li>C 声明抽象方法,大括号可有可无</li><li>D 声明抽象方法不可写出大括号</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><ul><li>abstract修饰<strong>方法</strong>和<strong>类</strong>，不能用于修饰成员变量(字段)。</li><li>抽象方法没有方法体，有没有方法体看有没有大括号。</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>根据以下代码段,下列说法中正确的是(    )。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m1</code>方法</li><li>B 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m2</code>方法</li><li>C 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m3</code>方法</li><li>D 子类中一定能够继承和覆盖<code>Parent</code>类的<code>m4</code>方法</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="静态成员与继承无关"><a href="#静态成员与继承无关" class="headerlink" title="静态成员与继承无关"></a>静态成员与继承无关</h3><p>static修饰的成员属于类成员，父类字段或方法只能被子类同名字段或方法遮蔽，父类的静态成员不能被子类覆盖。</p><p>4、静态变量或静态方法，在子类中可以写同名的变量和方法，但是仍然各自属于父类或子类，与继承无关，与覆盖（重写）无关；</p><p>5、静态变量或静态方法在调用时，各自调用各自的静态的变量或静态方法，不管有没有强转，只取决于调用者是谁；</p><h1 id="考点5-图形界面"><a href="#考点5-图形界面" class="headerlink" title="考点5 图形界面"></a>考点5 图形界面</h1><p>容器panel缺省使用的布局编辑策略是( )</p><ul><li>A <code>Border Layout</code></li><li>B <code>Flow Layout</code></li><li>C <code>GridLayout</code></li><li>D <code>Card Layout</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>默认是流式布局<code>Flow Layout</code>，相当于浏览器，缩小后有滑块，可以滑动查看</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪个I / O类可以附加或更新文件</p><ul><li>A <code>RandomAccessFile()</code></li><li>B <code>OutputStream()</code></li><li>C <code>DataOutputStream()</code></li><li>D <code>None of the above</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>RandomAccessFile 可以通过 seek(long pos) 方法去移动文件指针进行追加更新写入.</p><h1 id="考点7-Java标识符"><a href="#考点7-Java标识符" class="headerlink" title="考点7 Java标识符"></a>考点7 Java标识符</h1><p>下列哪个是合法的 Java 标识符？( )</p><ul><li>A <code>Tree</code>&amp;<code>Glasses</code></li><li>B <code>FirstJavaApplet</code></li><li>C <code>First_Applet</code></li><li>D 273.5</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><h3 id="Java标识符规则"><a href="#Java标识符规则" class="headerlink" title="Java标识符规则"></a>Java标识符规则</h3><p>标识符只有英文，数字，下划线和$，而且数字不能做开头</p><h1 id="考点8-循环语句"><a href="#考点8-循环语句" class="headerlink" title="考点8 循环语句"></a>考点8 循环语句</h1><p>下列关于while循环、do-while循环和for循环说法错误的是</p><ul><li>A <code>while</code>循环先执行条件判断,<code>do-while</code>循环执行循环体</li><li>B <code>do-while</code>循环结束的条件是关键字<code>while</code>后的条件表达式成立</li><li>C <code>for</code>循环结构中的3个表达式缺一不可</li><li>D <code>while</code>循环能够实现的操作,<code>for</code>循环也能实现</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件) &#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>都可以替换成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;条件;) &#123;</span><br><span class="line">    <span class="comment">//执行语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>所以D：while循环能够实现的操作，for循环也能实现 是正确的。</p><h1 id="考点9-构造器修饰符-native-import"><a href="#考点9-构造器修饰符-native-import" class="headerlink" title="考点9 构造器修饰符 native import"></a>考点9 构造器修饰符 native import</h1><p>关于Java以下描述正确的有(      )</p><ul><li>A <code>native</code>关键字表明修饰的方法是由其它非<code>Java</code>语言编写的</li><li>B 能够出现在<code>import</code>语句前的只有注释语句</li><li>C 接口中定义的方法默认是<code>public</code>和<code>static</code>的</li><li>D 构造方法只能被修饰为<code>public</code>或者<code>default</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>A:<code>native</code>是由调用本地方法库(如操作系统底层函数),可以由C,C++实现,A正确<br>B:<code>import</code>是用于导包语句,其前面可以出现<code>package</code>,用来声明包的,B错误<br>C:接口方法的修饰符可以是:<code>public</code>,<code>abstract</code>,<code>default</code>,<code>static</code>(后两者需要有{}),C正确<br>D:构造方法可以用<code>private</code>,<code>protected</code>,<code>default</code>,<code>private</code>,D错误</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年12月8日 java2</title>
      <link href="/exam//1deb972e/"/>
      <url>/exam//1deb972e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/1deb972e/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/1deb972e/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/1deb972e/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/1deb972e/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/1deb972e/#考点5-考点-子类构造器调用父类构造器-已提供构造器则系统不提供默认无参构造器" class="header_1">考点5 考点:子类构造器调用父类构造器 已提供构造器则系统不提供默认无参构造器</a>&nbsp;<br><a href="/exam/1deb972e/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>假设一个 list初始化为{2,9,5,4,8,1}。 在第一次冒泡排序后,list变成了()?</p><ul><li>A 2, 9, 5, 4, 8, 1</li><li>B 2, 9, 5, 4, 1, 8</li><li>C 2, 5, 9, 4, 8, 1</li><li>D 2, 5, 4, 8, 1, 9</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>冒泡排序：将最大值放到末尾，一直缩小范围到第一位<br>第一次排序后最大的数,转移到数组最后</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>要求匹配以下16进制颜色值，正则表达式可以为：  #ffbbad  #Fc01DF  #FFF  #ffE</p><ul><li>A /#([0-9a-f]{6}|[0-9a-fA-F]{3})/g</li><li>B /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g</li><li>C /#([0-9a-fA-F]{3}|[0-9a-f]{6})/g</li><li>D /#([0-9A-F]{3}|[0-9a-fA-F]{6})/g</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>对于如下代码段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">foo</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    _______</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以放入到横线位置,使程序正确编译运行,而且不产生错误的选项是( )</p><ul><li>A <code>public void foo()</code>{}</li><li>B <code>public int foo()</code>{<code>return 1;</code>}</li><li>C <code>public A foo(B b)</code>{<code>return b;</code>}</li><li>D <code>public A foo()</code>{<code>return A;</code>}</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="重写-要求"><a href="#重写-要求" class="headerlink" title="重写 要求"></a>重写 要求</h3><p>两同两小一大原则， </p><ul><li>方法名相同，</li><li>参数列表相同，</li><li>子类返回类型小于等于父类方法返回类型， </li><li>子类抛出异常小于等于父类方法抛出异常， </li><li>子类访问权限大于等于父类方法访问权限。</li></ul><p>［注意：这里的返回类型必须要在有继承关系的前提下比较］</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>两同一不同</p><ul><li>同一个类中</li><li>方法名必须相同，</li><li>参数类型必须不同，</li></ul><p>再来说说这道题 A B 都是方法名和参数相同，是重写，但是<strong>返回类型没与父类返回类型有继承关系</strong>，</p><p>D语法错误，要返回一个对象，不能返回一个类</p><p>c的参数类型与父类不同，所以不是重写，可以理解为广义上的重载访问权限小于父类，都会显示错误</p><p>虽然题目没点明一定要重载或者重写，但是<strong>当你的方法名与参数类型与父类相同时，已经是重写了</strong>，这时候如果返回类型或者异常类型比父类大，或者访问权限比父类小都会编译错误</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>URL u =new URL(“<a href="http://www.123.com&quot;);。如果www.123.com不存在,则返回______。" target="_blank" rel="noopener">http://www.123.com&quot;);。如果www.123.com不存在,则返回______。</a></p><ul><li>A <code>http://www.123.com</code></li><li>B “”</li><li>C <code>null</code></li><li>D 抛出异常</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>new URL()时必须捕获检查异常，但这个异常是由于字符串格式和URL不符导致的，与网址是否存在无关。URL的toString方法返回字符串，无论网址是否存在<br>有空了解一下</p><h1 id="考点5-考点-子类构造器调用父类构造器-已提供构造器则系统不提供默认无参构造器"><a href="#考点5-考点-子类构造器调用父类构造器-已提供构造器则系统不提供默认无参构造器" class="headerlink" title="考点5 考点:子类构造器调用父类构造器 已提供构造器则系统不提供默认无参构造器"></a>考点5 考点:子类构造器调用父类构造器 已提供构造器则系统不提供默认无参构造器</h1><p>以下程序的输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Derived</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Derived(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>BD</code></li><li>B <code>DB</code></li><li>C C</li><li>D 编译错误</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>子类构造方法在调用时必须先调用父类的构造器，由于父类没有无参构造构造器，必须在子类中显式调用，修改子类构造方法如下即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"s"</span>);</span><br><span class="line">    System.out.print(<span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪些jvm的垃圾回收方式采用的是复制算法回收</p><ul><li>A 新生代串行收集器</li><li>B 老年代串行收集器</li><li>C 并行收集器</li><li>D 新生代并行回收收集器</li><li>E 老年代并行回收收集器</li><li>F <code>cms</code>收集器</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>有空了解一下<br>两个最基本的java回收算法：复制算法和标记清理算法<br>复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法<br>标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出<br>标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象<br>两个概念：新生代和年老代<br>新生代：初始对象，生命周期短的<br>永久代：长时间存在的对象<br>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理<br>CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p><p>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</p><p>有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年12月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月28日 java2</title>
      <link href="/exam//12285fce/"/>
      <url>/exam//12285fce/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/12285fce/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/12285fce/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/12285fce/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/12285fce/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/12285fce/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/12285fce/#考点7" class="header_1">考点7</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列程序段的输出结果是:( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complicatedexpression_r</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">20</span>, y=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b;</span><br><span class="line">    b = x &gt; <span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &gt; <span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>true</code></li><li>B <code>false</code></li><li>C 1</li><li>D 0</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>&amp;&amp;的优先级大于||   而不是相等   所以原式=(x&gt;50&amp;&amp;y&gt;60)||(x&gt;50&amp;&amp;y&lt;-60)||(x&lt;-50&amp;&amp;y&gt;60)||(x&lt;-50&amp;&amp;y&lt;-60);</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>函数()把文件位置重定位到文件中的指定位置</p><ul><li>A <code>fseek</code></li><li>B <code>fread</code></li><li>C <code>fopen</code></li><li>D <code>fgets</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>这是c语言的题</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于struts框架,下面那些说法是正确的？</p><ul><li>A <code>Struts</code>中无法完成上传功能</li><li>B <code>Struts</code>框架基于<code>MVC</code>模式</li><li>C <code>Struts</code>框架容易引起流程复杂、结构不清晰等问题</li><li>D <code>Struts</code>可以有效地降低项目的类文件数目</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>有空了解一下</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>有关hashMap跟hashTable的区别,说法正确的是？</p><ul><li>A <code>HashMap</code>和<code>Hashtable</code>都实现了<code>Map</code>接口</li><li>B <code>HashMap</code>是非<code>synchronized</code>,而<code>Hashtable</code>是<code>synchronized</code></li><li>C <code>HashTable</code>使用<code>Enumeration,HashMap</code>使用<code>Iterator</code></li><li>D <code>HashMap</code>允许将 <code>null</code> 作为一个 <code>entry</code> 的 <code>key</code> 或者 <code>value</code>,而 <code>Hashtable</code> 不允许。</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些类可以被继承？ Java.lang.Thread、java.lang.Number、java.lang.Double、java.lang.Math、 java.lang.ClassLoader</p><ul><li>A <code>Thread</code></li><li>B <code>Number</code></li><li>C <code>Double</code></li><li>D <code>Math</code></li><li>E <code>ClassLoader</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details><ul><li>A，Thread可以被继承，用于创建新的线程</li><li>B，Number类可以被继承，Integer，Float，Double等都继承自Number类</li><li>C，Double类的声明为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Double</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br></pre></td></tr></table></figure>final生明的类不能被继承</li><li>D，Math类的声明为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> <span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>不能被继承</li><li>E，ClassLoader可以被继承，用户可以自定义类加载器</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于ThreadLocal类 以下说法正确的是</p><ul><li>A <code>ThreadLocal</code>继承自<code>Thread</code></li><li>B <code>ThreadLocal</code>实现了<code>Runnable</code>接口</li><li>C <code>ThreadLocal</code>重要作用在于多线程间的数据共享</li><li>D <code>ThreadLocal</code>是采用哈希表的方式来为每个线程都提供一个变量的副本</li><li>E <code>ThreadLocal</code>保证各个线程间数据安全,每个线程的数据不会被另外线程访问和破坏</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: DE</details><p>1、ThreadLocal的类声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><br>可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。所以AB都不对。<br>2、ThreadLocal类为每一个线程都维护了自己独有的变量拷贝。每个线程都拥有了自己独立的一个变量。<br>所以ThreadLocal重要作用并不在于多线程间的数据共享，而是<strong>数据的独立</strong>，C选项错。<br>由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，<br>变量被彻底封闭在每个访问的线程中。所以E对。<br>3、ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本：</p><p><code>ThreadLocal</code>继承<code>Object</code>，相当于没继承任何特殊的。<br><code>ThreadLocal</code>没有实现任何接口。<br><code>ThreadLocal</code>并不是一个<code>Thread</code>，而是<code>Thread</code>的局部变量。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月29日 java1</title>
      <link href="/exam//64e3654a/"/>
      <url>/exam//64e3654a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/64e3654a/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/64e3654a/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/64e3654a/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/64e3654a/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/64e3654a/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/64e3654a/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/64e3654a/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/64e3654a/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/64e3654a/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于依赖注入,下列选项中说法错误的是()</p><ul><li>A 依赖注入能够独立开发各组件,然后根据组件间关系进行组装</li><li>B 依赖注入使组件之间相互依赖,相互制约</li><li>C 依赖注入提供使用接口编程</li><li>D 依赖注入指对象在使用时动态注入</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>依赖注入是相互依赖(减少耦合)，使开发更加简洁</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>如果一个接口Cup有个方法use(),有个类SmallCup实现接口Cup,则在类SmallCup中正确的是？  ( )</p><ul><li>A <code>void use() { …}</code></li><li>B <code>protected void use() { …}</code></li><li>C <code>public void use() { …}</code></li><li>D 以上语句都可以用在类<code>SmallCup</code>中</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>接口中的常量修饰符是public static final，</li><li>接口中的方法修饰符是public abstract</li><li>两头两小一大</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>使用mvc模式设计的web应用程序具有以下优点,除了？</p><ul><li>A 可维护行强</li><li>B 可扩展性强</li><li>C 代码重复少</li><li>D 大大减少代码量</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>关于ASCII码和ANSI码,以下说法不正确的是()？</p><ul><li>A 标准<code>ASCII</code>只使用7个<code>bit</code></li><li>B 在简体中文的<code>Windows</code>系统中,<code>ANSI</code>就是<code>GB2312</code></li><li>C <code>ASCII</code>码是<code>ANSI</code>码的子集</li><li>D <code>ASCII</code>码都是可打印字符</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>A、标准<code>ASCII</code>只使用7个<code>bit</code>，扩展的<code>ASCII</code>使用8个<code>bit</code>。<br>B、<code>ANSI</code>通常使用 0<code>x00</code>~0<code>x7f</code> 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0<code>x80</code>~0<code>xFFFF</code>来编码，即扩展的<code>ASCII</code>编码。不同 <code>ANSI</code> 编码之间互不兼容。在简体中文<code>Windows</code>操作系统中，<code>ANSI</code> 编码代表 <code>GBK</code> 编码；在繁体中文<code>Windows</code>操作系统中，<code>ANSI</code>编码代表<code>Big5</code>；在日文<code>Windows</code>操作系统中，<code>ANSI</code> 编码代表 <code>Shift_JIS</code> 编码。<br>C、<code>ANSI</code>通常使用 0<code>x00</code>~0<code>x7f</code> 范围的1 个字节来表示 1 个英文字符，即<code>ASCII</code>码<br>D、<code>ASCII</code>码包含一些特殊空字符，这些特殊的空字符无法打印。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在开发中使用泛型取代非泛型的数据类型(比如用ArrayList<String>取代ArrayList),程序的运行时性能会变得更好。() </p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>java中将ISO8859-1字符串转成GB2312编码,语句为 ？  </p><ul><li>A <code>new String(&quot;ISO8859-1&quot;.getBytes(&quot;ISO8859-1&quot;),&quot;GB2312&quot;)</code></li><li>B <code>new String(String.getBytes(&quot;GB2312&quot;), ISO8859-1)</code></li><li>C <code>new String(String.getBytes(&quot;ISO8859-1&quot;))</code></li><li>D <code>new String(String.getBytes(&quot;GB2312&quot;))</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p> 得到的是以charsetName编码得到的byte数组;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> [  ]  String.getBytes(String charsetName);</span><br></pre></td></tr></table></figure></p><p>String的构造函数有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName);</span><br></pre></td></tr></table></figure></p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对于以下代码段,4个输出语句中输出true的个数是(    )。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">A obj = <span class="keyword">new</span> D();</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> B);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> C);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> D);</span><br><span class="line">System.out.println(obj <span class="keyword">instanceof</span> A);</span><br></pre></td></tr></table></figure></p><ul><li>A 1</li><li>B 2</li><li>C 3</li><li>D 4</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>a instanceof A；表示的是a指向的<code>实际对象</code>，是否是A类或者A的子类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A obj = <span class="keyword">new</span> D();</span><br></pre></td></tr></table></figure><br>这里obj指向的实际对象类型为D<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure><br>obj是B的子类D的实例，true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> D</span><br></pre></td></tr></table></figure><br>obj是D对象的实例，true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> A</span><br></pre></td></tr></table></figure><br>obj是A类的子类B的子类D的实例，true</p><p>总结可以从obj的实际类型D开始，依次向上查找父类，如果在继承链中找到这个类，则返回true。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于异常的编程,以下描述错误的是:( )</p><ul><li>A 在有除法存在的代码处,为了防止分母为零,必须抛出并捕获异常</li><li>B <code>int i=Integer.parseInt(&quot;123a&quot;);</code>将产生<code>NumberFormatException</code></li><li>C <code>int a[]=null;</code> <code>a[0]=1;</code> 将产生<code>NullPointerException</code></li><li>D 输入输出流编程中,读和写时都要抛出<code>IOException</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p><strong>除零异常是运行时异常，不需要显示处理</strong><br>Java的异常分为两种，一种是运行时异常（RuntimeException），一种是非运行异常也叫检查式异常（CheckedException）。</p><p>1、<strong>运行时异常不需要程序员去处理</strong>，当异常出现时，JVM会帮助处理。常见的运行时异常有：</p><ul><li>ClassCastException(类转换异常)</li><li>ClassNotFoundException</li><li>IndexOutOfBoundsException(数组越界异常)</li><li>NullPointerException(空指针异常)</li><li>ArrayStoreException(数组存储异常，即数组存储类型不一致)</li><li>除零异常</li><li>还有IO操作的BufferOverflowException异常</li></ul><p>2、非运行异常需要程序员手动去捕获或者抛出异常进行显示的处理，因为Java认为Checked异常都是可以被修复的异常。常见的异常有：</p><ul><li>IOException</li><li>SqlException</li></ul><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于java集合下列说法不正确的有哪些()</p><ul><li>A <code>HashSet</code> 它是线程安全的,不允许存储相同的对象</li><li>B <code>ConcurrentHashMap</code> 它是线程安全的,其中存储的键对象可以重复,值对象不能重复</li><li>C <code>Collection</code>接口是<code>List</code>接口和<code>Set</code>接口的父接口,通常情况下不被直接使用</li><li>D <code>ArrayList</code>线程安全的,允许存放重复对象</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>线程安全(Thread-safe)的集合对象：</p><ul><li>Vector 线程安全：</li><li>HashTable 线程安全：</li></ul><p>非线程安全的集合对象：</p><ul><li>ArrayList </li><li>LinkedList</li><li>HashMap</li><li>HashSet</li><li>TreeMap</li><li>TreeSet</li></ul><p>StringBuffer线程安全<br>StringBulider线程不安全</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月28日 java1</title>
      <link href="/exam//8b210e74/"/>
      <url>/exam//8b210e74/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/8b210e74/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/8b210e74/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/8b210e74/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/8b210e74/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/8b210e74/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/8b210e74/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/8b210e74/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/8b210e74/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/8b210e74/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/8b210e74/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/8b210e74/#考点11" class="header_1">考点11</a>&nbsp;<br><a href="/exam/8b210e74/#考点12" class="header_1">考点12</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面有关maven和ant的描述,描述错误的是？</p><ul><li>A <code>Ant</code> 没有正式的约定如一个一般项目的目录结构,你必须明确的告诉 <code>Ant</code> 哪里去找源代码</li><li>B <code>Maven</code> 拥有约定,因为你遵循了约定,它已经知道你的源代码在哪里</li><li>C <code>maven</code>和<code>ant</code>都有”生命周期”的概念,当你输入一个命令后,<code>maven</code>或者<code>ant</code>会执行一系列的有序的步骤,直到到达你指定的生命周期</li><li>D <code>Ant</code>构建文件默认命名为<code>build.xml,Maven</code>默认构建文件为<code>pom.xml</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p><code>Ant</code>没有生命周期，你必须定义目标和目标之间的依赖。你必须手工为每个目标附上一个任务序列。<br>有空了解一下<br>Ant的作用：是一种基于Java的build工具</p><p>能够用ant编译java类。生成class文件<br>ant能够自己定义标签、配置文件，用于构建。<br>ant能够把相关层构建成jar包 。<br>ant把整个项目生成web包。并公布到Tomcat<br>Ant的长处：</p><p>跨平台性：Ant是纯Java语言编写的，因此具有非常好的跨平台性。<br>操作简单：Ant是由一个内置任务和可选任务组成的。Ant执行时须要一个XML文件(构建文件)。<br>Ant通过调用target树，就能够运行各种task：每一个task实现了特定接口对象。因为Ant构建文件时XML格式的文件。所以非常easy维护和书写，并且结构非常清晰。<br>Ant能够集成到开发环境中：因为Ant的跨平台性和操作简单的特点。它非常easy集成到一些开发环境中去。<br>Maven的作用： 除了以程序构建能力为特色之外，还提供高级项目管理工具。<br>Maven除了具备Ant的功能外。还添加了下面基本的功能：<br>使用Project Object Model来对软件项目管理。<br>内置了很多其它的隐式规则，使得构建文件更加简单。<br>内置依赖管理和Repository来实现依赖的管理和统一存储；<br>内置了软件构建的生命周期；<br>Maven的长处：<br>拥有约定，知道你的代码在哪里，放到哪里去<br>拥有一个生命周期，比如运行 mvn install就能够自己主动运行编译，測试。打包等构建过程<br>仅仅须要定义一个pom.xml,然后把源代码放到默认的文件夹，Maven帮你处理其它事情<br>拥有依赖管理。仓库管理<br>总体的比較：<br>       Ant将提供了非常多能够重用的task，比如 copy, move, delete以及junit单元測试Maven则提供了非常多能够重用的过程。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>有一个源代码,只包含import java.util.* ; 这一个import语句,下面叙述正确的是？   ( )</p><ul><li>A 只能写在源代码的第一句</li><li>B 可以访问<code>java/util</code>目录下及其子目录下的所有类</li><li>C 能访问<code>java/util</code>目录下的所有类,不能访问<code>java/util</code>子目录下的所有类</li><li>D 编译错误</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>导入java.util.*不能读取其子目录的类，因为如果java.util里面有个a类，java.util.regex里面也有个a类，我们若是要调用a类的方法或属性时，应该使用哪个a类呢。所以也应该选C</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面代码的输出结果为:<br>String str =<br>“”;<br>System.out.print(str.split(“,”).length);</p><ul><li>A 0</li><li>B 1</li><li>C 出现异常</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>String的 split 方法默认返回一个数组，  如果没有找到分隔符， 会把整个字符串当成一个长度为1的字符串数组返回到结果， 所以此处结果就是1</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>局部内部类可以用哪些修饰符修饰？</p><ul><li>A <code>public</code></li><li>B <code>private</code></li><li>C <code>abstract</code></li><li>D <code>final</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><p>局部内部类定义在方法中，可以看成局部变量，局部本身就是访问权限修饰，不能有public，protected，public修饰，另外，普通方法中不能定义static内部类。 </p><p>成员内部类定义在类中，是类的成员，类的成员可以有public，protected，public，static修饰。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在socket编程中,可以使用方法(      )获取本机的ip地址</p><ul><li>A <code>getInetAddress()</code></li><li>B <code>getLocalAddress()</code></li><li>C <code>getReuseAddress()</code></li><li>D <code>getLocalPort()</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><ul><li><code>getInetAddress</code>获取主机名和<code>IP</code>地址</li><li><code>getLocalAddress()</code>顾名思义，获取本地<code>IP</code>地址</li><li><code>getReuseAddress()</code>返回布尔类型，表示复用地址</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下 b 的值是: byte b = (byte)129;</p><ul><li>A -126</li><li>B -127</li><li>C -128</li><li>D -129</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>byte型占一个字节，也就是8位，int型4个字节，32位）；二、在计算机系统中，数值一律用补码来表示（存储）<br>正数：补码=反码=原码（当然以二进制形式表达）<br>129 int类型（4个字节）二进制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 10000001</span><br></pre></td></tr></table></figure><br>强制转换byte型后，只有一个字节即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure><br>（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）<br>只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 0001</span><br></pre></td></tr></table></figure><br>（原码）<br>对应的反码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 1110</span><br></pre></td></tr></table></figure><br>又补码等于反码+1，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 1111</span><br></pre></td></tr></table></figure><br>该二进制转换int型刚好是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-127＝(1+2+4+8+16+32+64)</span><br></pre></td></tr></table></figure><br>普及一下</p><ul><li>正数原码，反码，补码相同</li><li>负数反码除了符号位不变，其他位取反，</li><li>负数补码=反码+1；</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列关于包(package)的描述,正确的是()</p><ul><li>A 包(<code>package</code>)是<code>Java</code>中描述操作系统对多个源代码文件组织的一种方式。</li><li>B <code>import</code>语句将所对应的<code>Java</code>源文件拷贝到此处执行。</li><li>C 包(<code>package</code>)是<code>Eclipse</code>组织<code>Java</code>项目特有的一种方式。</li><li>D 定义在同一个包(<code>package</code>)内的类可以不经过<code>import</code>而直接相互使用。</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>1、为了更好地组织类,Java提供了包机制。包是类的容器,用于分隔类名空间。如果没有指定包名,所有的示例都属于一个默认的无名包。Java中的包一般均包含相关的类,<strong>java是跨平台的,所以java中的包和操作系统没有任何关系</strong>,java的包是用来组织文件的一种虚拟文件系统。A错<br>2、import语句并没有将对应的java源文件拷贝到此处仅仅是引入,告诉编译器有使用外部文件,<strong>编译的时候要去读取这个外部文件</strong>。B错<br>3、Java提供的包机制与IDE没有关系。C错<br>4、定义在同一个包(package)内的类可以不经过import而直接相互使用。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>某程序要求每次输入只能是正整数,并且每次输入的数值要求必须是100的倍数且小于等于500,则下列哪个是正确的无效等价类(        )</p><ul><li>A (0,100)、(100,200)、(200,300)、(300,400)、(400,500)、(500,+∞);</li><li>B (500,+∞)</li><li>C (500,+∞)、任意大于0小于500的非100倍数的整数;</li><li>D (-∞,100)、(100,200)、(200,300)、(300,400)、(400,500)、(500,+∞);</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="什么是有效等价类"><a href="#什么是有效等价类" class="headerlink" title="什么是有效等价类"></a>什么是有效等价类</h3><ul><li>无效等价类是指不满足软件规格说明的输入数据集合，也就是没有意义的、不合理的输入数据集合。<ul><li>利用无效等价类可以找出程序异常说明情况，检查程序的功能和性能的实现是否有不符合规格说明要求的地方。</li></ul></li></ul><h3 id="什么是无效等价类"><a href="#什么是无效等价类" class="headerlink" title="什么是无效等价类"></a>什么是无效等价类</h3><ul><li>有效等价类是指输入数据完全满足程序输入的规格说明，是有效、有意义的输入数据所构成的集合。<ul><li>利用有效等价类可以检验程序是否满足规格说明所规定的功能和性能。 </li></ul></li></ul><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于volatile关键字,下列描述不正确的是？</p><ul><li>A 用<code>volatile</code>修饰的变量,每次更新对其他线程都是立即可见的。</li><li>B 对<code>volatile</code>变量的操作是原子性的。</li><li>C 对<code>volatile</code>变量的操作不会造成阻塞。</li><li>D 不依赖其他锁机制,多线程环境下的计数器可用<code>volatile</code>实现。</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details><p>有空了解一下</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>JSP分页代码中,哪个步骤次序是正确的？</p><ul><li>A 先取总记录数,得到总页数,最后显示本页的数据。</li><li>B 先取所有的记录,得到总页数,再取总记录数,最后显示本页的数据。</li><li>C 先取总页数,得到总记录数,再取所有的记录,最后显示本页的数据。</li><li>D 先取本页的数据,得到总页数,再取总记录数,最后显示所有的记录。</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>对下面Spring声明式事务的配置含义的说明错误的是()<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txProxyTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=</span></span><br><span class="line"><span class="tag">"<span class="attr">org.springframework.transaction.interceptor.TransactionProxyFactoryBean</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"myTransactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionAttributes"</span>&gt;</span>      </span><br><span class="line"> <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"get*"</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>A 定义了声明式事务的配置模板</li><li>B 对<code>get</code>方法采用只读事务</li><li>C 缺少<code>sessionFactory</code>属性的注入</li><li>D 配置需要事务管理的<code>bean</code>的代理时,通过<code>parent</code>引用这个配置模板,代码如下:<bean id="petBiz" parent="txProxyTemplate"><property name="target" ref="petTarget"/></bean></li></ul><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>有空了解一下。</p><h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>JSP分页代码中,哪个步骤次序是正确的？</p><ul><li>A 先取总记录数,得到总页数,最后显示本页的数据。</li><li>B 先取所有的记录,得到总页数,再取总记录数,最后显示本页的数据。</li><li>C 先取总页数,得到总记录数,再取所有的记录,最后显示本页的数据。</li><li>D 先取本页的数据,得到总页数,再取总记录数,最后显示所有的记录。</li></ul><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>有空了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月24日 java1</title>
      <link href="/exam//911deefa/"/>
      <url>/exam//911deefa/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/911deefa/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/911deefa/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/911deefa/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/911deefa/#tar-cf-all-tar-*-jpg" class="header_1">tar -cf all.tar *.jpg </a>&nbsp;<br><a href="/exam/911deefa/#tar-rf-all-tar-*-gif" class="header_1">tar -rf all.tar *.gif </a>&nbsp;<br><a href="/exam/911deefa/#tar-uf-all-tar-logo-gif" class="header_1">tar -uf all.tar logo.gif </a>&nbsp;<br><a href="/exam/911deefa/#tar-tf-all-tar" class="header_1">tar -tf all.tar </a>&nbsp;<br><a href="/exam/911deefa/#tar-xf-all-tar" class="header_1">tar -xf all.tar </a>&nbsp;<br><a href="/exam/911deefa/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/911deefa/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/911deefa/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/911deefa/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/911deefa/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/911deefa/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/911deefa/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/911deefa/#考点11" class="header_1">考点11</a>&nbsp;<br><a href="/exam/911deefa/#考点12" class="header_1">考点12</a>&nbsp;<br><a href="/exam/911deefa/#考点13" class="header_1">考点13</a>&nbsp;<br><a href="/exam/911deefa/#考点14" class="header_1">考点14</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面哪段程序能够正确的实现了GBK编码字节流到UTF-8编码字节流的转换:<br>byte[] src,dst;</p><ul><li>A <code>dst=String.fromBytes(src,&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</code></li><li>B <code>dst=new String(src,&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;)</code></li><li>C <code>dst=new String(&quot;GBK&quot;,src).getBytes()</code></li><li>D <code>dst=String.encode(String.decode(src,&quot;GBK&quot;)),&quot;UTF-8&quot; )</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>先解码再编码</p><ul><li>用<code>new String(src,&quot;GBK&quot;)</code>解码得到字符串</li><li>用<code>getBytes(&quot;UTF-8&quot;)</code>得到字符串对应的<code>UTF8</code>编码字节数组</li></ul><p>String类没有fromBytes()和encode以及decode方法</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在java7中,下列哪个说法是正确的:</p><ul><li>A <code>ConcurrentHashMap</code>使用<code>synchronized</code>关键字保证线程安全</li><li>B <code>HashMap</code>实现了<code>Collection</code>接口</li><li>C <code>Arrays.asList</code>方法返回<code>java.util.ArrayList</code>对象</li><li>D <code>SimpleDateFormat</code>对象是线程不安全的</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="ConcurrentHashMap使用ReentrantLock来保证线程安全"><a href="#ConcurrentHashMap使用ReentrantLock来保证线程安全" class="headerlink" title="ConcurrentHashMap使用ReentrantLock来保证线程安全"></a><code>ConcurrentHashMap</code>使用<code>ReentrantLock</code>来保证线程安全</h3><p><code>ConcurrentHashMap</code>使用<code>segment</code>来分段和管理锁,<code>segment</code>继承自<code>ReentrantLock</code>,因此<code>ConcurrentHashMap</code>使用<code>ReentrantLock</code>来保证线程安全。</p><h3 id="Arrays-asList-返回Arrays类的静态内部类"><a href="#Arrays-asList-返回Arrays类的静态内部类" class="headerlink" title="Arrays.asList()返回Arrays类的静态内部类"></a><code>Arrays.asList()</code>返回<code>Arrays</code>类的静态内部类</h3><p><code>Arrays.asList()</code>将一个数组转化为一个<code>List</code>对象,这个方方法返回一个<code>ArrayList</code>类型的对象, 这个<code>ArrayList</code>类是<code>Arrays</code>类的静态内部类<br>而不是<code>java.util.ArrayList</code>类,</p><p>不能对这个列表进行添加删除更新操作,否则会报<code>UnsupportedOperationException</code>异常。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下哪个命令用于查看tar(backup.tar)文件的内容而不提取它?()</p><ul><li>A <code>tar -xvf backup.tar</code></li><li>B <code>tar -tvf backup.tar</code></li><li>C <code>tar -svf backup.tar</code></li><li>D <code>none of these</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="Linux解压缩和压缩命令"><a href="#Linux解压缩和压缩命令" class="headerlink" title="Linux解压缩和压缩命令"></a>Linux解压缩和压缩命令</h3><p>有空了解一下<br>把常用的tar解压命令总结下，当作备忘：<br>tar<br>-c: 建立压缩档案<br>-x：解压<br>-t：查看内容<br>-r：向压缩归档文件末尾追加文件<br>-u：更新原压缩包中的文件<br>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。<br>-z：有gzip属性的<br>-j：有bz2属性的<br>-Z：有compress属性的<br>-v：显示所有过程<br>-O：将文件解开到标准输出<br>下面的参数-f是必须的<br>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</p><h1 id="tar-cf-all-tar-jpg"><a href="#tar-cf-all-tar-jpg" class="headerlink" title="tar -cf all.tar *.jpg"></a>tar -cf all.tar *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</p><h1 id="tar-rf-all-tar-gif"><a href="#tar-rf-all-tar-gif" class="headerlink" title="tar -rf all.tar *.gif"></a>tar -rf all.tar *.gif</h1><p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p><h1 id="tar-uf-all-tar-logo-gif"><a href="#tar-uf-all-tar-logo-gif" class="headerlink" title="tar -uf all.tar logo.gif"></a>tar -uf all.tar logo.gif</h1><p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p><h1 id="tar-tf-all-tar"><a href="#tar-tf-all-tar" class="headerlink" title="tar -tf all.tar"></a>tar -tf all.tar</h1><p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p><h1 id="tar-xf-all-tar"><a href="#tar-xf-all-tar" class="headerlink" title="tar -xf all.tar"></a>tar -xf all.tar</h1><p>这条命令是解出all.tar包中所有文件，-x是解开的意思<br>压缩<br>tar –cvf jpg.tar <em>.jpg  将目录里所有jpg文件打包成tar.jpg<br>tar –czf jpg.tar.gz </em>.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>tar –cjf jpg.tar.bz2 <em>.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>tar –cZf jpg.tar.Z </em>.jpg   将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>rar a jpg.rar <em>.jpg rar格式的压缩，需要先下载rar for linux<br>zip jpg.zip </em>.jpg   zip格式的压缩，需要先下载zip for linux<br>解压<br>tar –xvf file.tar  解压 tar包<br>tar -xzvf file.tar.gz 解压tar.gz<br>tar -xjvf file.tar.bz2   解压 tar.bz2<br>tar –xZvf file.tar.Z   解压tar.Z<br>unrar e file.rar 解压rar<br>unzip file.zip 解压zip<br>总结<br><em>.tar 用 tar –xvf 解压</em>.gz 用 gzip -d或者gunzip 解压<br><em>.tar.gz和</em>.tgz 用 tar –xzf 解压<br><em>.bz2 用 bzip2 -d或者用bunzip2 解压</em>.tar.bz2用tar –xjf 解压<br><em>.Z 用 uncompress 解压</em>.tar.Z 用tar –xZf 解压<br><em>.rar 用 unrar e解压</em>.zip 用 unzip 解压<br>linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。<br>1．命令格式：<br>tar[必要参数][选择参数][文件]<br>2．命令功能：<br>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的<br>3．命令参数：<br>必要参数有如下：<br>-A 新增压缩文件到已存在的压缩<br>-B 设置区块大小<br>-c 建立新的压缩文件<br>-d 记录文件的差别<br>-r 添加文件到已经压缩的文件<br>-u 添加改变了和现有的文件到已经存在的压缩文件<br>-x 从压缩的文件中提取文件<br>-t 显示压缩文件的内容<br>-z 支持gzip解压文件<br>-j 支持bzip2解压文件<br>-Z 支持compress解压文件<br>-v 显示操作过程<br>-l 文件系统边界设置<br>-k 保留原有文件不覆盖<br>-m 保留文件不被覆盖<br>-W 确认压缩文件的正确性<br>可选参数如下：<br>-b 设置区块数目<br>-C 切换到指定目录<br>-f 指定压缩文件<br>—help 显示帮助信息<br>—version 显示版本信息<br>4．常见解压/压缩命令<br>tar<br>解包：tar xvf FileName.tar<br>打包：tar cvf FileName.tar DirName<br>（注：tar是打包，不是压缩！）<br>.gz<br>解压1：gunzip FileName.gz<br>解压2：gzip -d FileName.gz<br>压缩：gzip FileName<br>.tar.gz 和 .tgz<br>解压：tar zxvf FileName.tar.gz<br>压缩：tar zcvf FileName.tar.gz DirName<br>.bz2<br>解压1：bzip2 -d FileName.bz2<br>解压2：bunzip2 FileName.bz2<br>压缩： bzip2 -z FileName<br>.tar.bz2<br>解压：tar jxvf FileName.tar.bz2<br>压缩：tar jcvf FileName.tar.bz2 DirName<br>.bz<br>解压1：bzip2 -d FileName.bz<br>解压2：bunzip2 FileName.bz<br>压缩：未知<br>.tar.bz<br>解压：tar jxvf FileName.tar.bz<br>压缩：未知<br>.Z<br>解压：uncompress FileName.Z<br>压缩：compress FileName<br>.tar.Z<br>解压：tar Zxvf FileName.tar.Z<br>压缩：tar Zcvf FileName.tar.Z DirName<br>.zip<br>解压：unzip FileName.zip<br>压缩：zip FileName.zip DirName<br>.rar<br>解压：rar x FileName.rar<br>压缩：rar a FileName.rar DirName<br>5．使用实例<br>实例1：将文件全部打包成tar包<br>命令：<br>tar -cvf log.tar log2012.log<br>tar -zcvf log.tar.gz log2012.log<br>tar -jcvf log.tar.bz2 log2012.log</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>jdk1.8版本之前的前提下,接口和抽象类描述正确的有( )</p><ul><li>A 抽象类没有构造函数</li><li>B 接口没有构造函数</li><li>C 抽象类不允许多继承</li><li>D 接口中的方法可以有方法体</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>抽象类可以有构造函数。只是不能被实例化！<br>JDK8以后的默认方法和静态方法可以有方法体，题目的方法应该是指普通方法</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下选项中,合法的赋值语句是()</p><ul><li>A <code>a&gt;1;</code></li><li>B <code>i++;</code></li><li>C <code>a= a+1=5;</code></li><li>D <code>y = int ( i );</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details>`i++`算是自我赋值D选择不一定对y为short、byte、char时，y = （int）i; //发生向下转型，不可赋值# 考点6执行完以下代码 int [ ]  x = new int[10] ;后,以下哪项说明是正确的( )- A `x[9]`为0- B `x[9]`未定义- C `x[10]`为0- D `x[0]`为空## 解析<details><summary>显示答案/隐藏答案</summary>正确答案: A</details><ul><li>基本类型数组: <code>byte[],short[],int[]</code> ,默认值为0；</li><li><code>boolean[]</code>默认值为<code>false</code>；</li><li><code>float[],double[]</code>,默认值为0.0；</li><li>对象类型数组: 默认值为<code>null</code></li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Java的体系结构包含(    )。</p><ul><li>A <code>Java</code>编程语言</li><li>B <code>Java</code>类文件格式</li><li>C <code>Java API</code></li><li>D <code>JVM</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下代码的循环次数是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 0</li><li>B 1</li><li>C 7</li><li>D 无限次</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>每次循环都减2,7÷2不可能等于0。所以死循环。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>一个Java源程序文件中定义几个类和接口,则编译该文件后生成几个以.class为后缀的字节码文件。</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>如果类中有内部类，会产生<code>类名$内部类名.class</code>，<br>如果有匿名类则会产生<code>类名$1.class</code></p><p>有空测试一下</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>java8中,下面哪个类用到了解决哈希冲突的开放定址法 </p><ul><li>A <code>LinkedHashSet</code></li><li>B <code>HashMap</code></li><li>C <code>ThreadLocal</code></li><li>D <code>TreeMap</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>ThreadLocalMap使用开放定址法解决hash冲突，</li><li>HashMap使用链地址法解决hash冲突。</li></ul><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>Java程序的种类有( )</p><ul><li>A 类(<code>Class)</code></li><li>B <code>Applet</code></li><li>C <code>Application</code></li><li>D <code>Servlet</code></li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>java程序的种类有:<br>内嵌于web文件中,由浏览器来观看的Applet<br>可独立运行的Application<br>服务器端的Servlet</p><h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>有这样一段程序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123; </span><br><span class="line">        List list=<span class="keyword">new</span> ArrayList(); </span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        Set set=<span class="keyword">new</span> HashSet(); </span><br><span class="line">        set.add(<span class="string">"a"</span>); </span><br><span class="line">        set.add(<span class="string">"b"</span>); </span><br><span class="line">        set.add(<span class="string">"a"</span>); </span><br><span class="line">        System.out.println(list.size()+<span class="string">","</span>+set.size()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>请问运行主要的程序会打印出的是什么()</p><ul><li>A 2,2</li><li>B 2,3</li><li>C 3,2</li><li>D 3,3</li></ul><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>list有序可重复，set无序不可重复</p><h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>以下程序输出()<br>public static void main(String[] args) {<br>   int num = 2;<br>   switch (num) {<br>   case 1:<br>        ++num;<br>   case 2:<br>        ++num;<br>   case 3:<br>        ++num;<br>   default:<br>        ++num;<br>   break;<br>   }<br>   System.out.println(num);<br> }<br>}</p><ul><li>A 2</li><li>B 3</li><li>C 4</li><li>D 5</li></ul><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="case遇到break才跳出"><a href="#case遇到break才跳出" class="headerlink" title="case遇到break才跳出"></a>case遇到break才跳出</h3><ul><li>匹配到case 2 num等于3 </li><li>但是其后没有break,所以继续执行case 3 num等于4、</li><li>还是没有break，继续匹配到default语句  num等于5</li></ul><p>所以答案为 5</p><h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>以下代码在编译和运行过程中会出现什么情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestDemo test=<span class="keyword">new</span> TestDemo(<span class="number">88</span>);</span><br><span class="line">        System.out.println(test.count);</span><br><span class="line">    &#125;</span><br><span class="line">    TestDemo(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        count=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 编译运行通过,输出结果是88</li><li>B 编译时错误,<code>count</code>变量定义的是私有变量</li><li>C 编译时错误,<code>System.out.println</code>方法被调用时<code>test</code>没有被初始化</li><li>D 编译和执行时没有输出结果</li></ul><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月23日 java2</title>
      <link href="/exam//eac8a439/"/>
      <url>/exam//eac8a439/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/eac8a439/#考点1" class="header_1">考点1</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下哪个区域不属于新生代？</p><ul><li>A <code>eden</code>区</li><li>B <code>from</code>区</li><li>C 元数据区</li><li>D <code>to</code>区</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月23日 java1</title>
      <link href="/exam//73c1f583/"/>
      <url>/exam//73c1f583/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/73c1f583/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/73c1f583/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/73c1f583/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/73c1f583/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/73c1f583/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/73c1f583/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/73c1f583/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列程序执行后结果为( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> B();</span><br><span class="line">    B b = <span class="keyword">new</span> B();</span><br><span class="line">    System.out.println(<span class="string">"Result="</span> + a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    System.out.println(<span class="string">"Result="</span> + b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>Result=150Result=150</code></li><li>B <code>Result=100Result=100</code></li><li>C <code>Result=100Result=150</code></li><li>D <code>Result=150Result=100</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="编译看左边-运行看右边"><a href="#编译看左边-运行看右边" class="headerlink" title="编译看左边 运行看右边"></a>编译看左边 运行看右边</h3><p>编译时，看左边是否有这个方法。也就是父类引用只能调用父类中声明的方法<br>运行时，调用右边的方法，也就是调用的是new创建的实际对象的方法，</p><ul><li>如果重写了该方法，则调用子类重写的方法，</li><li>如果没有重写该方法，则调用从父类继承来的方法。</li></ul><p>静态方法编译看左，运行看左<br>成员方法编译看左，运行看右<br>成员变量编译看左，运行看左</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>有程序片段如下,以下表达式结果为 true 的是( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float  s=<span class="keyword">new</span>  Float(<span class="number">0.1f</span>);</span><br><span class="line">Float  t=<span class="keyword">new</span>  Float(<span class="number">0.1f</span>);</span><br><span class="line">Double  u=<span class="keyword">new</span>  Double(<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure></p><ul><li>A <code>s==t</code></li><li>B <code>s.equals(t)</code></li><li>C <code>u.equals(s)</code></li><li>D <code>t.equals(u)</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>Float类和Double类都重写对于的equals方法，在比较之前都会判断是否同属于Float对象或Double对象，如果不是直接返回false，如果是再继续比较对应的数值大小。<br>JDK1.8的源码如下：<br>1.Float类重写了equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float) </span><br><span class="line">          &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.Double类重写了equals方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Double) </span><br><span class="line">          &amp;&amp; (doubleToLongBits(((Double)obj).value) == doubleToLongBits(value)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="考点1-1"><a href="#考点1-1" class="headerlink" title="考点1"></a>考点1</h1><p>Math.floor(-8.5)=( )</p><ul><li>A (<code>float)-8.0</code></li><li>B (<code>long)-9</code></li><li>C (<code>long)-8</code></li><li>D (<code>double)-9.0</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>Math.floor(-8.5)=( )</p><ul><li>A (<code>float)-8.0</code></li><li>B (<code>long)-9</code></li><li>C (<code>long)-8</code></li><li>D (<code>double)-9.0</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>Math.floor()   表示向下取整，返回double类型   （floor—-地板）<br>Math.ceil()   表示向上取整，返回double类型    （ceil—-天花板）<br>Math.round()  四舍五入，返回int类型</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面关于volatile的功能说法正确的是哪个</p><ul><li>A 原子性</li><li>B 有序性</li><li>C 可见性</li><li>D 持久性</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><ul><li>synchronized保证三大性，原子性，有序性，可见性，</li><li>volatile保证有序性，可见性，不能保证原子性。</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下哪几种方式可用来实现线程间通知和唤醒:( )</p><ul><li>A <code>Object.wait/notify/notifyAll</code></li><li>B <code>ReentrantLock.wait/notify/notifyAll</code></li><li>C <code>Condition.await/signal/signalAll</code></li><li>D <code>Thread.wait/notify/notifyAll</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AC</details><p>wait()、notify()和notifyAll()是Object类中的方法；<br>Condition是在java1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、 notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>JavaWEB中有一个类,当会话种邦定了属性或者删除了属性时,他会得到通知,这个类是:(    )</p><ul><li>A <code>HttpSessionAttributeListener</code></li><li>B <code>HttpSessionBindingListener</code></li><li>C <code>HttpSessionObjectListener</code></li><li>D <code>HttpSessionListener;</code></li><li>E <code>HttpSession</code></li><li>F <code>HttpSessionActivationListener</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>HttpSessionAttributeListener：可以实现此侦听器接口获取此web应用程序中<strong>会话属性列表更改的通知</strong>；<br>HttpSessionBindingListener：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；<br>HttpSessionObjectListener：没有该接口API；<br>HttpSessionListener：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；<br>HttpSessionActivationListener：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月22日 java1</title>
      <link href="/exam//9c039ebd/"/>
      <url>/exam//9c039ebd/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/9c039ebd/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/9c039ebd/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/9c039ebd/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/9c039ebd/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/9c039ebd/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/9c039ebd/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面所示的java代码,运行时,会产生()类型的异常<br>int Arry_a[] = new int[10];<br>System.out.println(Arry_a[10]);</p><ul><li>A <code>ArithmeticException</code></li><li>B <code>NullPointException</code></li><li>C <code>IOException</code></li><li>D <code>ArrayIndexOutOfBoundsException</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p><img src="https://uploadfiles.nowcoder.com/images/20160921/5459305_1474429057978_AE040A3D9B415BA24D436E0954EAD4D4" alt="这里有图片"></p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下哪个区域不属于新生代？</p><ul><li>A <code>eden</code>区</li><li>B <code>from</code>区</li><li>C 元数据区</li><li>D <code>to</code>区</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p><code>Java</code> 中的堆是<code>JVM</code> 所管理的最大的一块内存空间,主要用于存放各种类的实例对象。<br>在<code>Java</code> 中,<code>堆</code>被划分成两个不同的区域:</p><ul><li>新生代(<code>Young</code>)、</li><li>老年代(<code>Old</code>)。</li></ul><p>新生代(<code>Young</code>)又被划分为三个区域:</p><ul><li><code>Eden</code>、</li><li><code>From Survivor</code>、</li><li><code>To Survivor</code>。</li></ul><p>这样划分的目的是为了使 <code>JVM</code> 能够更好的管理堆内存中的对象,包括内存的分配以及回收。<br>堆的内存模型大致为:<br><a href="http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png" target="_blank" rel="noopener">这里有图片</a><br>从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。<br>本人使用的是 JDK1.6，以下涉及的 JVM 默认值均以该版本为准。<br>默认的新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：</p><ul><li>新生代 ( Young ) = 1/3 的堆空间大小。</li><li>老年代 ( Old ) = 2/3 的堆空间大小。</li></ul><p>其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。<br>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： </p><ul><li>Eden = 8/10 的新生代空间大小，</li><li>from = to = 1/10 的新生代空间大小。</li></ul><p>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，<strong>总是有一块 Survivor 区域是空闲着的</strong>。<br>因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下JAVA程序代码的输出是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">17</span>^<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 12</li><li>B 22</li><li>C 20</li><li>D 1419857</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p> 异或运算是一个二进制运算：两者相同为0，两者不同为1</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算</th><th style="text-align:left">数据</th></tr></thead><tbody><tr><td style="text-align:left">17</td><td style="text-align:left">0001 0001</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">0000 0101</td></tr><tr><td style="text-align:left">亦或结果</td><td style="text-align:left">0001 0100</td></tr><tr><td style="text-align:left">转10进制</td><td style="text-align:left">20</td></tr></tbody></table></div><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面程序的运行结果是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Wangyi;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SonB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Base base = <span class="keyword">new</span> Son();</span><br><span class="line">        base.method();</span><br><span class="line">        base.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A Base SonB</li><li>B Son SonB</li><li>C Base Son SonB</li><li>D 编译不通过</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="多态-编译看左边-运行看右边"><a href="#多态-编译看左边-运行看右边" class="headerlink" title="多态 编译看左边 运行看右边"></a>多态 编译看左边 运行看右边</h3><p>这类多态问题中，无论向上或向下转型，都记住一句话就可以了。<br><strong>编译看左边，运行看右边</strong></p><ul><li>意思编译时候，看左边有没有该方法，</li><li>运行的时候结果看new的对象是谁，就调用谁的方法。</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>关于 访问权限说法正确 的是 ？ (    )</p><ul><li>A 类定义前面可以修饰<code>public,protected</code>和<code>private</code></li><li>B 内部类前面可以修饰<code>public,protected</code>和<code>private</code></li><li>C 局部内部类前面可以修饰<code>public,protected</code>和<code>private</code></li><li>D 以上说法都不正确</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="内部类分类"><a href="#内部类分类" class="headerlink" title="内部类分类"></a>内部类分类</h3><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：</p><ul><li>成员内部类，</li><li>局部内部类，</li><li>匿名内部类，</li><li>静态内部类 。</li></ul><h3 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1.成员内部类"></a>1.成员内部类</h3><h4 id="成员内部类中可以访问外部类的所有成员"><a href="#成员内部类中可以访问外部类的所有成员" class="headerlink" title="成员内部类中可以访问外部类的所有成员"></a>成员内部类中可以访问外部类的所有成员</h4><p>该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；</p><h4 id="成员内部类的成员会隐藏外部类成员"><a href="#成员内部类的成员会隐藏外部类成员" class="headerlink" title="成员内部类的成员会隐藏外部类成员"></a>成员内部类的成员会隐藏外部类成员</h4><p>成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即成员内部类中，默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：<br>【外部类.this.成员变量  或  外部类.this.成员方法】；</p><h4 id="外部类中要先创建内部类对象才能调用内部类的成员"><a href="#外部类中要先创建内部类对象才能调用内部类的成员" class="headerlink" title="外部类中要先创建内部类对象才能调用内部类的成员"></a>外部类中要先创建内部类对象才能调用内部类的成员</h4><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p><h4 id="内部类可以拥有四种访问权限"><a href="#内部类可以拥有四种访问权限" class="headerlink" title="内部类可以拥有四种访问权限"></a>内部类可以拥有四种访问权限</h4><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。</p><ul><li>如果成员内部类用private修饰，则只能在外部类的内部访问；</li><li>如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；</li><li>如果是默认访问权限，则只能在同一个包下访问。</li><li>如果用public修饰，则任何地方都能访问；</li></ul><h4 id="外部类只能有两种访问权限"><a href="#外部类只能有两种访问权限" class="headerlink" title="外部类只能有两种访问权限"></a>外部类只能有两种访问权限</h4><p>外部类只能被public和包访问两种权限修饰。</p><h3 id="2-局部内部类"><a href="#2-局部内部类" class="headerlink" title="2.局部内部类"></a>2.局部内部类</h3><h4 id="局部内部类只在方法或者代码块中可见"><a href="#局部内部类只在方法或者代码块中可见" class="headerlink" title="局部内部类只在方法或者代码块中可见"></a>局部内部类只在方法或者代码块中可见</h4><p>局部内部类是定义在一个方法或者一个代码块里面的类<br>它和成员内部类的区别在于<br>局部内部类的访问仅限于方法内或者该作用域内；</p><h4 id="局部内部类不能用访问修饰符修饰"><a href="#局部内部类不能用访问修饰符修饰" class="headerlink" title="局部内部类不能用访问修饰符修饰"></a>局部内部类不能用访问修饰符修饰</h4><p>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p><h3 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h3><ul><li>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</li><li>匿名内部类是唯一一种没有构造器的类；</li><li>匿名内部类是不能有访问修饰符和static修饰符的；</li><li>一般使用匿名内部类的方法来编写事件监听代码；<h4 id="4-内部静态类"><a href="#4-内部静态类" class="headerlink" title="4.内部静态类"></a>4.内部静态类</h4></li><li>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；</li><li>静态成员不能访问非静态成员，也就是静态内部类不能使用外部类的非static成员变量或者方法</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪一项不属于优化Hibernate所鼓励的？</p><ul><li>A 使用单向一对多关联,不使用双向一对多</li><li>B 不用一对一,用多对一取代</li><li>C 配置对象缓存,不使用集合缓存</li><li>D 继承类使用显式多态</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>有空了解一下</p><h3 id="优化Hibernate所鼓励的7大措施"><a href="#优化Hibernate所鼓励的7大措施" class="headerlink" title="优化Hibernate所鼓励的7大措施"></a>优化Hibernate所鼓励的7大措施</h3><p>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit”<br>避免查处所有对象<br>7.消除大表，使用二级缓存</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月16日 java1</title>
      <link href="/exam//c0a58c6/"/>
      <url>/exam//c0a58c6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c0a58c6/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/c0a58c6/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/c0a58c6/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/c0a58c6/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/c0a58c6/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/c0a58c6/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Java的Daemon线程,setDaemon( )设置必须要？</p><ul><li>A 在<code>start</code>之前</li><li>B 在<code>start</code>之后</li><li>C 前后都可以</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>setDaemon()方法必须在线程启动之前调用，当线程正在运行时调用会产生异常。</p><h3 id="java中线程分类"><a href="#java中线程分类" class="headerlink" title="java中线程分类"></a>java中线程分类</h3><ul><li>前台线程。通过Thread.setDaemon(false)设置为前台线程;</li><li>守护线程。通过Thread.setDaemon(true)设置为守护线程</li></ul><p>前台线程创建的线程默认就是前台线程。</p><p>多线程方面的需要加强<br>有空了解一下</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在java7中,下列不能做switch()的参数类型是？</p><ul><li>A <code>int</code>型</li><li>B 枚举类型</li><li>C 字符串</li><li>D 浮点型</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>switch支持：</p><ul><li>支持小于等于int的类型（byte,short,char,int），</li><li>不支持八大基础数据类型中的boolean,long,float,double</li><li>支持枚举类型</li><li>java7开始支持支持String类型</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>在Java图形用户界面编程中,如果需要显示信息,一般是使用<strong><strong>__</strong></strong>类的对象来实现。</p><ul><li>A <code>JLabel</code></li><li>B <code>JButton</code></li><li>C <code>JTextArea</code></li><li>D <code>JtextField</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><ul><li>JTextField单行文本</li><li>JTextArea多行文本</li><li>JButton按键显示</li><li>JLable显示标签 信息</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>以下哪些方法可以取到http请求中的cookie值()?</p><ul><li>A <code>request.getAttribute</code></li><li>B <code>request.getHeader</code></li><li>C <code>request.getParameter</code></li><li>D <code>request.getCookies</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details><p>下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 HttpServletRequest 对象可用：<br>1）Cookie[] getCookies()<br>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。<br>2）Object getAttribute(String name)<br>以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。<br>3）String getHeader(String name)<br>以字符串形式返回指定的请求头的值。Cookie也是头的一种；<br>4）String getParameter(String name)<br>以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。</p><p>JSP servlet方面的知识忘记了，有空了解一下</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面程序段执行后b的值是()。<br>Integer integ =new Integer(9);<br>boolean b = integ  instanceof  Object;</p><ul><li>A 9</li><li>B <code>true</code></li><li>C 1</li><li>D <code>false</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>A instanceOf B，是判断对象A</p><ul><li>是否属于B类的实例</li><li>是否属于B类的子类的实例</li><li>是否属于B接口的实现类的实例</li><li>是否属于B接口的子接口的实现类的实例。</li></ul><p>任何数据类型都可以赋值给Object对象。<br><img src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/hexoSettings/FrontAwesome/find.png" alt="测试"></p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下哪些类是线程安全的()</p><ul><li>A <code>Vector</code></li><li>B <code>HashMap</code></li><li>C <code>ArrayList</code></li><li>D <code>StringBuffer</code></li><li>E <code>Properties</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADE</details>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月15日 js1</title>
      <link href="/exam//5e5d21bc/"/>
      <url>/exam//5e5d21bc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/5e5d21bc/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/5e5d21bc/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下哪一个不是JavaScript的数据类型:</p><ul><li>A <code>String</code></li><li>B <code>Boolean</code></li><li>C <code>Integer</code></li><li>D <code>Undefined</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="JavaScript中的数据类"><a href="#JavaScript中的数据类" class="headerlink" title="JavaScript中的数据类"></a>JavaScript中的数据类</h3><ul><li>基本类型:Undefined,Null,Boolean,Number.</li><li>引用类型:Object, Array, Function</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下代码执行的结果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 0,1,2</li><li>B 1,2,3</li><li>C 3,3,3</li><li>D 0,0,0</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>每次for循环的时候setTimeout都会执行，因为setTimeout是<strong>异步函数</strong>，里面的function则不会立即执行，而是会被放入任务队列，因此放了3次；<br>任务队列中的函数会在for循环结束之后执行。<br>for循环的3次执行完之后,i变为3，也就是每次循环，i都会被后一个i值覆盖。所以就是输出3个3。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>请问在javascript程序中,alert(undefined==null)的输出结果是</p><ul><li>A <code>null</code></li><li>B <code>undefined</code></li><li>C <code>true</code></li><li>D <code>false</code></li><li>E 以上答案都不正确</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>==仅判断<code>值</code>是否相同，undefined值和null是相同的，故true<br>===在判断值是否相同的同时<strong>还判断类型是否相同</strong>，</p><ul><li>undefined类型为undefined，</li><li>null类型为object，</li><li>因此为false</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>var str1=new RegExp(“e”);<br>document.write(str1.exec(“hello”));<br>以上代码输出结果为(      )</p><ul><li>A e</li><li>B <code>null</code></li><li>C 1</li><li>D 其他几项都不对</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="正则表达式方法-exec-方法"><a href="#正则表达式方法-exec-方法" class="headerlink" title="正则表达式方法 exec()方法"></a>正则表达式方法 exec()方法</h3><p>exec()方法用于检索字符串中的匹配正则表达式的子串<br>该函数返回一个数组，其中存放匹配的子串。如果未找到匹配，则返回值为 null。</p><p>JavaScript高级程序设计<br>有空了解一下</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列关于 JavaScript 的说法中正确的是()</p><ul><li>A 所有变量在使用之前必须做声明</li><li>B <code>JavaScript</code>是面向对象的程序设计语言</li><li>C <code>JavaScript</code>是解释性语言</li><li>D <code>JavaScript</code>前身是<code>Oak</code>语言</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details>### 解释性语言和编译型语音**解释性语言**是相对于**编译型语言**存在的，**编译型语言**源代码直接翻译成`机器语言`，解释性语言源代码先翻译成中间代码，再由解释器对中间代码进行解释运行。比如Python/JavaScript / Perl /Shell等都是解释型语言。### JavaScript局部变量可以不声明A如果是局部变量无需声明，也可以使用，如下所示。所以A错误。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">    for(i=0;i&lt;20;i++)&#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 没有 var i</span></span></span><br><span class="line"><span class="actionscript">    &#125;      <span class="keyword">return</span> i;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.writeln(a());</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>### javascript不是面向对象语言javascript没有继承性，所以B错误。D选项中JAVA的前身才是Oak，而不是JavaScript。所以D错误。# 考点6下面有关JavaScript中 call和apply的描述,错误的是？- A `call`与`apply`都属于`Function.prototype`的一个方法,所以每个`function`实例都有`call`、`apply`属性- B 两者传递的参数不同,`call`函数第一个参数都是要传入给当前对象的对象,`apply`不是- C `apply`传入的是一个参数数组,也就是将多个参数组合成为一个数组传入- D `call`传入的则是直接的参数列表。`call` 方法可将一个函数的对象上下文从初始的上下文改变为由 `thisObj` 指定的新对象。## 解析<details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>有空了解一下</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>typeof Date.now() 的值是:</p><ul><li>A date</li><li>B object</li><li>C number</li><li>D error</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>Date.now() 方法返回自1970年1月1日 00:00:00 UTC到当前时间的<strong>毫秒数</strong>。<br>故该题为number</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>0xff ^ 33 的结果是:</p><ul><li>A 220</li><li>B 221</li><li>C 222</li><li>D 223</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0xff＝1111 1111(255)</span><br><span class="line"></span><br><span class="line">1111 1111(255)</span><br><span class="line">0010 0001(33)</span><br><span class="line">异或操作     </span><br><span class="line">1101 1110(222)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月15日 java3</title>
      <link href="/exam//93382e9/"/>
      <url>/exam//93382e9/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'93382e9'/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/'93382e9'/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/'93382e9'/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/'93382e9'/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/'93382e9'/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/'93382e9'/#考点7" class="header_1">考点7</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>执行下列代码的输出结果是( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(test(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            b += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(RuntimeException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e2)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            b += <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 10</li><li>B 20</li><li>C 30</li><li>D 40</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>如果finally块中有return语句的话，它将覆盖掉try或者catch语句中其他return语句。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>给出以下代码,请给出结果.<br>class Two{<br>    Byte x;<br>}<br>class PassO{<br>    public static void main(String[] args){<br>        PassO p=new PassO();<br>        p.start();<br>    }<br>    void start(){<br>        Two t=new Two();<br>        System.out.print(t.x+””);<br>        Two t2=fix(t);<br>        System.out.print(t.x+” “ +t2.x);<br>    }<br>    Two fix(Two tt){<br>        tt.x=42;<br>        return tt;<br>    }<br>}</p><ul><li>A <code>null null 42</code></li><li>B <code>null 42 42</code></li><li>C 0 0 42</li><li>D 0 42 42</li><li>E <code>An exception is thrown at runtime</code></li><li>F <code>Compilation</code></li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>成员变量会默认初始化。<br>Byte是byte的包装类型，初始化为null而不是0</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下关于对象序列化描述正确的是</p><ul><li>A 使用<code>FileOutputStream</code>可以将对象进行传输</li><li>B 使用<code>PrintWriter</code>可以将对象进行传输</li><li>C 使用<code>transient</code>修饰的变量不会被序列化</li><li>D 对象序列化的所属类需要实现<code>Serializable</code>接口</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.</p><h3 id="什么是对象序列化"><a href="#什么是对象序列化" class="headerlink" title="什么是对象序列化"></a>什么是<code>对象</code>序列化</h3><p>Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。</p><p>使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，<strong>对象序列化保存的是</strong><code>对象</code>的”状态”，即它的成员变量<strong>。<br>由此可知，</strong>对象序列化不会关注类中的静态变量**。</p><p>A、B：使用ObjectInputStream和ObjectoutputStream进行对象的传输<br>注意：<br>1.基本数据类型的变量可以直接序列化<br>2.对象要被序列化，它的类必须实现Serializable接口，如果一个类中有引用类型的变量，这个引用类型的变量的类也必须实现Serializable接口。如果这个引用类型的变量不想被实例化，则用transient修饰（ObjectInputStream）</p><h3 id="对象序列化只能保存对象的数据"><a href="#对象序列化只能保存对象的数据" class="headerlink" title="对象序列化只能保存对象的数据"></a>对象序列化只能保存对象的数据</h3><p>而static代表类的状态， transient代表对象的临时数据。<br>所以声明为static和transient类型的成员数据不能被序列化。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>What might cause the current thread to stop or pause executing</p><ul><li>A An InterruptedException is thrown.</li><li>B The thread executes a wait() call.</li><li>C The thread constructs a new Thread.</li><li>D A thread of higher priority becomes ready.</li><li>E The thread executes a waitforID()call on a MediaTracker.</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABE</details><p>题目:什么操作会使得当前线程停止。<br>A:一个InterruptedException 异常被捕获  大家都知道的嘛 (一般通过interrupt方法 中断线程)  如果抓到一个线程  都会关紧catch里面 然后中断当前操作,A正确。<br>B:线程执行了wait()方法。   线程使用了wait方法,会强行打断当前操作,(暂停状态,不会中断线程) 进入阻塞(暂停)状态,然后需要notify方法或notifyAll方法才能进入就绪状态。 B 正确。<br>C:当前线程创建了一个新的线程。   新创建的线程不会抢占时间片,只有等当前线程把时间片用完,其他线程才有资格拿到时间片去执行。<br>D:一个高优先级别的线程就绪。  如C相同,你优先级别再高 也待等我现在弄完才会给你。(就像我们玩游戏,会员虽然有排队优先权,但是还是要等正在登陆的用户进去游戏之后才能抢到他原来那个位置,不能说我在过关卡的过程中你一脚把我踢开,然后霸占我的位置吧,我原来的那些数据咋办!!!)<br>E:线程在MediaTracker上执行了waitforID()调用。<br>这个应该大家也不太熟悉。这个类是awt里面的,我查API才知道。<br>然后他的功能是加载图像,直到完成之前,该方法一直等待!这个方法是必须要抛出A选项的InterruptedException 异常的  说明这玩意会让其他线程 wait他完成!   所以会暂停当前线程</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些描述是正确的:(  )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> B ref;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">            ref = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class B &#123;</span><br><span class="line">        <span class="keyword">private</span> A ref;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">            ref = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        …start();</span><br><span class="line">        ….</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        a.setB(b);</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//a = null;</span></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>b = null</code>执行后b可以被垃圾回收</li><li>B <code>a = null</code>执行后b可以被垃圾回收</li><li>C <code>a = null</code>执行后a可以被垃圾回收</li><li>D <code>a,b</code>必须在整个程序结束后才能被垃圾回收</li><li>E 类A和类B在设计上有循环引用,会导致内存泄露</li><li>F <code>a, b</code> 必须在<code>start</code>方法执行完毕才能被垃圾回收</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>内存如下：<br>a -&gt; “a(b)”<br>b -&gt; “b”<br>a引用指向一块空间，这块空间里面包含着b对象<br>b引用指向一块空间，这块空间是b对象<br>A选项，b = null执行后b可以被垃圾回收。这里”b可以被垃圾回收”中的b指的是引用b指向的内存。这块内存即使不被引用b指向，还是被引用a指向着，不会被回收。<br>B选项，a = null执行后b可以被垃圾回收。从代码中可以看到，a = null是在b = null后执行的，该行执行后，引用a和b都没有指向对象，对象会被回收。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对 Map 的用法,正确的有:</p><ul><li>A <code>new java.util.Map().put(&quot;key&quot; , &quot;value&quot;) ;</code></li><li>B <code>new java.util.SortedMap().put(&quot;key&quot; , &quot;value&quot;) ;</code></li><li>C <code>new java.util.HashMap().put( null , null ) ;</code></li><li>D <code>new java.util.TreeMap().put( 0 , null ) ;</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><h3 id="接口不能new"><a href="#接口不能new" class="headerlink" title="接口不能new"></a>接口不能new</h3><p>A选项Map属于<strong>接口</strong>类型，不可以new的方式创建对象。所以A错误。<br>B选项SortedMap属于<strong>接口</strong>类型，不可以new的方式创建对象。所以B错误。</p><h3 id="TreeMap的key不能为null"><a href="#TreeMap的key不能为null" class="headerlink" title="TreeMap的key不能为null"></a>TreeMap的key不能为null</h3><p>C选项HashMap基于哈希表实现Map接口的类，并允许null的值和null键。<br>D选项TreeMap通过红黑树实现Map接口的类，<strong>key不可以为null</strong>，会报NullPointerException异常,value可以为null。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月15日 java2</title>
      <link href="/exam//7e34b27f/"/>
      <url>/exam//7e34b27f/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/7e34b27f/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/7e34b27f/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/7e34b27f/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/7e34b27f/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/7e34b27f/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/7e34b27f/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/7e34b27f/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/7e34b27f/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/7e34b27f/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/7e34b27f/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>已知表达式int m[]={0,1,2,3,4,5,6};下面哪个表达式的值与数组下标量最大值相等？</p><ul><li>A <code>m. length()</code></li><li>B <code>m. length-1</code></li><li>C <code>m. length()+1</code></li><li>D <code>m. length+1</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><div class="table-container"><table><thead><tr><th style="text-align:left">获取长度的方式</th><th style="text-align:left">数据类型</th></tr></thead><tbody><tr><td style="text-align:left"><code>length</code>属性</td><td style="text-align:left">数组</td></tr><tr><td style="text-align:left"><code>length()</code></td><td style="text-align:left">String`</td></tr><tr><td style="text-align:left"><code>size()</code></td><td style="text-align:left">集合</td></tr></tbody></table></div><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>与未加访问控制符的缺省情况相比,public和protected修饰符扩大了属性和方法的被访问范围,private修饰符则缩小了这种范围。</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>区分类中重载方法的依据是(    )。</p><ul><li>A 不同的形参名称</li><li>B 不同的返回值类型</li><li>C 不同的形参列表</li><li>D 不同的访问权限</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>字符界面下接受用户从键盘输入,需要import的包是:( )</p><ul><li>A <code>java.lang</code>包</li><li>B <code>java.awt</code>包</li><li>C <code>java.io</code>包</li><li>D <code>java.applet</code>包</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪个Set类是排序的？</p><ul><li>A <code>LinkedHashSet</code></li><li>B <code>TreeSet</code></li><li>C <code>HashSet</code></li><li>D <code>AbstractSet</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><ul><li>TreeSet排序，</li><li>LinkedHashSet有序。</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列关于Java并发的说法中正确的是()</p><ul><li>A <code>CopyOnWriteArrayList</code>适用于写多读少的并发场景</li><li>B <code>ReadWriteLock</code>适用于读多写少的并发场景</li><li>C <code>ConcurrentHashMap</code>的写操作不需要加锁,读操作需要加锁</li><li>D 只要在定义<code>int</code>类型的成员变量i的时候加上<code>volatile</code>关键字,那么多线程并发执行i++这样的操作的时候就是线程安全的了</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>A，CopyOnWriteArrayList适用于<strong>写少读多</strong>的并发场景<br>B，ReadWriteLock即为读写锁，他要求<strong>写与写之间互斥，读与写之间互斥</strong>，<br>   读与读之间可以并发执行。在读多写少的情况下可以提高效率<br>C，ConcurrentHashMap是同步的HashMap，<strong>读写都加锁</strong><br>D，volatile只保证多线程操作的可见性，不保证原子性</p><p>有空了解一下</p><p>CopyOnWrite指的是修改容器之前，先将原来的容器拷贝一份副本，在副本中进行修改，修改之后使用原来的容器指向修改好的容器，这样保证了两个容器可以同时读，用于<strong>读多于写</strong>的场景</p><p>volatile变量自身具有以下特性：1。可见性2.原子性：对任意单个volatile变量的读写具有原子性，但类似i++这种复合操作或者多个volatile操作不具有原子性</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>由3 个”1”和 5 个”0”组成的 8 位二进制补码,能表示的最小整数()</p><ul><li>A -126</li><li>B -125</li><li>C -32</li><li>D -3</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>一个1作为符号位，表示负数，剩下两个1,最大值是3，-(128-3)＝-125</p><p>既然求最小整数，那肯定先想到负数，则最高位（符号位）一定为1，原码中肯定是1所在的位数越高，值越小，而补码是由原码取反加1得到的，则在补码中1所在的位数一定要越低，即补码为1000 0011；由补码求得原码：1111 1101=-(64+32+16+8+4+1)=-125;</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下列Java代码中的变量a、b、c分别在内存的<em>__</em>存储区存放。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">"aa"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String b = <span class="string">"bb"</span>;</span><br><span class="line">        <span class="keyword">final</span> String c = <span class="string">"cc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 堆区、堆区、堆区</li><li>B 堆区、栈区、堆区</li><li>C 堆区、栈区、栈区</li><li>D 堆区、堆区、栈区</li><li>E 静态区、栈区、堆区</li><li>F 静态区、栈区、栈区</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>a是类中的成员变量，存放在堆区</li><li>b、c都是方法中的局部变量，存放在栈区</li></ul><p>堆区:只存放类对象,线程共享;<br>方法区:又叫静态存储区,存放class文件和静态数据,线程共享;<br>栈区:存放方法局部变量,基本类型变量区、执行环境上下文、操作指令区,线程不共享;</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>Consider the following code:<br>Integer s=new Integer(9);<br>Integer t=new Integer(9);<br>Long u=new Long(9);<br>Which test would return true?</p><ul><li>A <code>(s==u)</code></li><li>B <code>(s==t)</code></li><li>C <code>(s.equals(t))</code></li><li>D <code>(s.equals(9))</code></li><li>E <code>(s.equals(new Integer(9))</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CDE</details><p>B关于s==t，添加一点说明：<br>当Integer的值在-128~127之间时，使用拆箱方式创建Integer对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line">Integer i=<span class="number">9</span>; </span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line">Integer j=Integer.valueOf(<span class="number">9</span>);</span><br></pre></td></tr></table></figure><br>得到的对象使用==会得到true。<br>而使用new Integer()方式创建的对象，使用==会得到false。<br>当Integer的值不在这个范围内时，无论以何种方式创建两个Integer对象，使用==都会是false。</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>判断一块内存空间是否符合垃圾收集器收集的标准有哪些？</p><ul><li>A 给对象赋予了空值<code>null</code>,以下再没有调用过</li><li>B 对象重新分配了内存空间</li><li>C 给对象赋予了空值<code>null</code></li><li>D 给对象赋予了新值</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>在java语言中，判断一块内存空间是否符合垃圾收集器收集标准的标准只有两个：<br>1.给对象赋值为null，以下没有调用过。<br>2.给对象赋了新的值，重新分配了内存空间。</p><p>一块内存空间符合了垃圾收集器的收集标准，并不意味着这块内存空间就一定会被垃圾收集器收集。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月15日 java1</title>
      <link href="/exam//e73de3c5/"/>
      <url>/exam//e73de3c5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/e73de3c5/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/e73de3c5/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/e73de3c5/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/e73de3c5/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/e73de3c5/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/e73de3c5/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/e73de3c5/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/e73de3c5/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>要表示10个学生的成绩,下列声明并初始化数组正确的是()</p><ul><li>A <code>int[] score=new int[ ]</code></li><li>B <code>int score[10]</code></li><li>C <code>int score[]=new int[9]</code></li><li>D <code>int score[]=new int[10]</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>以下两种写法都可以：<br>int score[] = new int[10];<br>int[] score = new int[10];</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面有关java基本类型的默认值和取值范围,说法错误的是？</p><ul><li>A 字节型的类型默认值是0,取值范围是-2^7—2^7-1</li><li>B <code>boolean</code>类型默认值是<code>false</code>,取值范围是<code>true</code>`false`</li><li>C 字符型类型默认是0,取值范围是-2^15 —2^15-1</li><li>D <code>long</code>类型默认是0,取值范围是-2^63—2^63-1</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于下列程序段的输出结果,说法正确的是:( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 有错误,变量i没有初始化。</li><li>B <code>null</code></li><li>C 1</li><li>D 0</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>成员变量会默认初始化<br>静态成员可以访问静态成员</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java中下面哪个能创建并启动线程()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="comment">//some code here </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>new Runnable(MyRunnable).start()</code></li><li>B <code>new Thread(MyRunnable).run()</code></li><li>C <code>new Thread(new MyRunnable()).start()</code></li><li>D <code>new MyRunnable().start()</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>list是一个ArrayList的对象,哪个选项的代码填到//todo delete处,可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = list.iterator();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    Object obj = it.next();</span><br><span class="line">    <span class="comment">//needDelete返回boolean,决定是否要删除  </span></span><br><span class="line">    <span class="keyword">if</span> (needDelete(obj))&#123;</span><br><span class="line">        <span class="comment">//todo delet</span></span><br><span class="line">        e</span><br><span class="line">    &#125;</span><br><span class="line">    index ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>A it.remove();<br>B list.remove(obj);<br>C list.remove(index);<br>D list.remove(obj,index);</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>Iterator 支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。这样做的好处是可以避免 ConcurrentModifiedException ，当打开 Iterator 迭代集合时，同时又在对集合进行修改。有些集合不允许在迭代时删除或添加元素，但是调用 Iterator 的remove() 方法是个安全的做法。</p><h3 id="在循环中调用List的remove方法出现的问题"><a href="#在循环中调用List的remove方法出现的问题" class="headerlink" title="在循环中调用List的remove方法出现的问题"></a>在循环中调用List的remove方法出现的问题</h3><p>如果在循环的过程中调用集合的remove()方法，就会导致循环出错，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.remove(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>循环过程中list.size()的大小变化了，就导致了错误。</p><p>所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p><h3 id="正确使用List的remove方法删除元素的写法"><a href="#正确使用List的remove方法删除元素的写法" class="headerlink" title="正确使用List的remove方法删除元素的写法"></a>正确使用List的remove方法删除元素的写法</h3><p>for循环删除问题，如果真想用，可以这样，既不出错，也能正确删除：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String x=<span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> z=<span class="number">2</span>;</span><br><span class="line">        System.out.println(x+y+z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>关于下面的程序Test.java说法正确的是(    )。</p><ul><li>A 3</li><li>B 112</li><li>C 13</li><li>D 程序有编译错误</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><h3 id="static不能修饰局部变量"><a href="#static不能修饰局部变量" class="headerlink" title="static不能修饰局部变量"></a>static不能修饰局部变量</h3><p>被static修饰的变量称为静态变量，静态变量属于整个类，而局部变量属于方法，只在该方法内有效，所以<strong>static不能修饰局部变量</strong></p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下面代码的运行结果为:()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s;</span><br><span class="line">        System.out.println(<span class="string">"s="</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 代码得到编译,并输出”s=”</li><li>B 代码得到编译,并输出”<code>s=null</code>“</li><li>C 由于<code>String s</code>没有初始化,代码不能编译通过</li><li>D 代码得到编译,但捕获到 <code>NullPointException</code>异常</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="局部变量不会默认初始化"><a href="#局部变量不会默认初始化" class="headerlink" title="局部变量不会默认初始化"></a>局部变量不会默认初始化</h3><p>局部变量可以先声明不用必须初始化，但使用局部变量之前一定要先初始化。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>Java语言中,下面哪个语句是创建数组的正确语句？(     )</p><ul><li>A <code>float f[][] = new float[6][6];</code></li><li>B <code>float []f[] = new float[6][6];</code></li><li>C <code>float f[][] = new float[][6];</code></li><li>D <code>float [][]f = new float[6][6];</code></li><li>E <code>float [][]f = new float[6][];</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABDE</details><h3 id="二维数组变量和两个中括号可以全排列"><a href="#二维数组变量和两个中括号可以全排列" class="headerlink" title="二维数组变量和两个中括号可以全排列"></a>二维数组变量和两个中括号可以全排列</h3><h3 id="二维数组的一维长度必须确定"><a href="#二维数组的一维长度必须确定" class="headerlink" title="二维数组的一维长度必须确定"></a>二维数组的一维长度必须确定</h3><p>二维数组定义时，一维的长度必须定义，二维可以后续定义</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月14日 java1</title>
      <link href="/exam//8ff88fb/"/>
      <url>/exam//8ff88fb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/8ff88fb/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/8ff88fb/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/8ff88fb/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/8ff88fb/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/8ff88fb/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/8ff88fb/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/8ff88fb/#考点7" class="header_1">考点7</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System. out. println(<span class="string">"Value is"</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码,以下说法正确的是:<br>A 程序会打出 “Value is 0”<br>B 程序会抛出 NullPointerException<br>C 非静态变量不能够被静态方法引用<br>D 编译器会抛出 “possible reference before assignment”的错误</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>main方法是静态方法，静态成员不能访问非静态成员。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下列哪个说法是正确的()</p><ul><li>A <code>ConcurrentHashMap</code>使用<code>synchronized</code>关键字保证线程安全</li><li>B <code>HashMap</code>实现了<code>Collction</code>接口</li><li>C <code>Array.asList</code>方法返回<code>java.util.ArrayList</code>对象</li><li>D <code>SimpleDateFormat</code>是线程不安全的</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>A选项中，ConcurrentHashMap<br>使用segment来分段和管理锁，segment继承自ReentrantLock，因此<strong>ConcurrentHashMap使用ReentrantLock来保证线程安全</strong>。<br>B中，HashMap定义规则如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><br>C中，应该是Arrays.asList()，其将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象，<br>这个ArrayList类并非java.util.ArrayList类，而是Arrays类的内部类</p><p><strong>java并发集合</strong>有不懂有空了解一下</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于匿名内部类叙述正确的是？ ( )</p><ul><li>A 匿名内部类可以继承一个基类,不可以实现一个接口</li><li>B 匿名内部类不可以定义构造器</li><li>C 匿名内部类不能用于形参</li><li>D 以上说法都不正确</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="匿名内部类不能有构造器"><a href="#匿名内部类不能有构造器" class="headerlink" title="匿名内部类不能有构造器"></a>匿名内部类不能有构造器</h3><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列关于构造方法的叙述中,错误的是()</p><ul><li>A <code>java</code>语言规定构造方法名与类名必须相同</li><li>B <code>java</code>语言规定构造方法没有返回值,但不同<code>void</code>声明</li><li>C <code>java</code>语言规定构造方法不可以重载</li><li>D <code>java</code>语言规定构造方法只能通过<code>new</code>自动调用</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: CD</details><p>构造方法除了 new 关键字调用外，还可以通过如下方式调用</p><ul><li>反射</li><li>反序列化</li><li>this调用</li><li>super调用</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪些具体实现类可以用于存储键,值对,并且方法调用提供了基本的多线程安全支持:(  )</p><ul><li>A <code>java.util.ConcurrentHashMap</code></li><li>B <code>java.util.Map</code></li><li>C <code>java.util.TreeMap</code></li><li>D <code>java.util.SortMap</code></li><li>E <code>java.util.Hashtable</code></li><li>F <code>java.util.HashMap</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AE</details><p>线程安全的类有</p><ul><li>hashtable</li><li>concurrentHashMap </li><li>synchronizedMap</li></ul><p>有空了解一下</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>关于Java中的ClassLoader下面的哪些描述是错误的:(    )</p><ul><li>A 默认情况下,<code>Java</code>应用启动过程涉及三个<code>ClassLoader: Boostrap, Extension, System</code></li><li>B 一般的情况不同<code>ClassLoader</code>装载的类是不相同的,但接口类例外,对于同一接口所有类装载器装载所获得的类是相同的</li><li>C 类装载器需要保证类装载过程的线程安全</li><li>D <code>ClassLoader</code>的<code>loadClass</code>在装载一个类时,如果该类不存在它将返回<code>null</code></li><li>E <code>ClassLoader</code>的父子结构中,默认装载采用了父优先</li><li>F 所有<code>ClassLoader</code>装载的类都来自<code>CLASSPATH</code>环境指定的路径</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BDF</details><p>反射相关的内容，有空了解一下</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>class A {}<br>class B extends A {}<br>class C extends A {}<br>class D extends B {}<br>Which four statements are true ?</p><ul><li>A <code>The type List&lt;A&gt;is assignable to List.</code></li><li>B <code>The type List&lt;B&gt;is assignable to List&lt;A&gt;.</code></li><li>C <code>The type List&lt;Object&gt;is assignable to List</code>&lt;?&gt;.</li><li>D <code>The type List&lt;D&gt;is assignable to List</code>&lt;?<code>extends B&gt;.</code></li><li>E <code>The type List</code>&lt;?<code>extends A&gt;is assignable to List&lt;A&gt;.</code></li><li>F <code>The type List&lt;Object&gt;is assignable to any List reference.</code></li><li>G <code>The type List</code>&lt;?<code>extends B&gt;is assignable to List</code>&lt;?<code>extends A&gt;.</code></li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ACDG</details><p>泛型相关的内容，有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月14日 java2</title>
      <link href="/exam//91f6d941/"/>
      <url>/exam//91f6d941/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/91f6d941/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/91f6d941/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/91f6d941/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/91f6d941/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/91f6d941/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/91f6d941/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>有关线程的叙述正确的是()</p><ul><li>A 可以获得对任何对象的互斥锁定。</li><li>B 通过继承<code>Thread</code>类或实现<code>Runnable</code>接口,可以获得对类中方法的互斥锁定。</li><li>C 线程通过使用<code>synchronized</code>关键字可获得对象的互斥锁定。</li><li>D 线程的创建只能通过继承<code>Thread</code>类来实现。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>采用<code>synchronized</code>修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。<br>每个对象都有一个<code>monitor</code>(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入<strong>锁池</strong>。<br>任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做<strong>互斥锁</strong>。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>设int x=1,float y=2,则表达式x/y的值是:()</p><ul><li>A 0</li><li>B 1</li><li>C 2</li><li>D 以上都不是</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>直接量2是int类型，可以自动转成float类型<br>表达式的计算结果的类型为操作数中范围最大的<br>x/y的结果为float类型，等于0.5</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java接口的方法修饰符可以为？(忽略内部接口)</p><ul><li>A <code>private</code></li><li>B <code>protected</code></li><li>C <code>final</code></li><li>D <code>abstract</code></li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>接口方法默认public abstract</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java中提供了哪两种用于多态的机制</p><ul><li>A 通过子类对父类方法的覆盖实现多态</li><li>B 利用重载来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。</li><li>C 利用覆盖来实现多态.即在同一个类中定义多个同名的不同方法来实现多态。</li><li>D 通过子类对父类方法的重载实现多态</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AB</details><p>多态分为 编译时多态 和 运行时多态 。<br>其中 编辑时多态是静态的 ， 主要是指方法的重载 ，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。<br>而 运行时多态是动态的 ，它是 通过动态绑定来实现的 ，也就是我们所说的多态性(要有继承关系 2.子类要重写父类的方法 3.父类引用指向子类)</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列哪个选项是错误的。()</p><ul><li>A 一个文件中只能有一个<code>public class</code>。</li><li>B 一个文件中可以有多个类。</li><li>C 一个类中可以有两个<code>main</code>方法。</li><li>D 若类中只含一个<code>main</code>方法,则必须是<code>public</code>的。</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><p>A.一个文件中，可以有多个public class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即，<strong>外部类为public，还可以有public的内部类</strong>。<br>B.一个文件中可以有多个类，可以是多个并列的类，也可以是外部类、内部类结合。<br>C.一个类中，可以有多个main方法，这是重载，但是<br><code>public static void main(String[] args)</code><br>的方法只能有一个。<br>D.类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面有关java threadlocal说法正确的有？</p><ul><li>A <code>ThreadLocal</code>存放的值是线程封闭,线程间互斥的,主要用于线程内共享一些数据,避免通过参数来传递</li><li>B 线程的角度看,每个线程都保持一个对其线程局部变量副本的隐式引用,只要线程是活动的并且 <code>ThreadLocal</code> 实例是可访问的;在线程消失之后,其线程局部实例的所有副本都会被垃圾回收</li><li>C 在<code>Thread</code>类中有一个<code>Map</code>,用于存储每一个线程的变量的副本。</li><li>D 对于多线程资源共享的问题,同步机制采用了”以时间换空间”的方式,而<code>ThreadLocal</code>采用了”以空间换时间”的方式</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><p>有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月13日 java1</title>
      <link href="/exam//ea239382/"/>
      <url>/exam//ea239382/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/ea239382/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/ea239382/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/ea239382/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/ea239382/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/ea239382/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/ea239382/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/ea239382/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/ea239382/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/ea239382/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/ea239382/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/ea239382/#考点11" class="header_1">考点11</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下()不是合法的标识符？</p><ul><li>A <code>STRING</code></li><li>B <code>x3x</code></li><li>C <code>void</code></li><li>D <code>deSf</code></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>void属于java中的关键字</p><ul><li><code>Java</code>标识符只能由数字、字母、下划线”_”或”$”符号以及<code>Unicode</code>字符集组成</li><li><code>Java</code>标识符必须以字母、下划线”_”或”$”符号以及<code>Unicode</code>字符集开头</li><li><code>Java</code>标识符不可以是<code>Java</code>关键字、保留字(<code>const</code>、<code>goto</code>)和字面量(<code>true</code>、<code>false</code>、<code>null</code>)</li><li><code>Java</code>标识符区分大小写,是大小写敏感的</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在<code>Java</code>中,关于<code>HashMap</code>类的描述,以下错误的是()？</p><ul><li>A <code>HashMap</code>能够保证其中元素的顺序</li><li>B <code>HashMap</code>允许将<code>null</code>用作值</li><li>C <code>HashMap</code>允许将<code>null</code>用作键</li><li>D <code>HashMap</code>使用键/值得形式保存数据</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p><code>HashMap</code>的底层是由数组加链表实现的，对于每一个<code>key</code>值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序。故A错。<br>最开始有<code>Hashtable</code>，<code>Hashtable</code>是不允许<code>key</code>和<code>value</code>的值为空的</p><p>A.HashMap不能保证元素的顺序，而LinkedHashMap可以保持数据的插入顺序，TreeMap可以按照键值进行排序（可自定比较器）<br>B.HashMap允许存在多条null值<br>C.HashMap允许且仅允许一条null键<br>D.Map就是通过键/值形式保存数据的<br>可能有误，仅供参考，欢迎大佬批评指正。<br>HashMap</p><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。<br>HashTable是Java中的遗留类，现在不怎么用了，也许HashTable类的设计者当时认为null作为key 和value 是没有什么用的。</p><p>HashMap是之后的版本引进的类，它的接口Map表达的意义更为广泛，也许HashMap的设计者认为null作为key和value是有实际意义的，所以才允许为null.</p><p>当然实际项目中，真的是有value为null的情况的。key为null的情况比较少见，但不代表没有。HashMap允许null为key和value应当是类的设计者思考让这个类更有用的设计吧。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下代码结果是什么？<br><code>public class foo</code> {<br><code>public static void main(String sgf[])</code> {<br><code>StringBuffer a=new StringBuffer(&quot;A&quot;)</code>;<br><code>StringBuffer b=new StringBuffer(&quot;B&quot;)</code>;<br><code>operate(a,b)</code>;<br><code>System.out.println(a+&quot;.&quot;+b)</code>;<br>}<br><code>static void operate(StringBuffer x,StringBuffer y)</code> {<br><code>x.append(y)</code>;<br><code>y=x</code>;<br>}<br>}</p><ul><li>A 代码可以编译运行,输出”<code>AB.AB</code>“。</li><li>B 代码可以编译运行,输出”<code>A.A</code>“。</li><li>C 代码可以编译运行,输出”<code>AB.B</code>“。</li><li>D 代码可以编译运行,输出”<code>A.B</code>“。</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>构造方法用于创建类的实例对象,构造方法名应与类名相同,返回类型为void。</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>构造函数，名称与类相同，没有返回类型的<br>如果”构造器”有返回值，那就说普通方法，而不是构造器</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下程序的执行结果是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    System.out.print(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(foo(<span class="string">'A'</span>);foo(<span class="string">'B'</span>)&amp;&amp;(i&lt;<span class="number">2</span>);foo(<span class="string">'C'</span>))&#123;</span><br><span class="line">        i++;</span><br><span class="line">        foo(<span class="string">'D'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>ABDCBDCB</code></li><li>B <code>ABCDABCD</code></li><li>C 编译时出错</li><li>D 运行时抛出异常</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h3><ul><li>for循环的执行顺序</li><li>短路与运算符</li></ul><h4 id="for循环格式"><a href="#for循环格式" class="headerlink" title="for循环格式"></a>for循环格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句; 布尔表达式; 更新语句) &#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环执行顺序"><a href="#for循环执行顺序" class="headerlink" title="for循环执行顺序"></a>for循环执行顺序</h4><ol><li><strong>初始化语句</strong>, 仅在循环开始前执行一次;</li><li><strong>布尔表达式</strong>, 用于决定是否继续执行正文过程, 表达式中异常则结束循环;</li><li><strong>循环体</strong>, 如果过程中存在break, return或者异常, 循环结束(不会执行更新语句), 如果遇到continue, 则会执行更新语句后进入下一轮循环;</li><li><strong>更新语句</strong>, 注意更新语句不做逻辑真假判断, 到这里一轮循环结束;</li></ol><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列说法正确的是( )</p><ul><li>A <code>volatile</code>,<code>synchronized</code> 都可以修改变量,方法以及代码块</li><li>B <code>volatile</code>,<code>synchronized</code> 在多线程中都会存在阻塞问题</li><li>C <code>volatile</code>能保证数据的可见性,但不能完全保证数据的原子性,<code>synchronized</code>即保证了数据的可见性也保证了原子性</li><li>D <code>volatile</code>解决的是变量在多个线程之间的可见性、原子性,而<code>sychroized</code>解决的是多个线程之间访问资源的同步性</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="synchronized关键字和volatile关键字比较"><a href="#synchronized关键字和volatile关键字比较" class="headerlink" title="synchronized关键字和volatile关键字比较"></a>synchronized关键字和volatile关键字比较</h3><ul><li>volatile关键字是线程同步的<strong>轻量级</strong>实现，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。</li><li>但是<strong>volatile关键字只能用于变量</strong>而<strong>synchronized关键字可以修饰方法以及代码块</strong>。</li><li>synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li><li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li><li>volatile关键字主要用于解决<code>变量</code>在多个线程之间的<code>可见性</code>，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ul><p>synchronized: 具有原子性，有序性和可见性；（三个都有）<br>volatile：具有有序性和可见性（缺一个原子性）</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>经过强制类型转换以后,变量a, b的值分别为( )short a = 128; byte b = (byte) a;</p><ul><li>A 128 127</li><li>B 128 -128</li><li>C 128 128</li><li>D 编译错误</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>byte在内存中占一个字节，范围是 -128到127之间。<br>java中short占用2bytes，强转short类型为byte，会将多出的高8位进行截断，short类型的 128的补码：0000 0000 1000 0000，强转为byte后的补码：1000 0000,最高位是符号位，</p><p>这样就表示-0，但是注意，没有-0，只有0，为了充分利用资源，java就将原来本应该表示“-0”的原码<strong>规定</strong>为-128，故结果为-128，类型也就能够表示的范围是-128。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下JAVA程序代码的输出是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="number">14</span>^<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 2744</li><li>B 13</li><li>C 17</li><li>D 11</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>^表示异或 就是相同是0 不同是1<br>14是1110<br>3是0011<br>所以14^3=1101，即13</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面这条语句一共创建了多少个对象:String s=”welcome”+”to”+360;</p><ul><li>A 1</li><li>B 2</li><li>C 3</li><li>D 4</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="编译器对直接量的优化"><a href="#编译器对直接量的优化" class="headerlink" title="编译器对直接量的优化"></a>编译器对直接量的优化</h3><p>“welcome”，”to”，360这三个都是<strong>直接量</strong>,直接量的连接在编译阶段就可以确定下来。编译器会将其优化成”welcometo360”，也就是只有一个对象。<br>字符串直接量的连接只生成一个对象</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素</p><ul><li>A 事件源</li><li>B 事件对象</li><li>C 事件过程</li><li>D 事件监听器</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>Java提供的事件处理模型是一种人机交互模型。它有三个基本要素：<br>1) 事件源(Event Source):即事件发生的场所,就是指各个组件,如按钮等,点击按钮其实就是组件上发生的一个事件;<br>2)事件(Event):事件封装了组件上发生的事情,比如按钮单击、按钮松开等等;<br>3) 事件监听器(Event Listener):负责监听事件源上发生的特定类型的事件,当事件到来时还必须负责处理相应的事件;</p><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>常用的servlet包的名称是？</p><ul><li>A <code>java.servlet</code></li><li>B <code>javax.servlet</code></li><li>C <code>servlet.http</code></li><li>D <code>javax.servlet.http</code></li></ul><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BD</details><p><code>JEE5.0</code>中的<code>Servlet</code>相关的就下面这几个包:</p><ul><li><code>javax.servlet</code></li><li><code>javax.servlet.jsp</code></li><li><code>java.servlet.jsp.el</code></li><li><code>java.servlet.jsp.tagext</code></li></ul><p>而最用得多的就是<br><code>javax.servlet</code><br><code>javax.servlet.http</code><br>这两个包了.</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月12日 HTML CSS1</title>
      <link href="/exam//f0d7fdad/"/>
      <url>/exam//f0d7fdad/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f0d7fdad/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/f0d7fdad/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列哪个样式定义后,内联(非块状)元素可以定义宽度和高度</p><ul><li>A display:inline</li><li>B display:block</li><li>C display:none</li><li>D display:inherit</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><ul><li>block:将行级别元素转为块级别元素</li><li>inline:将块级别元素转为行级别元素</li><li>inline-block:不能自动换行,但是可以设置宽高</li></ul><p>内联元素加上display：block后被块级化，块级元素一般是其他元素的容器，可容纳其他内联元素和其他块状元素。块状元素排斥和其他元素一行，高度和宽度起作用，因此可以定义宽高。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>css属性font-style用于设置字体的粗细。请判断这句话的正确与否。</p><ul><li>A T</li><li>B F</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="font-style属性定义字体的风格"><a href="#font-style属性定义字体的风格" class="headerlink" title="font-style属性定义字体的风格"></a>font-style属性定义字体的风格</h3><p>注意：该属性设置使用斜体、倾斜或正常字体。<br>语法: font-style: normal | italic | oblique | inherit;</p><ul><li>normal:默认正常情况;</li><li>italic:显示文字为斜体(该字体有斜体样式时使用)</li><li>oblique:显示文字为斜体(该字体没有斜体样式时使用,文字斜体显示)</li><li>inherit:从父亲那继承一个样式字体;</li></ul><h3 id="font-weight属性设置文本的粗细"><a href="#font-weight属性设置文本的粗细" class="headerlink" title="font-weight属性设置文本的粗细"></a>font-weight属性设置文本的粗细</h3><p>注意：该属性用于设置显示元素的文本中所用的字体加粗。</p><p>语法: font-weight: normal | bold | bolder | lighter | 100-900 | inherit;</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>表示有序列表的是</p><ul><li>A ul</li><li>B dl</li><li>C li</li><li>D ol</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><ul><li>ul 无序列表</li><li>ol 有序列表</li><li>li 定义列表项目</li><li>dl 定义列表</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>请选出结构正确的选项</p><ul><li>A <code>&lt;a href=www.nowcoder.com&gt;牛客网&lt;/a&gt;</code></li><li>B <code>&lt;a href=&quot;www.nowcoder.com&quot;&gt;牛客网&lt;/a&gt;</code></li><li>C <code>&lt;a href=&quot;http://www.nowcoder.com/&quot;&gt;牛客网&lt;/a&gt;</code></li><li>D <code>&lt;a href=&quot;http://www.nowcoder.com/&quot;&gt;牛客网</code></li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>href属性值是URL，而URL里包含协议，但不一定是http协议。如果没协议就会解析为相对路径。在浏览器地址栏中不输入协议名也行是因为浏览器发现这个相对路径没东西之后自动帮你加的协议。</p><ul><li>属性值要写在引号里面，A错误</li><li>URL中要有协议,B错误</li><li>a标签为双标签故应为<code>&lt;a&gt;&lt;/a&gt;</code>，所以D错误</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>从四个选项选出不同的一个。</p><ul><li>A <code>&lt;nav&gt;</code></li><li>B <code>&lt;footer&gt;</code></li><li>C <code>&lt;meta&gt;</code></li><li>D <code>&lt;canvas&gt;</code></li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>A选项<code>&lt;nav&gt;&lt;/nav&gt;</code>，位于<code>&lt;body&gt;&lt;/body&gt;</code>中。标签定义导航链接；</li><li>B选项<code>&lt;footer&gt;&lt;/footer&gt;</code>,位于<code>&lt;body&gt;&lt;/body&gt;</code>中。标签定义文档或节的页脚；</li><li>C选项<code>&lt;meta&gt;</code>,<code>&lt;meta&gt;</code> 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。</li><li><code>&lt;meta&gt;</code>标签位于文档的头部（<code>&lt;head&gt;&lt;/head&gt;</code>），不包含任何内容。<code>&lt;meta&gt;</code> 标签的属性定义了与文档相关联的名称/值对。</li><li>D选项<code>&lt;canvas&gt;</code>。<code>&lt;canvas&gt;</code>位于<code>&lt;body&gt;&lt;/body&gt;</code>中， 标签定义图形，比如图表和其他图像。</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p><code>HTML</code> 语言中,设置表格中文字与边框距离的标签是(      )</p><ul><li>A <code>&lt;table boder=&quot;&quot;&gt;</code></li><li>B <code>&lt;table cellspacing=&quot;&quot;&gt;</code></li><li>C <code>&lt;table cellpadding=&quot;&quot;&gt;</code></li><li>D <code>&lt;table width=&quot;&quot;&gt;</code></li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cellpadding</code></td><td style="text-align:left">单元格<strong>边距</strong>，就是文字与边框之间的距离</td></tr><tr><td style="text-align:left"><code>cellspacing</code></td><td style="text-align:left">单元格之间的间距</td></tr></tbody></table></div><h3 id="表格标记的常用属性有9个"><a href="#表格标记的常用属性有9个" class="headerlink" title="表格标记的常用属性有9个"></a>表格标记的常用属性有9个</h3><ul><li><code>cellpadding</code>:单元格边沿与其内容之间的空白 <code>cellspacing</code>:单元格之间的空白</li><li><code>border</code>:表格边框的宽度(也可以理解我边框的粗细程度) </li><li><code>height</code>:表格高度</li><li><code>width</code>:表格的宽度</li><li><code>bgcolor</code>:表格背景颜色 </li><li><code>align</code>:表格相对周围元素的对齐方式(也可以理解为表格中的文字内容的对齐方式) </li><li><code>frame</code>:规定外侧边框哪些部分是可见的</li><li><code>rules</code>:规定内侧边框哪些部分是可见的</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>以下说法,错误的是</p><ul><li>A <code>mark</code>用于显示变粗的文字</li><li>B <code>&lt;del&gt;</code>用于显示删除的文本</li><li>C <code>&lt;ins&gt;</code>的文字会带下划线</li><li>D <code>&lt;strong&gt;</code>用于强调文本</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><ul><li><code>&lt;mark&gt;</code> 标签定义带有记号的文本。请在需要突出显示文本时使用 <code>&lt;m&gt;</code> 标签。</li><li><code>&lt;del&gt;</code>定义文档中已被删除的文本。 </li><li><code>&lt;ins&gt;</code> 标签定义已经被插入文档中的文本。 </li><li><code>&lt;strong&gt;</code> 标签和<code>&lt;em&gt;</code> 标签一样，用于强调文本，但<code>&lt;strong&gt;</code> 强调的程度更强一些。</li></ul><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下哪个<code>CSS</code>属性是继承属性(<code>inherited)</code>？</p><ul><li>A <code>vertical-align</code></li><li>B <code>background-color</code></li><li>C <code>text-indent</code></li><li>D <code>justify-content</code></li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h3 id="什么是CSS中的继承"><a href="#什么是CSS中的继承" class="headerlink" title="什么是CSS中的继承"></a>什么是CSS中的继承</h3><p><strong>继承就是指<code>子节点</code>默认使用<code>父节点</code>的样式属性</strong>。 </p><h3 id="那些属性可以继承"><a href="#那些属性可以继承" class="headerlink" title="那些属性可以继承"></a>那些属性可以继承</h3><p>不可继承的属性太多了不要背，记住可以继承的属性有哪些就行了。<br>可以继承的属性很少，只有<code>颜色</code>，<code>文字</code>，<code>字体间距</code>，<code>行高</code>，<code>对齐方式</code>，和<code>列表的样式</code>可以继承。 </p><ul><li>所有元素可继承：<code>visibility</code>和<code>cursor</code>。</li><li>内联元素可继承：<code>letter-spacing</code>、<code>word-spacing</code>、<code>white-space</code>、<code>line-height</code>、<code>color</code>、<code>font</code>、<code>font-family</code>、<code>font-size</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-weight</code>、<code>text-decoration</code>、<code>text-transform</code>、<code>direction</code>。 </li><li>终端块状元素可继承：<code>text-indent</code>和<code>text-align</code>。 </li><li>列表元素可继承：<code>list-style</code>、<code>list-style-type</code>、<code>list-style-position</code>、<code>list-style-image</code>。</li></ul><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于<code>web</code>表单登录中用到的图形验证码的实现,以下做法不正确的有</p><ul><li>A 返回给浏览器的<code>html</code>代码中包含图形验证码和文本字符串,登录前客户端判断输入内容和页面中保存的内容是否一致</li><li>B 服务器端在返回的图片和<code>cookie</code>中同时包含图形验证码,登录前客户端判断输入内容和<code>cookie</code>保存的内容是否一致</li><li>C 服务器端生成验证码后一方面通过图片将验证码返回给客户端,同时在服务器端保存文本的验证码,由服务器端验证输入内容是否正确</li><li>D 浏览器通过识别图形验证码中的内容和用户输入的内容判断是否一致</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: `ABD`</details><p>放浏览器判断太不安全啦，当然要给服务器来判断啦</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> HTML CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月11日 java1</title>
      <link href="/exam//eed643bf/"/>
      <url>/exam//eed643bf/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/eed643bf/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/eed643bf/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/eed643bf/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/eed643bf/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/eed643bf/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/eed643bf/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/eed643bf/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/eed643bf/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/eed643bf/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/eed643bf/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>What will be printed when you execute the following code?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    C() &#123;</span><br><span class="line">        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    C c = <span class="keyword">new</span> C();</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"A"</span>);</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    A(String s) &#123;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    Test() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"B"</span>);</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A BB</li><li>B CBB</li><li>C BAB</li><li>D None of the above</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><h3 id="父类和子类的初始化顺序"><a href="#父类和子类的初始化顺序" class="headerlink" title="父类和子类的初始化顺序"></a>父类和子类的初始化顺序</h3><ol><li>父类静态初始化代码，包括静态初始化块，或者静态变量声明。</li><li>子类静态初始化代码，包括静态初始化块，或者静态变量声明。</li><li>父类实例初始化块</li><li>父类构造器</li><li>子类实例初始化块</li><li>子类构造器</li></ol><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>说明输出结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getClass().getName());</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SuperTest().test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A SuperTest</li><li>B SuperTest.class</li><li>C test.SuperTest</li><li>D test.SuperTest.class</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>Object的getClass方法是final的,所以TestSuper和Date都不能重写getClass方法。</li><li>调用的都是Object的getClass方法，而Object的getClass作用是返回的是<strong>运行时</strong>的类的名字。这个运行时的类就是当前类SuperTest</li><li>class对象.getName()的返回返回值为:<code>包名+类名</code></li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下说法中正确的有？</p><ul><li>A StringBuilder是 线程不安全的</li><li>B Java类可以同时用 abstract和final声明</li><li>C HashMap中,使用 get(key)==null可以 判断这个Hasmap是否包含这个key</li><li>D volatile关键字不保证对变量操作的原子性</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: AD</details><ul><li>abstract修饰的类是抽象类，是可以继承的，而final修饰的类表示不能再被继承，故肯定不能共同使用。故B错。</li><li>HashMap中提供的get(key)获取的是变量，无法判断是否存在key。所以C是错的</li><li>volatile关键字是一种轻量级的同步机制，只保证数据的可见性，而不保证数据的原子性。故D对</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持,下面关于Java反射的描述，哪些是错误的:(          )</p><ul><li>A Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下</li><li>B 通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法</li><li>C 通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员</li><li>D Java反射机制提供了字节码修改的技术，可以动态的修剪一个类</li><li>E Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多</li><li>F Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ADF</details><p>反射指的是在运行时能够分析类的能力的程序。<br>反射机制可以用来：<br>1.Field、Method、Constructor位于java.lang.reflect包中。<strong>Class类在<code>java.lang</code>中</strong>。<br>2.在运行时查看对象。<br>3.实现通用的数组操作代码。</p><p>反射机制的功能：<br>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。<br>反射机制常见作用：<br>动态加载类、动态获取类的信息（属性、方法、构造器）；动态构造对象；动态调用类和对象的任意方法、构造器；动态调用和处理属性；获取泛型信息（新增类型：ParameterizedType,GenericArrayType等）；处理注解（反射API:getAnnotationsdeng等）。<br>反射机制性能问题：<br><strong>反射会降低效率</strong>。<br>void setAccessible(boolean flag):是否启用访问安全检查的开关，true屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。<strong>禁止安全检查，可以提高反射的运行速度</strong>。<br>可以考虑使用：cglib/javaassist操作。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在异常处理中,若try中的代码可能产生多种异常则可以对应多个catch语句，若catch中的参数类型有父类子类关系，此时应该将父类放在后面，子类放在前面。</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>如果将父类放在前面的话，异常将被父类完全捕获，子类永远不能捕获异常</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>如何跳出Array的forEach循环？( )</p><ul><li>A break</li><li>B return true</li><li>C return false</li><li>D 以上都不是</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>foreach循环是for循环的增强版,for循环怎么跳,foreach就怎么跳。<br>这里让人迷惑分点就是这个Array，不要理解成ArrayList的forEach方法。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列哪个选项是Java调试器？如果编译器返回程序代码的错误,可以用它对程序进行调试。</p><ul><li>A java.exe</li><li>B javadoc.exe</li><li>C jdb.exe</li><li>D javaprof.exe</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><ul><li>javac.exe是编译.java文件</li><li>java.exe是执行编译好的.class文件</li><li>javadoc.exe是生成Java说明文档</li><li>jdb.exe是Java调试器</li><li>javaprof.exe是剖析工具</li></ul><p>jdb是”java debuger”的简写</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ResultSet中记录行的第一列索引为？</p><ul><li>A -1</li><li>B 0</li><li>C 1</li><li>D 以上都不是</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>ResultSet跟普通的数组不同，索引从1开始而不是从0开始</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下列关于final、finally、finalize说法正确的是( )</p><ul><li>A final可以用来修饰类、方法、变量</li><li>B finally是java保证重点代码一定要被执行的一种机制</li><li>C 变量被final修饰后不能再指向其他对象,但可以重写</li><li>D finalize设计的目的是保证对象在被垃圾收集前完成特定资源的回收</li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>finalize()是Object的方法，子类可以覆盖该方法以实现资源清理工作的目的，GC会在回收对象之前调用该方法<br>final修饰的变量也不能重写(重新赋值)</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List names = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        names.add(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; names.size();i++)&#123;</span><br><span class="line">            System.out.print(names.get(i) + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NameList sl = <span class="keyword">new</span> NameList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    sl.add(<span class="string">"A"</span>);</span><br><span class="line">                    sl.add(<span class="string">"B"</span>);</span><br><span class="line">                    sl.add(<span class="string">"C"</span>);</span><br><span class="line">                    sl.printAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             .start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Which two statements are true if this class is compiled and run?</p><ul><li>A An exception may be thrown at runtime.</li><li>B The code may run with no output, without exiting.</li><li>C The code may run with no output, exiting normally(正常地).</li><li>D The code may rum with output “A B A B C C “, then exit.</li><li>E The code may rum with output “A B C A B C A B C “, then exit.</li><li>F The code may ruin with output “A A A B C A B C C “, then exit.</li><li>G The code may ruin with output “A B C A A B C A B C “, then exit.</li></ul><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: EG</details><p>首先最主要的是，有两条线程在同时进行。</p><ul><li><strong>线程内的是顺序进行</strong>，</li><li><strong>线程之间的顺序不定，可能是交叉执行，也有可能是先执行了一个线程后执行了另一个线程。</strong></li></ul><p>但是无论怎样，两个线程不可能同时执行一个操作，这就说明<br>执行慢的那个线程s1.println();这行代码将会打印出完整的6个字符的字串（但是两个进程添加顺序不确定，有可能是ABCABC，也有可能最后字串是AABBCC或ABABCC等），这就意味着最后6个字符就是真正的添加顺序。<br>根据逻辑判断，第一次s1.println()结束时，可能两个线程添加都已经添加完，此时第一次s1.println()输出字符最多6个，第二次s1.println()输出字符个数是6个，也就是最多输出12个。<br>最少的情况，也就是s1.println()结束时，只有第一个线程进行了add()操作，此时字符输出最少3个，第二次是6个，也就是9个。<br>也就是输出的字符串个数一定在9~12个之间。所以A、B、C、D排除。<br>所以看选项E的话，最后字串是ABCABC，那第一次s1.println()操作可能在第一个s1.add(“c”)操作结束到第二个s1.add(“c”)操作之间。比如：(ABC)ABCABC、(ABCA)ABCABC、(ABCAB)ABCABC、(ABCABC)ABCABC。这些都是可能的输出，所以G也正确。所以E、G正确<br>而选项F。最后6个字符是BCABCC。首先这不可能，因为虽然添加字符顺序是不确定的，但是确定的是第一个添加的字符肯定是A，并且字符串必须由2个A、2个B、2个C组成。</p><p>这题烧脑</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月11日 Java2</title>
      <link href="/exam//b61e3d01/"/>
      <url>/exam//b61e3d01/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/b61e3d01/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/b61e3d01/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/b61e3d01/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/b61e3d01/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/b61e3d01/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/b61e3d01/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/b61e3d01/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/b61e3d01/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>哪个关键字可以对对象加互斥锁？()</p><ul><li>A synchronized</li><li>B volatile</li><li>C serialize</li><li>D static</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><p>用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面代码的执行结果是 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chinese</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Chinese objref =<span class="keyword">new</span> Chinese();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Chinese <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> objref;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestChinese</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Chinese obj1 = Chinese.getInstance();</span><br><span class="line">        Chinese obj2 = Chinese.getInstance();</span><br><span class="line">        System.out.println(obj1 == obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A true</li><li>B false</li><li>C TRUE</li><li>D FALSE</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>这是<strong>饿汉式单例模式</strong>，在类创建时，就已经实例化完成</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>假定Base b = new Derived(); 调用执行b.methodOne（）后,输出结果是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.methodOne();</span><br><span class="line">        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.methodTwo();</span><br><span class="line">        System.out.print(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A ABDC</li><li>B AB</li><li>C ABCD</li><li>D ABC</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>这是一道类多态的向上转型题。<br>Base b = new Derived();<br>向上转型：父类只能调用父类方法或者子类覆写后的方法,而子类中的单独方法则是无法调用的。<br>因此：<br>调用的顺序是：(1)、(2)、(3)、(4)、(5)、(6)、(7) ; 得到的结果是：ABDC<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="comment">// (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">//执行到这里的时候调用子类的覆盖方法 (4)</span></span><br><span class="line">        methodTwo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (7)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// (2)</span></span><br><span class="line">        <span class="keyword">super</span>.methodOne();</span><br><span class="line">        System.out.print(<span class="string">"C"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法为重写了父类的方法 (5)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//(6)</span></span><br><span class="line">        <span class="keyword">super</span>.methodTwo();</span><br><span class="line">        System.out.print(<span class="string">"D"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java程序内存泄露的最直接表现是( )</p><ul><li>A 频繁FullGc</li><li>B jvm崩溃</li><li>C 程序抛内存控制的Exception</li><li>D java进程异常消失</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><p>java是自动管理内存的，通常情况下程序运行到稳定状态，内存大小也达到一个 基本稳定的值<br>但是内存泄露导致Gc不能回收泄露的垃圾，内存不断变大.<br>最终超出内存界限，抛出<strong>OutOfMemoryExpection</strong></p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在Java中,对于不再使用的内存资源，如调用完成的方法，”垃圾回收器”会自动将其释放。(  )</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>调用方法是在<strong>栈内存</strong>中完成的,调用完成会自动释放,<br>而gc释放的是<strong>堆区</strong>的内容</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪些情况下需要使用抽象类？</p><ul><li>A 当一个类的一个或多个方法是抽象方法时</li><li>B 当类是一个抽象类的子类,并且不能为任何抽象方法提供任何实现细节或方法体时</li><li>C 当一个类实现多个接口时</li><li>D 当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: ABD</details><p>D:当你不想实现接口中的所有方法，只想实现接口中的个别方法时，你可以先写一个抽象类来实现该接口，并实现除了你想要的方法之外的所有方法(可以简单的将方法体设为空)<br>接着再用你的类继承这个抽象类，这个类中就只用实现你需要的方法了，这样就可以达到你的需要了。<br>如果你直接实现接口的话，你就需要实现接口的所有方法。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列容器中,哪些容器按 key 查找的复杂度为 O(log(n)) ()</p><ul><li>A std::unordered_set</li><li>B std::multimap</li><li>C std::map</li><li>D std::deque</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BC</details><p>STL库中，map和multimap底层都是红黑树实现的，两者的不同在于multimap允许重复，而map中不行。<br><strong>红黑树的查找复杂度为O(log(n))</strong><br>unodered_map/_set底层是哈希表实现的，<strong>哈希表查找复杂度为O(1)</strong></p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>Java.Thread的方法resume()负责重新开始被以下哪个方法中断的线程的执行()。</p><ul><li>A stop</li><li>B sleep</li><li>C wait</li><li>D suspend</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态</p><p><img src="https://uploadfiles.nowcoder.com/files/20171113/7172803_1510563467506_20140828202610671" alt="线程状态"></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月11日 HTML CSS</title>
      <link href="/exam//6acef549/"/>
      <url>/exam//6acef549/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/6acef549/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/6acef549/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/6acef549/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/6acef549/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/6acef549/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/6acef549/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/6acef549/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/6acef549/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/6acef549/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列定义的 css 中,哪个权重是最低的？</p><ul><li>A #game .name</li><li>B #game .name span</li><li>C #game div</li><li>D #game div.name</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><div class="table-container"><table><thead><tr><th style="text-align:left">style</th><th style="text-align:left">权重</th></tr></thead><tbody><tr><td style="text-align:left">行内样式</td><td style="text-align:left">1000</td></tr><tr><td style="text-align:left">id</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">element</td><td style="text-align:left">1</td></tr></tbody></table></div><p>权重越大，优先级越高<br>CSS选择器优先级是指“基础选择器”的优先级：<br>ID &gt; CLASS &gt; ELEMENT &gt; *</p><p>a：100 + 10 = 110<br>b：100 + 10 + 1 = 111<br>c：100 + 1 = 101<br>d：100 + 1 + 10 = 111</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于li这个节点,下列哪个CSS选择器的优先级最高？</p><ul><li>A li#app</li><li>B li.cnt</li><li>C li.cnt:hover</li><li>D #app.cnt</li></ul><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><div class="table-container"><table><thead><tr><th style="text-align:left">style</th><th style="text-align:left">权重</th></tr></thead><tbody><tr><td style="text-align:left">行内样式</td><td style="text-align:left">1000</td></tr><tr><td style="text-align:left">id</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left">class</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">element</td><td style="text-align:left">1</td></tr></tbody></table></div><p>第一等:代表内联样式,如: style=””，权值为1000。<br>第二等：代表ID选择器，如：#content，权值为0100。<br>第三等：代表类，伪类和属性选择器，如.content，权值为0010。<br>第四等：代表类型选择器和伪元素选择器，如div<br>p，权值为0001。<br>通配符、子选择器、相邻选择器等的。如<br>、&gt;、+,权值为0000。</p><p>权重:<br>①内联样式1000,如style=””;<br>②ID100，如#content；<br>③类、属性10，如.content；<br>④标签1，如div。<br>A.li#app:标签+ID=1+100=101；<br>B.li.cnt：标签+类=1+10=11；<br>C.li.cnt:hover：标签+类=11；<br>D.#app.cnt：ID+类=100+10=110。<br>(D)权重最大，优先级最高。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列哪个不属于id与class之间的区别</p><ul><li>A id在文档中只能使用一次,而class可以多次使用</li><li>B id比class具有更高的样式优先级</li><li>C 一个元素只能有一个id属性值，却可以拥有多个class属性值</li><li>D 在class中可以定义:hover伪类，在id中不能定义</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: D</details><p>伪类选择符E:hover设置元素在其鼠标悬停时的样式。<br><code>E元素</code>可以通过其他选择器进行选择，比如使用<code>类选择符</code>、<code>id选择符</code>、<code>类型选择符</code>等等。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面关于表单的说法中,错误的是 (      )</p><ul><li>A 可以给 input 添加 multiple 属性使它可以输入多行文字</li><li>B placeholder 属性可以用来提示用户输入什么内容</li><li>C 用户无法直接修改包含 disabled 属性的文本框的内容</li><li>D maxlength 属性可以限制文本框内最多输入多少个字符</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><p>multiple 属性是一个布尔属性。<br>multiple 属性规定允许用户输入到 <code>&lt;input&gt;</code>元素的多个值。<br>注意：multiple 属性适用于以下 input 类型：email 和 file。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo-form.php"</span>&gt;</span></span><br><span class="line">  选择图片: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"img"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>有一个元素,需要在pc端显示而在手机端隐藏，需要使用的方法是？</p><ul><li>A visible-xs-8 hidden-md</li><li>B visible-md-8 hidden-xs</li><li>C visible-md-8 hidden-sm</li><li>D visible-sm-8 hidden-md</li></ul><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p>手机端屏幕是小于768px的，bootstrap col-xs代表屏幕小于768px，所以在手机端隐藏是hidden-xs。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p><code>&lt;i&gt;</code>，<code>&lt;em&gt;</code>标签语义分别表示斜体和加粗,是否正确？</p><ul><li>A 正确</li><li>B 错误</li></ul><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><ul><li><code>&lt;i&gt;</code>标签只是单纯的样式标签，表现斜体的样式，但是语义上与普通文本无异；</li><li><code>&lt;em&gt;</code>标签在样式上表示为斜体，同时在语义上也表示为强调</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>以下不属于把CSS样式表与HTML网页关联的方法的是()</p><ul><li>A 在HTML文档的<code>&lt;!--…--&gt;</code>标签内定义CSS样式</li><li>B 用<code>&lt;link&gt;</code>标签链接网上可访问的CSS样式表文件</li><li>C 在HTML文档的<head>标签内定义CSS样式</li><li>D 用<code>@import</code>引入样式表文件</li></ul><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于标签,下列说法错误的是</p><ul><li>A <code>&lt;video&gt;</code>标签中controls属性决定是否向用户显示控件</li><li>B <code>&lt;audio&gt;</code>与<code>&lt;/audio&gt;</code>之间插入的内容是用来解释控件的</li><li>C <code>&lt;datalist&gt;</code>标签可以和input标签配合进行使用，来显示列表</li><li>D <code>&lt;progress&gt;</code>标签不填写max和value会自动滑动</li></ul><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B</details><p><code>&lt;audio&gt;</code>与<code>&lt;/audio&gt;</code> 之间插入的内容是供不支持audio 元素的浏览器显示的</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>以下选项正确的是</p><ul><li>A <code>&lt;p /&gt;</code></li><li>B <code>&lt;br /&gt;</code></li><li>C <code>&lt;hr /&gt;</code></li><li>D <code>&lt;img /&gt;</code></li></ul><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BCD</details><p>HTML中的标签分为<code>闭合标签</code>和<code>自闭合标签</code>。 自闭合标签有</p><ul><li><code>&lt;input/&gt;</code></li><li><code>&lt;img/&gt;</code></li><li><code>&lt;br/&gt;</code></li><li><code>&lt;link/&gt;</code></li><li><code>&lt;hr/&gt;</code></li></ul><p>等</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> HTML CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月7日 java3</title>
      <link href="/exam//e786d9ee/"/>
      <url>/exam//e786d9ee/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/e786d9ee/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/e786d9ee/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/e786d9ee/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/e786d9ee/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/e786d9ee/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/e786d9ee/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/e786d9ee/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/e786d9ee/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列语句：<code>int *p, a = 10;  p = &amp;a</code>.<br>均表示地址的是（）</p><ul><li>A <code>a , p, &amp;a</code></li><li>B <code>&amp;*a,&amp;a,*p</code></li><li>C <code>*&amp;p, *p, &amp;a</code></li><li>D <code>&amp;a, p, &amp;*p</code></li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><code>*p</code>表示指针p</li><li><code>&amp;a</code>表示取a的内存地址</li><li><code>p = &amp;a</code> 表示p等于a的内存地址</li><li><code>&amp;*p</code>表示获取指针p的内存地址</li><li><code>*&amp;p</code>表示指向P内存地址的一个指针</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面代码的运行结果是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String s;</span><br><span class="line">    System.out.println(<span class="string">"s="</span>+s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 代码编程成功，并输出”s=”</li><li>B 代码编译成功，并输出”s=null”</li><li>C 由于String s没有初始化，代码不能编译通过。</li><li>D 代码编译成功，但捕获到NullPointException异常</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="局部变量没有默认值"><a href="#局部变量没有默认值" class="headerlink" title="局部变量没有默认值"></a>局部变量没有默认值</h3><p>成员变量有初始值，而局部变量没有初始值得。本体中的s定义在方法中所以为局部变量-没有初始值。变量没有初始值就使用了，编译通不过</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java运行时内存分为“线程共享”和“线程私有”两部分，以下哪些属于“线程共享”部分</p><ul><li>A 程序计算器</li><li>B 方法区</li><li>C java虚拟机栈</li><li>D java堆</li></ul><p>正确答案: BD</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li>私有:<ul><li>java虚拟机栈，</li><li>程序计数器，</li><li>本地方法栈</li></ul></li><li>共享:<ul><li>java堆，</li><li>方法区</li></ul></li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>)</span><br></pre></td></tr></table></figure><p><code>&quot;abc&quot;</code>在内存中是怎么分配的?</p><ul><li>A 堆</li><li>B 栈</li><li>C 字符串常量区</li><li>D 寄存器</li></ul><p>正确答案: AC</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>截止JDK1.8版本,java并发框架支持锁包括?</p><ul><li>A 读写锁</li><li>B 自旋锁</li><li>C X锁</li><li>D 乐观锁</li><li>E 排他锁</li></ul><p>正确答案: ABD</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>HashSet子类依靠()方法区分重复元素。</p><ul><li>A toString(),equals()</li><li>B clone(),equals()</li><li>C hashCode(),equals()</li><li>D getClass(),clone()</li></ul><p>正确答案: C</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>一个文件中的字符要写到另一个文件中，首先需要（ ）。</p><ul><li>A 使用标准输出流System.out.println()。</li><li>B 建立文件字符输出流。</li><li>C 建立文件字符输入流。</li><li>D 标准输入流System.in.read()。</li></ul><p>正确答案: C</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下描述错误的一项是（ ）？</p><ul><li>A 程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行 到了第几行，是线程隔离的</li><li>B 原则上讲，所有的对象都是在堆区上分配内存，是线程之间共享的</li><li>C 方法区用于存储JVM加载的类信息、常量、静态变量，即使编译器编译后的代码等数据，是线程隔离的</li><li>D Java方法执行内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</li></ul><p>正确答案: C</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>有空了解一下</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月7日 数据库1</title>
      <link href="/exam//f54bdba1/"/>
      <url>/exam//f54bdba1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f54bdba1/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/f54bdba1/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/f54bdba1/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/f54bdba1/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/f54bdba1/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/f54bdba1/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/f54bdba1/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/f54bdba1/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>实现数据库安全性控制的常用方法和技术有（）</p><ul><li>A 用户标识与鉴别、存取控制、视图机制、审计、数据加密</li><li>B 存取控制、视图机制、审计、数据加密、防火墙</li><li>C 用户标识与鉴别、存取控制、视图机制、审计、防火墙</li><li>D 存取控制、视图机制、审计、数据加密、数据转储</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="实现数据库安全性控制的常用方法和技术"><a href="#实现数据库安全性控制的常用方法和技术" class="headerlink" title="实现数据库安全性控制的常用方法和技术"></a>实现数据库安全性控制的常用方法和技术</h3><p><strong>用户标识和鉴别</strong>：该方法由系统提供一定的方式让用户标识自己的名字或身份。每次用户要求进入系统时，由系统进行核对，通过鉴定后才能提供系统的使用权<br><strong>存取控制</strong>：通过用户权限定义和合法权检查确保只有合法权限的用户访问数据库，所有未授权的人员无法存取数据<br><strong>视图机制</strong>：为不同的用户定义视图，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动地对数据提供一定程度的安全保护。<br><strong>审计</strong>：建立审计日志，把用户对数据库的所有操作自动记录下来放入审计日志中，DBA可以利用审计跟踪的信息，重现导致数据库现有状况的一系列事件，找出非法存取数据的人，时间和内容等。<br><strong>数据加密</strong>：对存储和传输的数据进行加密处理，从而使得不知道解密算法的人无法获知数据的内容。</p><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的界面上构造的保护屏障。和数据库安全性没关系</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>数据库 DB 、数据库系统 DBS 、数据库管理系统 DBMS 之间的关系是 ( ) 。</p><ul><li>A DB包括DBS和DBMS</li><li>B DBMS包括DB和DBS</li><li>C DBS包括DB和DBMS</li><li>D 没有任何关系</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>数据库系统DBS包括：数据库DB和数据库管理系统DBMS</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>在SQL语言中，属于DCL的操作命令是?</p><ul><li>A GRANT</li><li>B CREATE</li><li>C UPDATE</li><li>D DROP</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="DML（data-manipulation-language）："><a href="#DML（data-manipulation-language）：" class="headerlink" title="DML（data manipulation language）："></a>DML（data manipulation language）：</h3><p>它们是select、update、insert、delete，<br>就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言</p><h3 id="DDL（data-definition-language）："><a href="#DDL（data-definition-language）：" class="headerlink" title="DDL（data definition language）："></a>DDL（data definition language）：</h3><p>DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，<br>DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用</p><h3 id="DCL（Data-Control-Language）："><a href="#DCL（Data-Control-Language）：" class="headerlink" title="DCL（Data Control Language）："></a>DCL（Data Control Language）：</h3><p>是数据库控制功能。是用来设置或更改数据库<strong>用户</strong>或<strong>角色权限</strong>的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在E-R图中，属性用（ ）符号表示。</p><ul><li>A 椭圆</li><li>B 矩形</li><li>C 菱形</li><li>D 三角形</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>E-R图 用矩形表示实体型；</li><li>用椭圆表示实体的属性；</li><li>用菱形表示实体型之间的联系</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在数据库设计中， E-R 图产生于（ ）。</p><ul><li>A 需求分析阶段</li><li>B 物理设计阶段</li><li>C 逻辑设计阶段</li><li>D 概念设计阶段</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="数据库设计的六个阶段"><a href="#数据库设计的六个阶段" class="headerlink" title="数据库设计的六个阶段"></a>数据库设计的六个阶段</h3><p>规范的设计方法，一个完整的数据库设计一般分为六个阶段：<br>⑴<strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；<br>⑵<strong>概念结构设计</strong>：主要采用E-R模型进行设计，包括<strong>画E-R图</strong>；<br>⑶<strong>逻辑结构设计</strong>：通过将E-R图转换成表，<strong>实现从E-R模型到关系模型的转换</strong>；<br>⑷<strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸<strong>数据库的实施</strong>：包括编程、测试和试运行；<br>⑹<strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对数据库第二范式的理解正确的是()</p><ul><li>A 数据库表的每一列都是不可分割的原子数据项</li><li>B 在1NF基础上,任何非主属性不依赖于其它非主属性</li><li>C 在1NF基础上,非码属性必须完全依赖与码</li><li>D 以上说法都不正确</li></ul><p>正确答案: C</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h3 id="范式说明"><a href="#范式说明" class="headerlink" title="范式说明"></a>范式说明</h3><p>第一范式，原子性<br>第二范式，没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br>第三范式，不能存在传递依赖</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>使用MYSQL进行模糊查询 LIKE ‘_YOU%’,下面哪个是正确结果？</p><ul><li>A YONYOU</li><li>B YYOUYO</li><li>C YOUYON</li><li>D YYYOUN</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">通配符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">_</td><td style="text-align:left">表示任意单个字符</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">表示任意个或多个字符</td></tr></tbody></table></div><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面那些是非关系型数据库()</p><ul><li>A Redis</li><li>B Mysql</li><li>C MongoDb</li><li>D SqlServer</li></ul><p>正确答案: AC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="一、关系型数据库"><a href="#一、关系型数据库" class="headerlink" title="一、关系型数据库"></a>一、关系型数据库</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190815/345829746_1565884415495_1013528-20170926113945323-238845177.png" alt="图片"><br>关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织<br>优点：<br>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：SQL语言通用，可用于复杂查询；<br>3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。<br>缺点：<br>1、读写性能比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，灵活度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。</p><h3 id="二、非关系型数据库"><a href="#二、非关系型数据库" class="headerlink" title="二、非关系型数据库"></a>二、非关系型数据库</h3><p><img src="https://uploadfiles.nowcoder.com/files/20190815/345829746_1565884442185_1013528-20170926114007198-781865994.png" alt="图片"><br>非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。<br>优点：<br>1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：nosql数据库部署简单，基本都是开源软件。</p><p>缺点：<br>1、不提供sql支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p><p>非关系型数据库的分类和比较：<br>1、文档型<br>2、key-value型<br>3、列式数据库<br>4、图形数据库</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月8日 java2</title>
      <link href="/exam//618ab2f5/"/>
      <url>/exam//618ab2f5/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/618ab2f5/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/618ab2f5/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/618ab2f5/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/618ab2f5/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/618ab2f5/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/618ab2f5/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/618ab2f5/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/618ab2f5/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/618ab2f5/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/618ab2f5/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/618ab2f5/#考点11" class="header_1">考点11</a>&nbsp;<br><a href="/exam/618ab2f5/#考点12" class="header_1">考点12</a>&nbsp;<br><a href="/exam/618ab2f5/#考点13" class="header_1">考点13</a>&nbsp;<br><a href="/exam/618ab2f5/#考点14" class="header_1">考点14</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Which is the return type of the method main()?</p><ul><li>A int</li><li>B void</li><li>C Boolean</li><li>D static</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>子类A继承父类B, A a = new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？</p><ul><li>A 父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li><li>B 父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li><li>C 父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数</li><li>D 父类Ｂ构造函数-&gt;父类Ｂ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>当实例化子类对象时，</p><ul><li>首先要加载父类的class文件进内存，静态代码块是随着类的创建而执行，所以父类静态代码块最先被执行，</li><li>子类class文件再被加载，同理静态代码块被先执行；</li><li>实例化子类对象要先调用父类的构造方法，而调用父类构造方法前会先执行父类的非静态代码块</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>有如下代码：请写出程序的输出结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; <span class="number">5</span>; z++) &#123; </span><br><span class="line">            <span class="keyword">if</span> ((++x &gt; <span class="number">2</span>) &amp;&amp; (++y &gt; <span class="number">2</span>) &amp;&amp; (k++ &gt; <span class="number">2</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                x++;</span><br><span class="line">                ++y;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(x + ”” +y + ”” +k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 432</li><li>B 531</li><li>C 421</li><li>D 523</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>每次循环z,x,y,k对应数值为：<br>0,1,0,0<br>1,2,0,0<br>2,3,1,0<br>3,4,2,0<br>4,5,3,1<br>执行完这次以后，z++为5，不再进入for循环。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>现有如下代码段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n/<span class="number">2</span>) </span><br><span class="line">       x = <span class="number">2</span>*x;</span><br></pre></td></tr></table></figure><br>假设n&gt;=0，则其时间复杂度应为（   ）</p><ul><li>A O(log2(n))</li><li>B O(nlog2(n))</li><li>C O(n)</li><li>D O(n^2)</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">2</span>;       <span class="comment">//①</span></span><br><span class="line">       <span class="keyword">while</span>(x&lt;n/<span class="number">2</span>)</span><br><span class="line">x = <span class="number">2</span>*x;   <span class="comment">// ②</span></span><br></pre></td></tr></table></figure><p>语句①的频度是1，设语句2的频度是f(n)，则2^f(n)&lt;=n/2;f(n)&lt;=log2(n/2)近似等于f(n)&lt;=log2(n)，取最大值f(n)=log2(n),T(n)=O(log2(n))</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面关于垃圾收集的说法正确的是</p><ul><li>A 一旦一个对象成为垃圾，就立刻被收集掉。</li><li>B 对象空间被收集掉之后，会执行该对象的finalize方法</li><li>C finalize方法和C++的析构函数是完全一回事情</li><li>D 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>对象空间被收集<strong>之前</strong>执行finalize（）方法，而不是对象空间被收集之后再执行</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a++ + a--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出什么？</p><ul><li>A 19</li><li>B 20</li><li>C 21</li><li>D 22</li></ul><p>正确答案: C</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ul><li>先取值，后加一</li><li>先取值，后减一</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>哪个正确</p><ul><li>A abstract类只能用来派生子类，不能用来创建abstract类的对象。</li><li>B final类不但可以用来派生子类，也可以用来创建final类的对象。</li><li>C abstract不能与final同时修饰一个类。</li><li>D abstract类定义中可以没有abstract方法。</li></ul><p>正确答案: ACD</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>1、abstract类不能用来创建abstract类的对象；<br>2、final类不能用来派生子类，因为用final修饰的类不能被继承；<br>3、如2所述，final不能与abstract同时修饰一个类，abstract类就是被用来继承的；<br>4、类中有abstract方法必须用abstract修饰，但abstract类中可以没有抽象方法，接口中也可以有abstract方法。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>关于equals和hashCode描述正确的是    ()</p><ul><li>A 两个obj，如果equals()相等，hashCode()一定相等（符合代码规范的情况下）</li><li>B 两个obj，如果hashCode()相等，equals()不一定相等</li><li>C 两个不同的obj， hashCode()可能相等</li><li>D 其他都不对</li></ul><p>正确答案: ABC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>运用下列哪个命令能够获取JVM的内存映像</p><ul><li>A jinfo</li><li>B jmap</li><li>C jhat</li><li>D jstat</li></ul><p>正确答案: B</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>1、jps：查看本机java进程信息。<br>2、jstack：打印线程的栈信息，制作线程dump文件。<br>3、jmap：打印内存映射，制作堆dump文件<br>4、jstat：性能监控工具<br>5、jhat：内存分析工具<br>6、jconsole：简易的可视化控制台<br>7、jvisualvm：功能强大的控制台</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>以下哪一个不是赋值符号？</p><ul><li>A +=</li><li>B &lt;&lt;=</li><li>C &lt;&lt;&lt;=</li><li>D &gt;&gt;&gt;=</li></ul><p>正确答案: C</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>A.很明显是赋值符号<br>B.&lt;&lt;=左移赋值<br>C.不是<br>D.&gt;&gt;&gt;= 右移赋值，左边空出的位以0填充</p><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>Java多线程有几种实现方法？</p><ul><li>A 继承Thread类</li><li>B 实现Runnable接口</li><li>C 实现Thread接口</li><li>D 以上都不正确</li></ul><p>正确答案: AB</p><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>多线程一共有三种实现方式<br>方式1：继承Thread类，并重写run()方法<br>方式2：实现Runnable接口，实现run()方法<br>方式3：实现Callable接口，线程结束后可以有返回值，但是该方式是依赖于线程池的。</p><h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>Java中的集合类包括ArrayList、LinkedList、HashMap等类，下列关于集合类描述正确的是（）</p><ul><li>A ArrayList和LinkedList均实现了List接口</li><li>B ArrayList的访问速度比LinkedList快</li><li>C 添加和删除元素时，ArrayList的表现更佳</li><li>D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</li></ul><p>正确答案: ABD</p><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>ArrayList插入和现有项的删除开销很大,除非在末端<br>LinkedList插入和删除开销很小<br>ArrayList和LinkedList都是实现了List接口<br>HashMap可以用null值和空字符串作为K,不过只能有一个</p><h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>下面的Java赋值语句哪些是有错误的 （）</p><ul><li>A int i =1000;</li><li>B float f = 45.0;</li><li>C char s = ‘\u0639’</li><li>D Object o = ‘f’;</li><li>E String s = “hello,world\0”;</li><li>F Double d = 100;</li></ul><p>正确答案: BF</p><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>不同的数据类型不能自动装箱拆箱，只有对应类型的数据类型和包装类才能自动装箱拆箱。<br>double类型的才可以自动装箱为Double<br>Double d = 100;中100为int类型，只能自动装箱为Integer</p><h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>true、false、null、sizeof、goto、synchronized  哪些是Java关键字？</p><ul><li>A true</li><li>B false</li><li>C null</li><li>D sizeof</li><li>E goto</li><li>F synchronized</li></ul><p>正确答案: EF</p><h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><ul><li>true、false、null是字面量。</li><li>goto、const是java保留字和关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月10日 Java1</title>
      <link href="/exam//c0d50785/"/>
      <url>/exam//c0d50785/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c0d50785/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/c0d50785/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/c0d50785/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/c0d50785/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/c0d50785/#考点5" class="header_1">考点5</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>%<span class="number">3</span>*<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>将打印？</p><ul><li>A 1</li><li>B 2</li><li>C 4</li><li>D 6</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>%</code>和<code>*</code>是同一个优先级，从左到右运算</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于非运行时异常，程序中一般可不做处理，由java虚拟机自动进行处理。</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>Java异常都继承自类Throwable，Throwable子类有Error和Exception，其中Exception又分为运行时异常和编译时异常。</p><ul><li>编译时异常是未雨绸缪性质的异常，需要显示处理。</li><li>运行时异常是程序员问题造成，并不强制进行显示处理。</li></ul><p>非运行异常=检查异常 需要try catch捕获或者throws抛出</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>如果一个list初始化为{5，3，1}，执行以下代码后，其结果为（）？<br>nums.add(6);<br>nums.add(0,4);<br>nums.remove(1);</p><ul><li>A [5, 3, 1, 6]</li><li>B [4, 3, 1, 6]</li><li>C [4, 3, 6]</li><li>D [5, 3, 6]</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li>初始化为{5,3,1}</li><li>nums.add(6)后list为{5,3,1,6}</li><li>nums.add(0,4)是在0号索引上添加数字4得到list为{4,5,3,1,6}</li><li>nums.remove(1)是将1号索引上的5进行remove得到list为{4,3,1,6}</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>给出以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObj</span></span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Object o=<span class="keyword">new</span> Object()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; </span><br><span class="line">        System.out.println(o.equals(“Fred”));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>请给出结果：（）</p><ul><li>A 运行时抛出异常</li><li>B true</li><li>C Fred</li><li>D 第三行编译错误</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>本题涉及匿名内部类、多态和覆盖三个知识点。 语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o=<span class="keyword">new</span> Object()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><br>创建了一个匿名内部类，并将所创建的匿名对象赋给 Object (多态：子类对象赋给超类引用)。同时，该匿名内部类重写了 Object<br>类的 equals 方法。<br>在执行语句<br>o.equals(“Fred”)<br>时，根据多态及覆盖原则，会调用匿名内部类重写后的 equals 方法。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下J2EE中常用的名词解释错误的是？</p><ul><li>A EJB容器：Enterprise java bean 容器</li><li>B JNDI：JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。</li><li>C JMS：JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。</li><li>D JAF：JAVA安全认证框架。提供一些安全控制方面的框架。</li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="J2EE中常用的名词解释"><a href="#J2EE中常用的名词解释" class="headerlink" title="J2EE中常用的名词解释"></a>J2EE中常用的名词解释</h3><p>1.<strong>web容器</strong>：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。<br>2.<strong>Web container</strong>：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。<br>3.<strong>EJB容器</strong>：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。<br>这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务，<br>配置，和其他的服务。<br>4.<strong>JNDI</strong>：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。<br>5.<strong>JMS</strong>：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。<br>6.<strong>JTA</strong>：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。<br>7.<strong>JAF</strong>：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。<br>8.<strong>RMI/IIOP</strong>:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月9日 java2</title>
      <link href="/exam//8e48d9cb/"/>
      <url>/exam//8e48d9cb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/8e48d9cb/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点11" class="header_1">考点11</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点12" class="header_1">考点12</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点13" class="header_1">考点13</a>&nbsp;<br><a href="/exam/8e48d9cb/#考点14" class="header_1">考点14</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列说法正确的有（ ）</p><ul><li>A class中的constructor不可省略</li><li>B constructor必须与class同名，但方法不能与class同名</li><li>C constructor可在一个对象被new时执行</li><li>D 一个class只能定义一个constructor</li></ul><p>正确答案: C</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>a. 类中的构造方法可以省略不写的<br>b. 构造方法必须跟类名相同，普通的类方法能与类同名的，但是要返回一个值。<br>c. 构造方法都在new 对象的时候调用的<br>d. 一个类可以定义多个构造方法的</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String str0=<span class="string">"0123456789"</span>;</span><br><span class="line"><span class="keyword">static</span> String str1=<span class="string">"0123456789"</span>;</span><br><span class="line">String str2=str1.substring(<span class="number">5</span>);</span><br><span class="line">String str3=<span class="keyword">new</span> String(str2);</span><br><span class="line">String str4=<span class="keyword">new</span> String(str3.toCharArray());</span><br><span class="line">str0=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>假定str0,…,str4后序代码都是只读引用。<br>Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）</p><ul><li>A 5</li><li>B 10</li><li>C 15</li><li>D 20</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>这是一个关于java的垃圾回收机制的题目。<strong>垃圾回收主要针对的是<code>堆区</code>的回收</strong>，因为<strong>栈区的内存是随着线程而释放的</strong>。<br>堆区分为三个区：</p><ul><li>年轻代(<code>Young Generation</code>)、</li><li>年老代(<code>Old Generation</code>)、</li><li>永久代(<code>Permanent Generation</code>,也就是方法区)。</li></ul><p><strong>年轻代</strong>:对象被创建时(<code>new</code>)的对象通常被放在<code>Young</code>(除了一些占据内存比较大的对象),经过一定的<code>Minor GC</code>(针对年轻代的内存回收)还活着的对象会被移动到年老代(一些具体的移动细节省略)。<br><strong>年老代</strong>:就是上述年轻代移动过来的和一些比较大的对象。<strong><code>Minor GC(Full GC)</code>是针对年老代的回收</strong><br><strong>永久代</strong>:存储的是<code>final</code>常量,<code>static</code>变量,常量池。</p><p><code>str3,str4</code>都是直接<code>new</code>的对象,而<code>substring</code>的源代码其实也是<code>new</code>一个<code>string</code>对象返回。<br>经过<code>full gc</code>之后,年老区的内存回收,则年轻区的占了15个,不算<code>PermGen</code>。所以答案选C</p><p><strong>垃圾回收机制这方面了解的比较少，有时间了解一下</strong></p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>运行代码，结果正确的是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(flag = <span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"true"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 编译错误</li><li>B TRUE</li><li>C FALSE</li><li>D 什么也没有输出</li></ul><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: B注意 if判断条件flag = true是**赋值语句**，返回true 不会执行else里面内容</details><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>从运行层面上来看，从四个选项选出不同的一个。</p><ul><li>A JAVA</li><li>B Python</li><li>C objectC</li><li>D C#</li></ul><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><details><summary>显示答案/隐藏答案</summary>正确答案: BA，C，D都是类C语言，B不是Python是解释执行的，其他语言都需要先编译</details><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>有以下一个对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String word=<span class="string">" "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.word=word;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        Data0bject. i=I;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>创建一个如下方式的DataObject:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataObject object=<span class="keyword">new</span> DataObject ( );</span><br><span class="line">object.setWord(<span class="string">"123"</span>);</span><br><span class="line">object.setI(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>将此对象序列化为文件，并在另外一个JVM中读取文件，进行反序列化，请问此时读出的DataObject对象中的word和i的值分别为：</p><ul><li>A “”, 0</li><li>B “”, 2</li><li>C “123”, 2</li><li>D “123”, 0</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>序列化保存的是<strong>对象的状态</strong>，静态变量属于<strong>类的状态</strong>，因此，<strong>序列化并不保存静态变量</strong>。所以i是没有改变的<br><strong>Java在序列化时不会实例化static变量和transient修饰的变量</strong>，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面有关java threadlocal说法正确的有？</p><ul><li>A ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递</li><li>B 线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</li><li>C 在Thread类中有一个Map，用于存储每一个线程的变量的副本。</li><li>D 对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式</li></ul><p>正确答案: ABCD</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p><strong>ThreadLocal类用来提供线程内部的<code>局部变量</code></strong>。这种变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量。<br>ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程的上下文。<br>可以总结为一句话：<strong>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度</strong>。</p><p>ThreadLocal设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p><h3 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a>ThreadLocal的使用场景</h3><p>数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。<br>如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>对接口的描述正确的是()</p><ul><li>A 一个类可以实现多个接口</li><li>B 接口可以有非静态的成员变量</li><li>C 在jdk8之前，接口可以实现方法</li><li>D 实现接口的任何类，都需要实现接口的方法</li></ul><p>正确答案: A</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>A，一个类只能有一个直接父类，但是继承是有传递性的。一个类可以实现多的接口。一个接口可以继承多个类。<br>B，接口中没有普通变量（普通成员变量），<strong>接口的成员变量都是<code>常量</code>，默认修饰符：public static final</strong><br>C，</p><ul><li><strong>JDK8之前接口中的方法都是默认public abstract的</strong>，抽象方法没有方法体</li><li><strong>JDK8时接口中可以有static、default的修饰的方法</strong>，static、default修饰的方法必须有方法。接口中的方法都不能被private和protected修饰。</li><li>外部接口、类只能被public修饰或者不写，</li><li>内部接口、类可以被四个访问修饰符修饰。</li></ul><p>D， 实现接口，其实就是需要重写接口中的abstract方法，一旦实现的类没有重写完，那么这个类必须是个抽象类（抽象类中可以没有抽象方法，但是有抽象方法的类必须是抽象类）。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>java7后关键字 switch 支不支持字符串作为条件：（）</p><ul><li>A 支持</li><li>B 不支持</li></ul><p>正确答案: A</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>在Java7之前，switch只能支持<br>byte、short、char、int或者其对应的封装类以及Enum类型。<br>在Java7中，呼吁很久的String支持也终于被加上了。</p><p>在switch语句中，表达式的值不能是null，否则会在运行时抛出NullPointerException。<br>在case子句中也不能使用null，否则会出现编译错误。<br>同时，case字句的值是不能重复的。对于字符串类型的也一样，但是字符串中可以包含Unicode转义字符。重复值的检查是在Java编译器对Java源代码进行相关的词法转换之后才进行的。也就是说，有些case字句的值虽然在源代码中看起来是不同的，但是经词法转换之后是一样的，就会在成编译错误。比如：“男”和“\u7537”就是一个意思。</p><p>可以看出，字符串类型在switch语句中利用hashcode的值与字符串内容的比较来实现的；但是在case字句中对应的语句块中仍然需要使用String的equals方法来进一步比较字符串的内容，这是因为哈希函数在映射的时候可能存在冲突。<br>switch(exp)，在JDK7之前，只能是byte、short、char、int或者对应的包装类，或者枚举常量（内部也是由整型或字符类型实现）。<br>为什么必须是这些呢，因为其实exp只是对int型支持的，其他都是因为可以自动拆卸或者自动向上转型到int，所以才可以。<br>到了JDK7的时候，String被引入了，为什么String能被引入呢？<br>其实本质上还是对int类型值得匹配。<br>原理如下，通过对case后面得String对象调用hashCode方法，得到一个int类型得hash值，然后用这个hash值来唯一标识这个case。那么当匹配时，首先调用exp的hashCode，得到exp的hash值，用这个hash值来匹配所有case，如果没有匹配成功，就说明不存在；如果匹配成功了，接着会调用字符串的equals方法进行匹配。（hash值一致，equals可不一定返回的就是true）。<br>所以，exp不能为null，cas子句使用的字符串也不能为null，不然会出现空指针异常。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>已知如下类定义：<br>class Base {<br> public Base (){<br> //…<br> }<br> public Base ( int m ){<br> //…<br> }<br> public void fun( int n ){<br> //…<br> }<br>}<br>public class Child extends Base{<br> // member methods<br>}<br>如下哪句可以正确地加入子类中？</p><ul><li>A private void fun( int n ){ //…}</li><li>B void fun ( int n ){ //… }</li><li>C protected void fun ( int n ) { //… }</li><li>D public void fun ( int n ) { //… }</li></ul><p>正确答案: D</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>方法的重写（override）两同两小一大原则：<br>方法名相同，参数类型相同<br>子类返回类型小于等于父类方法返回类型，<br>子类抛出异常小于等于父类方法抛出异常，<br>子类访问权限大于等于父类方法访问权限。</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>如下代码的 结果是什么 ?<br>class Base {<br>    Base() {<br>    System.out.print(“Base”);<br>    }<br>}<br>public class Alpha extends Base {<br>    public static void main( String[] args ) {<br>        new Alpha();<br>        //调用父类无参的构造方法<br>        new Base();<br>    }<br>}</p><ul><li>A Base</li><li>B BaseBase</li><li>C 编译失败</li><li>D 代码运行但没有输出</li><li>E 运行时抛出异常</li></ul><p>正确答案: B</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>关于下面程序，哪些描述是正确的: (  )<br> public class While {<br>public void loop() {<br>int x= 10;<br>while ( x )  {<br>System.out.print(“x minus one is “ + (x - 1));<br>x -= 1;<br>}<br>}<br>}</p><ul><li>A 行1有语法错误</li><li>B 行4有语法错误</li><li>C 行5有语法错误</li><li>D 行6有语法错误</li><li>E 行2有语法错误,loop是关键字</li><li>F 程序能够正常编译和运行</li></ul><p>正确答案: B</p><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>while()括号里的参数要是boolean类型，int类型不行</p><h1 id="考点12"><a href="#考点12" class="headerlink" title="考点12"></a>考点12</h1><p>假设如下代码中，若t1线程在t2线程启动之前已经完成启动。代码的输出是（）<br>public static void main(String[]args)throws Exception {<br>    final Object obj = new Object();<br>    Thread t1 = new Thread() {<br>        public void run() {<br>            synchronized (obj) {<br>                try {<br>                    obj.wait();<br>                    System.out.println(“Thread 1 wake up.”);<br>                } catch (InterruptedException e) {<br>                }<br>            }<br>        }<br>    };<br>    t1.start();<br>    Thread.sleep(1000);//We assume thread 1 must start up within 1 sec.<br>    Thread t2 = new Thread() {<br>        public void run() {<br>            synchronized (obj) {<br>                obj.notifyAll();<br>                System.out.println(“Thread 2 sent notify.”);<br>            }<br>        }<br>    };<br>    t2.start();<br>}</p><ul><li>A Thread 1 wake up Thread 2 sent notify.</li><li>B Thread 2 sent notify. Thread 1 wake up</li><li>C A、B皆有可能</li><li>D 程序无输出卡死</li></ul><p>正确答案: B</p><h2 id="解析-11"><a href="#解析-11" class="headerlink" title="解析"></a>解析</h2><p>选择B<br>执行obj.wait();时已释放了锁，所以t2可以再次获得锁，然后发消息通知t1执行，但这时t2还没有释放锁，所以肯定是执行t2，然后释放锁，之后t1才有机会执行。</p><h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>对于线程局部存储TLS(thread local storage)，以下表述正确的是</p><ul><li>A 解决多线程中的对同一变量的访问冲突的一种技术</li><li>B TLS会为每一个线程维护一个和该线程绑定的变量的副本</li><li>C 每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了</li><li>D Java平台的java.lang.ThreadLocal是TLS技术的一种实现</li></ul><p>正确答案: ABD</p><h2 id="解析-12"><a href="#解析-12" class="headerlink" title="解析"></a>解析</h2><p>ThreadLocal可以给一个初始值，而每个线程都会获得这个初始化值的一个副本，这样才能保证不同的线程都有一份拷贝。<br>ThreadLocal<br>不是用于解决共享变量的问题的，不是为了协调线程同步而存在，而是<strong>为了方便每个线程处理自己的状态而引入的一个机制</strong>.<br>ThreadLocal确实是保证了每一个线程都拥有一个变量的副本，而且这个副本的初始值取决于ThreadLoacl中initialValue方法的重写，如果initialValue方法中引用了一个全局的变量的地址，那么其他线程对全局变量的修改还是会影响到此线程中引用变量的内容。</p><h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>哪个是不正确的字符常量？</p><ul><li>A ”\n”</li><li>B ”1”</li><li>C ”a”</li><li>D ”\101”</li></ul><p>正确答案: ABCD</p><h2 id="解析-13"><a href="#解析-13" class="headerlink" title="解析"></a>解析</h2><ul><li>单引号才是字符常量</li><li>双引号是字符串常量</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月9日 java1</title>
      <link href="/exam//17418871/"/>
      <url>/exam//17418871/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'17418871'/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/'17418871'/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/'17418871'/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/'17418871'/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/'17418871'/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/'17418871'/#考点7" class="header_1">考点7</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>可以把任何一种数据类型的变量赋给Object类型的变量。</p><ul><li>A 对</li><li>B 错</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>引用类型的对象都可以赋值给Object变量；</li><li>而八大基础数据类型会先自动装箱成包装类型，然后再赋值给Object，所以编译运行都不会报错。</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下不是修饰符final的作用的是( )。</p><ul><li>A 修饰常量</li><li>B 修饰不可被继承的类</li><li>C 修饰不可变类</li><li>D 修饰不可覆盖的方法</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>final的作用</p><ol><li>final修饰的变量是常量，<ul><li>如果修饰的是<strong>引用变量</strong>则变量中的引用地址不可变，但是地址中的内容可以变。</li><li>如果修饰的是基本类型变量，则基本类型变量的值不可改变。</li></ul></li><li>final修饰的方法不可被<strong>重写</strong>，但是还是可以重载</li><li>final修饰的类<strong>不可继承</strong>。</li></ol><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>对于abstract声明的类，下面说法正确的是</p><ul><li>A 可以实例化</li><li>B 不可以被继承</li><li>C 子类为abstract</li><li>D 只能被继承</li><li>E 可以被抽象类继承</li></ul><p>正确答案: E</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>A,抽象类不能实例化，因为有抽象方法未实现<br>B,可以被继承。派生类可以实现抽象方法<br>C，子类可以是抽象的，也可以非抽象的<br>D，只能被继承说法太肯定，不正确<br>E，可以被抽象类继承，也可以被非抽象类继承</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列程序test 类中的变量c 的最后结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">50</span>) &#123;</span><br><span class="line">b = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = b + a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 10</li><li>B 0</li><li>C 19</li><li>D 编译出错</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p><strong>局部变量不会自动进行初始化</strong>，所以当使用局部变量时，而没有给该局部变量赋值就会产生编译错误。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面这段程序的输出结果是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        split(<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">                System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 12136</li><li>B 63121</li><li>C 61213</li><li>D 11236</li></ul><p>正确答案: A</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>考察方法进栈与出栈的顺序。先进后出<br>有个知识点，方法在出栈的时候，执行的是return语句。因为出栈就意味着方法结束并消费，如果没有return语句，那么方法出栈的时候什么都不执行，就直接销毁。<br>1.执行split（12）时，执行代码System.out.print(split(number / 2))<br>    split（12/2）进栈，此时number=6；<br>2.执行split（6）时，执行代码System.out.print(split(number / 2))<br>    split（6/2）进栈，此时number=3；<br>3.执行split（3）时，<br>第1行 if (number % 2 != 0)<br>第2行          System.out.print(split((number + 1) / 2));<br>第3行    System.out.print(split(number / 2));<br> 按照顺序执行<br> 先执行第2行<br>            首先split（(3+1)/2）进栈，此时number=2，<br>            再执行split（2），那么split（2/2）进栈，此时number=1， 最后return 1，<br>            注意此时第2行代码还没有结束<br>            此时<br>            split（2/2）出栈，输出1；<br>            split（(3+1)/2）出栈，输出2；<br>   第二行代码结束，再执行第三行，此时number=3，执行System.out.print(split(number / 2))<br>           split（3/2）进栈，number=1，return，那么就需要出栈了<br>split（3/2）出栈，输出1<br>split（6/2）出栈，输出3<br>split（12/2）出栈，输出6；<br>最终结果12136；<br>split（number）方法，最终返回的是number这个值，所以split（n）出栈的输出结果就是n<br>整理：<br>split（12/2）进栈<br>split（6/2）进栈<br>split（(3+1)/2）进栈<br>split（2/2）进栈<br>       split（2/2）出栈，输出1<br>        split（(3+1)/2）出栈，输出2<br>split（2/2）进栈<br>        split（2/2）出栈，输出1<br>split（6/2）出栈，输出3<br>split（12/2）出栈，输出6</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Which statement declares a variable a which is suitable for referring to an array of 50 string objects?（Java）</p><ul><li>A char a[][];</li><li>B String a[];</li><li>C String[] a;</li><li>D Object a[50];</li><li>E String a[50];</li><li>F Object a[];</li></ul><p>正确答案: BCF</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月8日 Java1</title>
      <link href="/exam//3942cc4b/"/>
      <url>/exam//3942cc4b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3942cc4b/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/3942cc4b/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/3942cc4b/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/3942cc4b/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/3942cc4b/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/3942cc4b/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/3942cc4b/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/3942cc4b/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/3942cc4b/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于下面代码 int[] x=new int[25]; 描述正确的是（）</p><ul><li>A x[25]存放了数据“\0”。</li><li>B x[24] 存放了数据“\0”。</li><li>C 若访问x[25]，程序将抛出异常。</li><li>D x[1]访问此数组的第一个元素。</li></ul><p>正确答案: C</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>A:不存在x[25] 索引从0开始到length-1<br>B:x[24]<br>存的是默认值0(java中没有’\0’这一说)<br>C:超出内存 正确<br>D:第二元素</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下表达式的类型和值是什么？（注意整数除法）（）<br>-5 + 1/4 + 2*-3 + 5.0</p><ul><li>A int -3</li><li>B int -4</li><li>C double -5.5</li><li>D double -6.0</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>注意题目说整数除法，所以1/4 = 0</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列修饰符中，能够使得某个成员变量可被它所在包访问到和它的子类访问到的是（ ）</p><ul><li>A protected</li><li>B public</li><li>C private</li><li>D 应不加修饰符</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">位置</th><th style="text-align:left">public</th><th style="text-align:left">protected</th><th style="text-align:left">default</th><th style="text-align:left">private</th></tr></thead><tbody><tr><td style="text-align:left">同一个类中</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td style="text-align:left">同一个包中</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">✘</td></tr><tr><td style="text-align:left">子类中</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">✘</td><td style="text-align:left">✘</td></tr><tr><td style="text-align:left">全局</td><td style="text-align:left">√</td><td style="text-align:left">✘</td><td style="text-align:left">✘</td><td style="text-align:left">✘</td></tr></tbody></table></div><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>内部类（也叫成员内部类）可以有4种访问权限。（  ）</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="为什么外部类只能public和默认修饰"><a href="#为什么外部类只能public和默认修饰" class="headerlink" title="为什么外部类只能public和默认修饰"></a>为什么外部类只能public和默认修饰</h3><p>外部类的上一级程序单元是包，所以其有两个作用域：同一包内和任何位置。因此只需要2种访问权限：包访问权限和公开访问权限，正好对应的省略访问控制符和public。省略访问控制符是包访问权限，即同一个包内的其他类可以访问省略访问控制符的成员。因此，如果一个外部类不使用任何访问控制符修饰，则只能被同一个包的其他类访问。</p><h3 id="为什么内部类可以使用四个访问控制符"><a href="#为什么内部类可以使用四个访问控制符" class="headerlink" title="为什么内部类可以使用四个访问控制符"></a>为什么内部类可以使用四个访问控制符</h3><p>而内部类的上一级程序单元是外部类，它就具有4个作用域：同一个类、同一个包、父子类和任何位置。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>你就把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下关于集合类ArrayList、LinkedList、HashMap描述错误的是（）</p><ul><li>A HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值</li><li>B ArrayList和LinkedList均实现了List接口</li><li>C 添加和删除元素时，ArrayList的表现更佳</li><li>D ArrayList的访问速度比LinkedList快</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ol><li><strong>List 是一个有序集合</strong>，可以存放重复的数据 (有序：存进是什么顺序，取出时还是什么顺序)<br>(1).ArrayList 底层是数组适合查询，不适合增删元素。<br>(2).LiskedList 底层是双向链表适合增删元素，不适合查询操作。<br>(3).Vector 底层和ArrayList相同，但是Vector是线程安全的，效率较低很少使用</li><li><strong>Set 是一个无序集合</strong>，不允许放重复的数据 (无序可重复，存进和取出的顺序不一样)<br>(1).HashSet 底层是哈希表/散列表<br>(2).TreeSet 继承sartedSet接口（无需不可重复，但存进去的元素可以按照元素的大小自动排序）</li><li>Map 是一个无序集合，以键值对的方式存放数据，键对象不允许重复，值对象可以重复。<br>(1).HashMap实现不同步，线程不安全。<strong>HashTable线程安全</strong><br>(2).HashMap中的key-value都是存储在Entry中的。<br>(3).HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<h3 id="数组插入删除效率低"><a href="#数组插入删除效率低" class="headerlink" title="数组插入删除效率低"></a>数组插入删除效率低</h3>数组的插入和删除效率比较低，读取的效率高，因为地址是连续的</li></ol><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下代码段执行后的输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(test());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="keyword">return</span> ++temp;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ++temp;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 1,2,2</li><li>B 1,2,3</li><li>C 1,3,3</li><li>D 1,3,2</li></ul><p>正确答案: D</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>finally代码块在try语句的return之前执行。try的return的值会被放入临时空间，然后执行finally代码块，如果finally中有return，会刷新临时空间的值，方法结束返回临时空间值，也就是finally中的return会覆盖try中的return。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Hashtable 和 HashMap 的区别是：</p><ul><li>A Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了 Map 接口</li><li>B HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口</li><li>C Hashtable 线程安全的，而 HashMap 是线程不安全的</li><li>D Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类</li><li>E HashMap允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li></ul><p>正确答案: BCDE</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>选B、C、D、E。</p><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>（1）Hashtable 是一个<strong>散列表</strong>，它存储的内容是键值对(key-value)映射。<br>（2）Hashtable 的函数都是同步的，这意味着<strong>HashTable是线程安全的</strong>。它的key、value都不可以为null。<br>（3）HashTable直接使用对象的hashCode。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>（1）由<strong>数组+链表</strong>组成的，基于<strong>哈希表</strong>的Map实现，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。<br>（2）<strong>HashMap是线程<code>不</code>安全的</strong>，HashMap可以接受为null的键(key)和值(value)。<br>（3）HashMap重新计算hash值</p><h3 id="Hashtable继承Dictionary"><a href="#Hashtable继承Dictionary" class="headerlink" title="Hashtable继承Dictionary"></a>Hashtable继承Dictionary</h3><p>Properties继承关系如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><h3 id="HashMap继承AbstractMap"><a href="#HashMap继承AbstractMap" class="headerlink" title="HashMap继承AbstractMap"></a>HashMap继承AbstractMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;<span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="Properties继承Hashtable"><a href="#Properties继承Hashtable" class="headerlink" title="Properties继承Hashtable"></a>Properties继承Hashtable</h3><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下面几个关于Java里queue的说法哪些是正确的（）？</p><ul><li>A LinkedBlockingQueue是一个可选有界队列，不允许null值</li><li>B PriorityQueue，LinkedBlockingQueue都是线程不安全的</li><li>C PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）</li><li>D PriorityQueue，ConcurrentLinkedQueue都遵循FIFO原则</li></ul><p>正确答案: AC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>A对、LinkedBlockingQueue是一个基于节点链接的<strong>可选是否有界</strong>的阻塞队列，不允许null值。<br>B错、LinkedBlockingQueue是一个<strong>线程安全</strong>的阻塞队列，实现了先进先出等特性。<br>C、PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）。<br>D、PriorityQueue是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，该队列的元素遵循FIFO原则。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于Java的一些概念，下面哪些描述是正确的：(        )</p><ul><li>A 所有的Java异常和错误的基类都是java.lang.Exception, 包括java.lang.RuntimeException</li><li>B 通过try … catch … finally语句，finally中的语句部分无论发生什么异常都会得到执行</li><li>C java中所有的数据都是对象</li><li>D Java通过垃圾回收回收不再引用的变量，垃圾回收时对象的finallize方法一定会得到执行</li><li>E Java是跨平台的语言，无论通过哪个版本的Java编写的程序都能在所有的Java运行平台中运行</li><li>F Java通过synchronized进行访问的同步，synchronized作用非静态成员方法和静态成员方法上同步的目标是不同的</li></ul><p>正确答案: BF</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A:Java中所有错误和异常的父类是java.lang.Throwable<br>C：基本数据类型不是对象，不能用new的方法获取，但是每个基本数据类型都对应着封装类型，这些封装类型为了解决基本数据类型面向对象用的。<br>D:Java垃圾回收器负责回收无用对象占据的内存资源,但对象没有使用new获取了一块特殊区域，这块特殊区域的回收使用finallize（）<br>E：Java跨平台是因为有JVM的存在，Java的三个版本的运行需要各自不同的环境。<br>F: Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月7日 计算机网络1</title>
      <link href="/exam//3a826652/"/>
      <url>/exam//3a826652/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3a826652/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/3a826652/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/3a826652/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/3a826652/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/3a826652/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/3a826652/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/3a826652/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/3a826652/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/3a826652/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>Internet中地理域名中国的缩写是（        ）</p><ul><li>A ch</li><li>B cn</li><li>C china</li><li>D chi</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>在 OSI 分层模型中，把传输的比特流划分为帧，是哪一层的功能（ ）</p><ul><li>A 物理层</li><li>B 网络层</li><li>C 数据链路层</li><li>D 传输层</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">层次</th><th style="text-align:left">传输数据类型</th></tr></thead><tbody><tr><td style="text-align:left">传输层</td><td style="text-align:left">片段</td></tr><tr><td style="text-align:left">网络层</td><td style="text-align:left">包</td></tr><tr><td style="text-align:left">数据链路层</td><td style="text-align:left">帧</td></tr><tr><td style="text-align:left">物理层</td><td style="text-align:left">比特</td></tr></tbody></table></div><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>正确的 IP 地址是 (  ) 。</p><ul><li>A 202.112.111.1</li><li>B 202.2.2.2.2</li><li>C 202.202.1</li><li>D 202.257.14.13</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>每个IP地址分为4段，段与段之间用小数点隔开，每段再用一个十进制整数表示，每个十进制整数的取值范围是0-255。故正确答案为A。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>HTML语言是一种(    )</p><ul><li>A 标注语言</li><li>B 机器语言</li><li>C 汇编语言</li><li>D 算法语言</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)<br>HTML 不是一种编程语言，而是一种标记语言 (markup language)<br>标记语言是一套标记标签 (markup tag)<br>HTML 使用标记标签来描述网页</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p><img src="https://uploadfiles.nowcoder.com/images/20180504/7366756_1525400408051_C312F56A2A650D1C2E64A70165833D39" alt="图片"><br>在OSI参考模型中，路由器R1、交换机Switch、集线器Hub实现的最高功能层分别是 。</p><ul><li>A 2、2、1</li><li>B 2、2、2</li><li>C 3、2、1</li><li>D 3、2、2</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>OSI参考模型中各层如下：<br>|层次|名称|<br>|:—|:—|<br>|7|应用层|<br>|6|表示层|<br>|5|会话层|<br>|4|传输层|<br>|3|网络层|<br>|2|数据链路层|<br>|1|物理层|</p><p><strong>集线器</strong>是一个多端口的中继器，工作在<strong>物理层</strong>。<br><strong>以太网交换机</strong>是一个多端口的网桥，工作在<strong>数据链路层</strong>。<br><strong>路由器</strong>是网络层设备，它实现了网络模型的下三层，即<strong>物理层、数据链路层和网络层</strong>。</p><p>题中R1、Switch和Hub分别是路由器、交换机和集线器，实现的<strong>最高层</strong>功能分别是网络层（即3）、数据链路层（即2）和物理层（即1）。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>在整个网络的设计中，对功能、可靠性和费用方面有着重要影响的因素是( )</p><ul><li>A 误码率</li><li>B 拓扑结构</li><li>C 网络距离</li><li>D 网络传输速率</li></ul><p>正确答案: B</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>拓扑结构是指网络中各个站点相互连接的形式，在局域网中明确一点讲就是文件服务器、工作站和电缆等的连接形式。<br>络的拓扑结构反映出网中各实体的结构关系，是建设<strong>计算机网络的第一步</strong>，是实现各种网络协议的基础，它对网络的性能，系统的可靠性与通信费用都有重大影响。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ADSL技术主要解决的问题是（  ）</p><ul><li>A 宽带传输</li><li>B 宽带接入</li><li>C 宽带交换</li><li>D 多媒体技术</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>一个5960字节的数据报（其中20字节IP首部加上5940字节的IP有效载荷）到达一台路由器，并且必须被转发到一条MTU为1500字节的链路上，并且原始数据报附加的标识号为587，试问此数据报被分的片数、第二分片的标识号和第四分片的标志位分别为（ ）</p><ul><li>A 4、587、0</li><li>B 5、587、1</li><li>C 4、588、1</li><li>D 5、588、0</li></ul><p>正确答案: B</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="分片计算方法"><a href="#分片计算方法" class="headerlink" title="分片计算方法"></a>分片计算方法</h3><p>每个分片都需要有IP首部，MTU=1500，ip首部长度为20，则每个分片的数据的最大长度为1480<br>第一分片：20+1480；<br>第二分片：20+1480；<br>第三分片：20+1480；<br>第四分片：20+1480；<br>第五分片：20+20；<br>5940/1480＝4.0135135135135<br> 4.0135135135135向上取整等于5，所以五个分片</p><h3 id="确定标识号"><a href="#确定标识号" class="headerlink" title="确定标识号"></a>确定标识号</h3><p>相同的标识号使得分片后的数据报片能正确的重装成原来的数据报；所有分片的标识号都应该一样，都和第一条分片的标识号587相同</p><h3 id="确定MF"><a href="#确定MF" class="headerlink" title="确定MF"></a>确定MF</h3><p>标志位的最低位MF=1表示后面还有分片。<br>总共有5个分片，第4个分片的MF为1，<br>第5个分片MF为0</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>在公司局域网上ping www.bilibili.com 没有涉及到的网络协议是？（）</p><ul><li>A TCP</li><li>B DNS</li><li>C ICMP</li><li>D ARP</li></ul><p>正确答案: A</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>ping 使用的协议为icmp，通过域名解析，需要用到DNS，局域网中使用arp进行主机间的通信。</p><p>TCP层是位于IP层之上,应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月6日 java2</title>
      <link href="/exam//7f438246/"/>
      <url>/exam//7f438246/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/7f438246/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/7f438246/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/7f438246/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/7f438246/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/7f438246/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            dianping();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"dazhong"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dianping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"dianping"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A dazhongdianping</li><li>B dianpingdazhong</li><li>C a和b都有可能</li><li>D dianping循环输出，dazhong夹杂在中间</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>调用run()方法不会创建一个新的线程，也就是现在只有一个main线程，run方法在main线程中执行。</li><li>一个线程中的代码执行顺序是固定的，所以先执行run()，在输出dazhong</li><li>调用start()方法才会创建线程。</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面有关java object默认的基本方法，说法错误的是？</p><ul><li>A equals(Object obj) 指示某个其他对象是否与此对象“相等”</li><li>B copy() 创建并返回此对象的一个副本</li><li>C wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li><li>D toString() 返回该对象的字符串表示</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>Object中没有copy方法，想不到吧！</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>结构型模式中最体现扩展性的模式是（）</p><ul><li>A 装饰模式</li><li>B 合成模式</li><li>C 桥接模式</li><li>D 适配器</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是结构型模式"><a href="#什么是结构型模式" class="headerlink" title="什么是结构型模式"></a>什么是结构型模式</h3><p>结构型模式是<strong>描述如何将类对象结合在一起，形成一个更大的结构</strong>。<br>结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。</p><h3 id="GoF结构型模式"><a href="#GoF结构型模式" class="headerlink" title="GoF结构型模式"></a>GoF结构型模式</h3><p>在GoF设计模式中，结构型模式有：</p><h4 id="1-适配器模式-Adapter"><a href="#1-适配器模式-Adapter" class="headerlink" title="1.适配器模式 Adapter"></a>1.适配器模式 Adapter</h4><p>适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。</p><h4 id="2-桥接模式-Bridge"><a href="#2-桥接模式-Bridge" class="headerlink" title="2.桥接模式 Bridge"></a>2.桥接模式 Bridge</h4><p>桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。</p><h4 id="3-组合模式-Composite"><a href="#3-组合模式-Composite" class="headerlink" title="3.组合模式 Composite"></a>3.组合模式 Composite</h4><p>组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h4 id="4-装饰模式-Decorator"><a href="#4-装饰模式-Decorator" class="headerlink" title="4.装饰模式 Decorator"></a>4.装饰模式 Decorator</h4><p>装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。<br>装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。</p><h4 id="5-外观模式-Facade"><a href="#5-外观模式-Facade" class="headerlink" title="5.外观模式 Facade"></a>5.外观模式 Facade</h4><p> 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。</p><h4 id="6-享元模式-Flyweight"><a href="#6-享元模式-Flyweight" class="headerlink" title="6.享元模式 Flyweight"></a>6.享元模式 Flyweight</h4><p> 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。</p><h4 id="7-代理模式-Proxy"><a href="#7-代理模式-Proxy" class="headerlink" title="7.代理模式 Proxy"></a>7.代理模式 Proxy</h4><p>为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面有关 java 类加载器,说法正确的是?()</p><ul><li>A 引导类加载器(bootstrap class loader):它用来加载 Java 的核心库,是用原生代码来实现的</li><li>B 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。</li><li>C 系统类加载器(system class loader):它根据 Java 应用的类路径(CLASSPATH)来加载 Java 类</li><li>D tomcat 为每个 App 创建一个 Loader,里面保存着此 WebApp 的 ClassLoader。需要加载 WebApp 下的类时,就取出 ClassLoader 来使用</li></ul><p>正确答案: ABCD</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="1）Bootstrap-ClassLoader"><a href="#1）Bootstrap-ClassLoader" class="headerlink" title="1）Bootstrap ClassLoader"></a>1）Bootstrap ClassLoader</h3><p>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p><h3 id="2）Extension-ClassLoader"><a href="#2）Extension-ClassLoader" class="headerlink" title="2）Extension ClassLoader"></a>2）Extension ClassLoader</h3><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定<br>目录下的jar包</p><h3 id="3）App-ClassLoader"><a href="#3）App-ClassLoader" class="headerlink" title="3）App ClassLoader"></a>3）App ClassLoader</h3><p>负责记载classpath中指定的jar包及目录中class</p><h3 id="4）Custom-ClassLoader"><a href="#4）Custom-ClassLoader" class="headerlink" title="4）Custom ClassLoader"></a>4）Custom ClassLoader</h3><p> 属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p><h3 id="自底向上检查类是否加载"><a href="#自底向上检查类是否加载" class="headerlink" title="自底向上检查类是否加载"></a>自底向上检查类是否加载</h3><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，<br>从Custom ClassLoader到BootStrap<br>ClassLoader逐层检查，<br>只要某个classloader已加载就视为已加载此类</p><h3 id="加载顺序自顶向下"><a href="#加载顺序自顶向下" class="headerlink" title="加载顺序自顶向下"></a>加载顺序自顶向下</h3><p>而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>Java类Demo中存在方法func0、func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">byte</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">short</span> i=<span class="number">2</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">long</span> i=<span class="number">3</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">float</span> <span class="title">func4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">　　</span>&#123;</span><br><span class="line">　　　　<span class="keyword">double</span> i=<span class="number">4</span>;</span><br><span class="line">　　　　<span class="keyword">return</span> i;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A func1</li><li>B func2</li><li>C func3</li><li>D func4</li></ul><p>正确答案: AD</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>这道题考的是数据类型转换问题。由大到小需要强制转换，由小到大不需要。<br>A：return;   没有返回值，错误<br>B：short 转成 float 无须强制转换，正确<br>C：long 转成 float  无须强制转换（这个最选项容易出错），正确。<br>float占4个字节为什么比long占8个字节大呢，因为底层的实现方式不同。<br>浮点数的32位并不是简单直接表示大小，而是按照一定标准分配的。<br>第1位，符号位，即S<br>接下来8位，指数域，即E。<br>剩下23位，小数域，即M，取值范围为[1 ,2 ) 或[0 , 1)<br>然后按照公式：<br>V=(-1)^s <em> M </em> 2^E<br>也就是说浮点数在内存中的32位不是简单地转换为十进制，而是通过公式来计算而来</p><p>虽然float只有4个字节，但浮点数最大值要比长整型的范围要大。<br>D：double → float 没有强制转换，错误。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月5日 java3</title>
      <link href="/exam//d28ae0ae/"/>
      <url>/exam//d28ae0ae/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/d28ae0ae/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/d28ae0ae/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面语句正确的是（）</p><ul><li>A x+1=5</li><li>B i++=1</li><li>C a++b=1</li><li>D x+=1</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="赋值运算左值必须是变量"><a href="#赋值运算左值必须是变量" class="headerlink" title="赋值运算左值必须是变量"></a>赋值运算左值必须是变量</h3><p>赋值运算符“=”右值可以是任何常数、变量或者表达式（只要能生成一个值就行）。但<strong>左值必须是一个明确的、已命名的变量</strong><br>所以对于i++ = 1，a++b = 1，x+1=5来说，赋值运算符的左边不是一个变量当然是错误的。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>类Person里面有个方法sleep()，如果直接用Person.sleep()，则方法sleep前面必须用的关键词是？  (    )</p><ul><li>A class</li><li>B static</li><li>C public</li><li>D final</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列描述中，错误的是</p><ul><li>A SQL语言又称为结构化查询语言</li><li>B java中”static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问</li><li>C 面向对象开发中，引用传递意味着传递的并不是实际的对象，而是对象的引用，因此，外部对引用对象所做的改变不会反映到所引用的对象上</li><li>D java是强类型语言，javascript是弱类型语言</li><li>E 面向对象的三大特性包括：封装，继承，多态</li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>这道题选C，因为引用代表就是所引用的是实际的对象，<strong>对引用的修改就是对对象的修改</strong>，可以理解为两把钥匙可以打开同一扇门，所以C错；其他几个选项都是对的</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列说法正确的是()</p><ul><li>A WebLogic中开发消息Bean的non－persistent 方式可以保证消息的可靠</li><li>B EJB容器发生错误，non－persistent方式下JMS容器仍然会将消息发送</li><li>C EJB容器发生错误，persistent方式下JMS容器仍然会将消息发送</li><li>D EJB容器发生错误，两种方式下JMS容器仍会在MDB可用的时候将消息发送</li></ul><p>正确答案: C</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>我不懂，解析我也看不懂，有空了解一下</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列语句正确的是：</p><ul><li>A 形式参数可被字段修饰符修饰</li><li>B 形式参数不可以是对象</li><li>C 形式参数为方法被调用时真正被传递的参数</li><li>D 形式参数可被视为local variable</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>A：形式参数只能被final修饰<br>B：形式参数可以是对象<br>C：形式参数被调用时被传递的是实际参数的拷贝<br>D：local variable：局部变量</p><h3 id="修饰符待整理"><a href="#修饰符待整理" class="headerlink" title="修饰符待整理"></a>修饰符待整理</h3><p>Java语言提供了很多修饰符，大概分为两类： </p><ol><li>访问权限修饰符 </li><li>非访问权限修饰符<br>访问权限修饰符<br>public：共有访问。对所有的类都可见。<br>protected：保护型访问。对同一个包可见，对不同的包的子类可见。<br>default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。<br>private：私有访问。只对同一个类可见，其余都不见。<br>非访问权限修饰符<br>static 修饰符，用来创建类方法和类变量。<br>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。<br>abstract 修饰符，用来创建抽象类和抽象方法。<br>synchronized 用于多线程的同步。<br>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。<br>transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。<br>类<br>外部类修饰符<br>public（访问控制符），将一个类声明为公共类，它可以被任何对象访问，一个程序的主类必须是公共类。<br>default（访问控制符），类只对包内可见，包外不可见。<br>abstract（非访问控制符），将一个类声明为抽象类，抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充，抽象类可以包含抽象方法和非抽象方法。。<br>final（非访问控制符），将一个类生命为最终（即非继承类），表示它不能被其他类继承。<br>注意：<br>1.protected 和 private 不能修饰外部类，是因为外部类放在包中，只有两种可能，包可见和包不可见。 </li><li>final 和 abstract不能同时修饰外部类，因为该类要么能被继承要么不能被继承，二者只能选其一。<br>3.不能用static修饰类，因为类加载后才会加载静态成员变量。所以不能用static修饰类和接口，因为类还没加载，无法使用static关键字。<br>内部类修饰符<pre><code>内部类与成员变量地位一直，所以可以public,protected、default和private，同时还可以用static修饰，表示嵌套内部类，不用实例化外部类，即可调用。</code></pre>方法修饰符<br>public（公共控制符），包外包内都可以调用该方法。<br>protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。具体细节可参考：<a href="http://blog.csdn.net/dawn_after_dark/article/details/74453915" target="_blank" rel="noopener">http://blog.csdn.net/dawn_after_dark/article/details/74453915</a><br>default(默认权限），指定该方法只对同包可见，对不同包（含不同包的子类）不可见。<br>private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类），非常严格的控制。<br>final ,指定方法已完备，不能再进行继承扩充。<br>static，指定不需要实例化就可以激活的一个方法，即在内存中只有一份，通过类名即可调用。<br>synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对它所属的方法加锁，以防止其他线程的访问，运行结束后解锁。<br>native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。<br>abstract ,抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 抽象方法的声明以分号结尾，例如：public abstract sample();。<br>成员变量修饰符<br>public（公共访问控制符），指定该变量为公共的，它可以被任何对象的方法访问。<br>protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。<br>default(默认权限），指定该变量只对同包可见，对不同包（含不同包的子类）不可见。<br>private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。<br>final，最终修饰符，指定此变量的值不能变。<br>static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。<br>transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。不持久化。<br>volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改，保证两个不同的线程总是看到某个成员变量的同一个值。<br>final 和 static 经常一起使用来创建常量。<br>局部变量修饰符<br>only final is permitted。<br>为什么不能赋予权限修饰符？<br>因为局部变量的生命周期为一个方法的调用期间，所以没必要为其设置权限访问字段，既然你都能访问到这个方法，所以就没必要再为其方法内变量赋予访问权限，因为该变量在方法调用期间已经被加载进了虚拟机栈，换句话说就是肯定能被当前线程访问到，所以设置没意义。<br>为什么不能用static修饰<br>我们都知道静态变量在方法之前先加载的，所以如果在方法内设置静态变量，可想而知，方法都没加载，你能加载成功方法内的静态变量？<br>接口<br>接口修饰符<br>接口修饰符只能用public、default和abstract。<br>不能用final、static修饰。<br>接口默认修饰为abstract。<br>接口中方法修饰符<br>only public &amp; abstract are permitted 。<br>意思只能用 public abstract修饰，当然如果你什么都不写，默认就是public abstract。<br>注意：在Java1.8之后，接口允许定义static 静态方法了！所以也可以用static来修饰！</li></ol><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（）</p><ul><li>A 1</li><li>B -(2^62+2^61+2^60+1)</li><li>C 2^62+2^61+2^60+1</li><li>D 2^59+(2^55+2^54+…+2^2+2^1+2^0)</li></ul><p>正确答案: C</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0Xf000000000000000补码为1111000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">0x7FFFFFFFFFFFFFFF补码为0111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">a-b&#x3D;a+(-b)&#x3D;</span><br><span class="line">1111000000000000000000000000000000000000000000000000000000000000+</span><br><span class="line">1000000000000000000000000000000000000000000000000000000000000001&#x3D;</span><br><span class="line">10111000000000000000000000000000000000000000000000000000000000001(高位溢出舍去)</span><br><span class="line">则结果为</span><br><span class="line">0111000000000000000000000000000000000000000000000000000000000001&#x3D;</span><br><span class="line">2^62+2^61+2^60+1</span><br><span class="line">答案为C</span><br></pre></td></tr></table></figure><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>Java对象的初始化方式有（ ）</p><ul><li>A 初始化块</li><li>B 构造器</li><li>C 定义变量时指定初始化值</li><li>D 其它各项都不对</li></ul><p>正确答案: ABC</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="对象的初始化方式"><a href="#对象的初始化方式" class="headerlink" title="对象的初始化方式"></a>对象的初始化方式</h3><p>1.new时初始化<br>2.静态工厂 newInstance；<br>3.反射Class.forName()；<br>4.clone方式；<br>5.反序列化；</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下面关于变量及其范围的陈述哪些是不正确的（）</p><ul><li>A 实例变量是类的成员变量</li><li>B 实例变量用关键字static声明</li><li>C 在方法中定义的局部变量在该方法被执行时创建</li><li>D 局部变量在使用前必须被初始化</li></ul><p>正确答案: BC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>实例变量属于对象<br>c选项应该是在线程为该方法<strong>创建栈桢时</strong>被创建，而不是方法<strong>执行</strong>时创建</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月5日 Java 2</title>
      <link href="/exam//a58dd038/"/>
      <url>/exam//a58dd038/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/a58dd038/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/a58dd038/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/a58dd038/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/a58dd038/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/a58dd038/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/a58dd038/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/a58dd038/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/a58dd038/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/a58dd038/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>一般情况下，以下哪个选项不是关系数据模型与对象模型之间匹配关系？</p><ul><li>A 表对应类</li><li>B 记录对应对象</li><li>C 表的字段对应类的属性</li><li>D 表之间的参考关系对应类之间的依赖关系</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>一般关系数据模型和对象数据模型之间有以下对应关系：</p><ul><li>表对应类，</li><li>记录对应对象，</li><li>表的字段对应类的属性</li></ul><p>目前ORMapping只是规定了数据结构和数据集的映射关系，还没到规定赖关系的阶段</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>已知有下列Test类的说明，在该类的main方法内，则下列哪个语句是正确的？（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> f = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A t.f;</li><li>B this.n;</li><li>C Test.m</li><li>D Test.f</li></ul><p>正确答案: A</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>A的答案中变量虽然为private，但因为main函数在该类中，所以即使private也仍可使用</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面赋值语句中正确的是（）</p><ul><li>A double d=5.3e12;</li><li>B float f=11.1;</li><li>C int i=0.0;</li><li>D Double oD=3;</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>java中整型默认的是int,浮点默认的是double.<br>A: double类型遵循IEEE754标准（具体自己查一下），约为10^-308~10^308和-10^-308~-10^308，所以本题在范围里<br>B: double类型的11.1 转成 float，是需要强制转换的<br>C: double类型的0.0 转成 int，也是需要强制转换的<br>D: int 转为 封装类型Double，是无法编译的，int虽可以转换成double，但在类型转换时无法进行自动装箱，故错误</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列不属于Java语言性特点的是</p><ul><li>A Java致力于检查程序在编译和运行时的错误</li><li>B Java能运行虚拟机实现跨平台</li><li>C Java自己操纵内存减少了内存出错的可能性</li><li>D Java还实现了真数组，避免了覆盖<code>数据类型</code>的可能</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是真数组"><a href="#什么是真数组" class="headerlink" title="什么是真数组"></a>什么是真数组</h3><p>程序设计语言中，数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，这样的数组称之为“真数组”。<br>实现了真数组为Java语言健壮性的特点之一。</p><p>真数组：<br>1、在内存中连续分配。<br>2、数组所存在的内存空间为数组专用，避免了<code>数据</code>被覆盖的问题。</p><p>是避免数据覆盖，而不是数据类型覆盖</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>在java语言中，如果你编写一个多线程序，可以使用的方法是（）</p><ul><li>A 扩展类Thread</li><li>B 实现Runnable接口</li><li>C 扩展类 Runnable</li><li>D 实现接口Thread</li></ul><p>正确答案: AB</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>Java多线程实现方式主要有四种：<br>1、继承Thread类<br>2、实现Runnable接口<br>3、实现Callable接口通过FutureTask包装器来创建Thread线程<br>4、使用ExecutorService、Callable、Future实现有返回结果的多线程</p><p>前两种方式线程执行完后都没有返回值，后两种是带返回值的。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面哪几个语句正确的声明一个整型的二维数组（）</p><ul><li>A int a[][]=new int[][]</li><li>B int b[10][10]=new int[][]</li><li>C int c[][]=new int[10][10]</li><li>D int []d[]=new int[10][10]</li></ul><p>正确答案: CD</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ol><li>定义一维数组时，必须显式指明数组的长度；</li><li>定义多维数组时，其<strong>一维数组的长度必须首先指明</strong>，其他维数组长度可以稍后指定；</li><li>采用给定值初始化数组时，不必指明长度；</li><li>“[]” 是数组运算符的意思，在声明一个数组时，数组运算符可以放在数据类型与变量之间，也可以放在变量之后。</li></ol><p>一维数组中，[]在变量名arr前还是后，这个写法没有固定的要求，<br>二维数组中，[][]a这三个元素其实可以作<strong>全排列</strong>，不论怎么排都不影响最后的编译结果，写法没有固定的要求。<br>在实际编程中，但最好统一。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>有以下程序段， 则下面正确的选项是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThead t=<span class="keyword">new</span> MyThead();</span><br><span class="line">        MyThead s=<span class="keyword">new</span> MyThead();</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">"one."</span>);</span><br><span class="line">        s.start();</span><br><span class="line">        System.out.println(<span class="string">"two."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 编译失败</li><li>B 程序运行可能结果为： one. Thread two. Thread</li><li>C 程序运行可能结果是： one. two. Thread Thread</li><li>D 程序运行结果不稳定</li></ul><p>正确答案: BCD</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>同一个线程中的输出顺序是确定的，main线程中的输出语句确定，也就是，只要one在two前面输出，thread在其后面那个位置输出无所谓。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有（ ）</p><ul><li>A private</li><li>B public</li><li>C protected</li><li>D static</li></ul><p>正确答案: AC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>java8 接口新特性：可以定义：</p><ul><li>静态方法（有方法体） 和</li><li>default方法（有方法体</li></ul><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>有关线程的叙述正确的是()</p><ul><li>A 可以获得对任何对象的互斥锁定</li><li>B 通过继承Thread类或实现Runnable接口，可以获得对类中方法的互斥锁定</li><li>C 线程通过使用synchronized关键字可获得对象的互斥锁定</li><li>D 线程调度算法是平台独立的</li></ul><p>正确答案: CD</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A，“任何对象”锁定，太绝对了，你能锁住你没有权限访问的对象吗？<br>B，前半句话讲的是创建线程的方式，后半句讲的是锁定，驴头不对马嘴。<br>C，正确。<br>D，线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平台独立的原因。<br>以上，选CD</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月5日 Java 1</title>
      <link href="/exam//3c848182/"/>
      <url>/exam//3c848182/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3c848182/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/3c848182/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/3c848182/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/3c848182/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/3c848182/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/3c848182/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/3c848182/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/3c848182/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>一个类中，有两个方法名、形参类型、顺序和个数都完全一样，返回值不一样的方法,这种现象叫覆盖。（  ）</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下关于Object类的说法正确的是（）</p><ul><li>A Java中所有的类都直接或间接继承自Object，无论是否明确的指明，无论其是否是抽象类。</li><li>B Java中的接口(interface)也继承了Object类</li><li>C 利用“==”比较两个对象时，Java调用继承自Object的equals方法，判断是否相等。</li><li>D 如果类的定义中没有重新定义toString()方法，则该类创建的对象无法使用toStrig()方法。</li></ul><p>正确答案: A</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li>A. Java中的所有类都直接或间接继承自Object，无论是否明确的指明，也无论其是否是抽象类。</li><li>B. Java中的接口（interface）并没有继承自Object一个类的子类必然是另一个类，如果interface继承自Object，那么interface也必然是一个类。这和接口的定义矛盾</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>执行如下代码后输出结果为（ ）<br>public class Test {<br> public static void main(String[] args) {<br>     System.out.println(“return value of getValue(): “ + getValue());<br> }<br> public static int getValue() {<br>     int i = 1;<br>     try {<br>         i = 4;<br>     } finally{<br>         i++;<br>         return i;<br>     }<br>     }<br> }</p><ul><li>A return value of getValue(): 1</li><li>B return value of getValue(): 4</li><li>C return value of getValue(): 5</li><li>D 其他几项都不对</li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>列表(List)和集合(Set)下面说法正确的是？  ( )</p><ul><li>A Set中至多只能有一个空元素</li><li>B List中至多只能有一个空元素</li><li>C List和Set都可以包含重复元素的有序集合</li><li>D List和Set都是有序集合</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>Set 不能有重复的元素，且是无序的，要有空值也就只能有一个。因为它不允许重复。 </li><li>List 可以有重复元素，且是有序的，要有空值也可以有多个，因为它可重复</li></ul><h3 id="集合中的有序的含义"><a href="#集合中的有序的含义" class="headerlink" title="集合中的有序的含义"></a>集合中的有序的含义</h3><p>java里面讲的<strong>有序无序</strong>，指的是你按照顺序存进去数据，然后再按照顺序取出来，两者是一样的。比如List(0)我放的是“a”，那么我list.get(0)取出来也是“a”。<br>并不代表我存了打乱顺序存1到10十个数，它会自己给按照升序或者降序给你排好序。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>关于以下程序代码的说明正确的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasStatic</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[ ])</span></span>&#123;</span><br><span class="line">        HasStatic hs1 = <span class="keyword">new</span> HasStatic();</span><br><span class="line">        hs1.x++;</span><br><span class="line">        HasStatic hs2 = <span class="keyword">new</span> HasStatic();</span><br><span class="line">        hs2.x++;</span><br><span class="line">        hs1=<span class="keyword">new</span> HasStatic();</span><br><span class="line">        hs1.x++;</span><br><span class="line">        HasStatic.x--;</span><br><span class="line">        System.out.println( <span class="string">"x="</span> +x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 5行不能通过编译，因为引用了私有静态变量</li><li>B 10行不能通过编译，因为x是私有静态变量</li><li>C 程序通过编译，输出结果为：x=103</li><li>D 程序通过编译，输出结果为：x=102</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul><li>此处是main函数在这个类内部，因而可以访问私有的静态成员。</li><li>在其他类中的main方法是会显示语法有错</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>如下的Java程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">     System.out.println(args[<span class="number">0</span>]); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 若采用命令行“java Test one two three”调用，则程序输出的结果为：</p><ul><li>A Test</li><li>B one</li><li>C two</li><li>D java</li></ul><p>正确答案: B</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>不要和linux脚本的参数弄混了。</p><ul><li>Linux里$0是程序名，$1以后才是参数</li><li>java里arg[0]就是第一个参数</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>以下代码段执行后的输出结果为<br>public class Test {<br>public static void main(String args[]) {<br>int i = -5;<br>i =  ++(i++);<br>System.out.println(i);<br>}<br>}</p><ul><li>A -7</li><li>B -3</li><li>C 编译错误</li><li>D -5</li></ul><p>正确答案: C</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>i++表示<strong>先赋值后加1</strong>，但前面又有一个++<strong>表示先加1再赋值</strong>，矛盾，编译器报错。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>以下哪些内存区域属于JVM规范？（　　）</p><ul><li>A 方法区</li><li>B 实例变量</li><li>C 静态变量</li><li>D 程序计数器</li><li>E 虚拟机栈</li></ul><p>正确答案: ADE</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>JVM内存区：</p><ul><li>程序计数器、</li><li>虚拟机栈、</li><li>本地方法栈、</li><li>堆、</li><li>方法区（包括常量池）。</li></ul><p>不属于JVM内存区：直接内存（Direct Memory），用户I/O操作</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月6日 java1</title>
      <link href="/exam//e64ad3fc/"/>
      <url>/exam//e64ad3fc/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/e64ad3fc/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/e64ad3fc/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于容器下面说法正确的是？ ( )</p><ul><li>A 列表(List)和集合(Set)存放的元素都是可重复的。</li><li>B 列表(List)和集合(Set)存放的元素都是不可重复的。</li><li>C 映射(Map)<key,value>中key是可以重复的。</li><li>D 映射(Map)<key,value>中value是可以重复的。</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>List列表的元素是有序的，可重复的</li><li>集合Set的元素是无序的，不可重复的</li><li>map是使用的是键值对存放，key不重复，value是可重复的</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下关于继承的叙述正确的是</p><ul><li>A 在Java中类只允许单一继承</li><li>B 在Java中一个类不能同时继承一个类和实现一个接口</li><li>C 在Java中接口只允许单一继承</li><li>D 在Java中一个类只能实现一个接口</li></ul><p>正确答案: A</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li>类支持单继承，</li><li>接口支持多继承，一个接口可以有多个父接口，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。一个接口继承多个父接口时，多个父接口排在extends关键字之后。</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下会产生信息丢失的类型转换是( ）</p><ul><li>A float a=10</li><li>B int a=（int）8846.0</li><li>C byte a=10； int b=-a</li><li>D double d=100</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>精度丢失只会发生在从大范围到小范围的转换<br>上面四个选项，只有 B 是从 double 到 int，也就是从大范围到小范围。</p><p>float a=10.0; 是把 double 转车 float. 会损失精度. 正确的写法是 float=10.0f;</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>java Thread中，run方法和start方法的区别，下面说法错误的是？</p><ul><li>A 通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。</li><li>B 他们都可以实现了多线程运行。</li><li>C run方法是thread的一个普通方法调用。</li><li>D 调用start方法后，一旦得到cpu时间片，就开始执行run()方法。</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="start方法和run方法的区别"><a href="#start方法和run方法的区别" class="headerlink" title="start方法和run方法的区别"></a>start方法和run方法的区别</h3><h4 id="1-start方法"><a href="#1-start方法" class="headerlink" title="1.start方法"></a>1.start方法</h4><p>用start方法来启动线程，是真正实现了多线程，<br>通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p><h4 id="2-run方法"><a href="#2-run方法" class="headerlink" title="2.run方法"></a>2.run方法</h4><p>run()方法只是类的一个普通方法而已，<strong>如果直接调用run方法，程序中依然只有主线程这一个线程</strong>，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面哪个选项正确创建socket连接？</p><ul><li>A Socket s = new Socket(8080);</li><li>B Socket s = new Socket(“192.168.1.1”,8080)</li><li>C SocketServer s = new Socket(8080);</li><li>D Socket s = new SocketServer(“192.168.1.1”,8080)</li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h3 id="创建客户端Socket"><a href="#创建客户端Socket" class="headerlink" title="创建客户端Socket"></a>创建客户端Socket</h3><p>创建 Socket 肯定要知道服务器ip 和 port 啊<br>服务器的 ServerSocket 只需要开放端口号就行啦<br>也就是<br>服务器端：ServerSocket提供的实例 ServerSocket server = new ServerSocket(端口号)<br>客户端：Socket提供的实例 Socket client = new Socket(IP地址，端口号)</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>变量a是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF;变量b是一个64位有符号的整数，初始值用16进制表示为：0x8000000000000000。则a+b的结果用10进制表示为多少？</p><ul><li>A 1</li><li>B -1</li><li>C 2^63+2^62+…+2^2+2^1+2^0</li><li>D –(2^63+2^62+…+2^2+2^1+2^0)</li></ul><p>正确答案: B</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>计算机中是以补码存储并参与运算的，所以题目中的初始值均是补码<br>（1）a+b的16进制表示为：OxFFFFFFFFFFFFFFF（16位F），转为2进制为111……111（64位1，每个F-&gt;4位2）。<br>（2）有符号数：是针对二进制来讲的。用最高位作为符号位，“0”代表“+”，“1”代表“-”。所以a+b的结果是一个负数。<br>（3）计算机中负数是以补码的形式保存的，将补码转换成原码的计算方式如下：<br>        ①. 对于正数，原码与补码相同。<br>        ②.对于负数，将补码除符号位之外，按位取反，末位加1，即得到原码。<br>（4）a + b = 111……111（64位1）<br>          取反：100……000（1位1，后面63位0）<br>          加一：100……001（中间62位0）<br>      10进制：-1。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>,b3,b6;  </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;  </span><br><span class="line">b6=b4+b5;  </span><br><span class="line">b3=(b1+b2);  </span><br><span class="line">System.out.println(b3+b6);</span><br></pre></td></tr></table></figure><br>关于上面代码片段叙述正确的是（）</p><ul><li>A 输出结果：13</li><li>B 语句：b6=b4+b5编译出错</li><li>C 语句：b3=b1+b2编译出错</li><li>D 运行期抛出异常</li></ul><p>正确答案: C</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>没有final修饰的byte变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。</p><h3 id="表达式的数据类型自动提升规则。"><a href="#表达式的数据类型自动提升规则。" class="headerlink" title="表达式的数据类型自动提升规则。"></a>表达式的数据类型自动提升规则。</h3><p>①所有的byte,short,char型的值将被提升为int型；<br>②如果有一个操作数是long型，计算结果是long型；<br>③如果有一个操作数是float型，计算结果是float型；<br>④如果有一个操作数是double型，计算结果是double型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span> b4=<span class="number">4</span>,b5=<span class="number">6</span>;</span><br><span class="line">b6=b4+b5;</span><br></pre></td></tr></table></figure><p>声明b4与b5为final常量，不可改变。<br>所以b4+b5的结果为byte类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1=<span class="number">1</span>,b2=<span class="number">2</span>;</span><br><span class="line">b3=(b1+b2);</span><br></pre></td></tr></table></figure><br>b1+b2的结果会自动升级为int类型。<br>int类型赋值给低级别byte的需要强制转换。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>已知如下的命令执行 java MyTest a b c 请问哪个语句是正确的？ ( )</p><ul><li>A args[0] = “MyTest a b c”</li><li>B args[0] = “MyTest”</li><li>C args[0] = “a”</li><li>D args[1]= “b”</li></ul><p>正确答案: CD</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>对于代码 var a = 10.42; 取出 a 的整数部分，以下代码哪些是正确的？</p><ul><li>A parseInt(a);</li><li>B Math.floor(a);</li><li>C Math.ceil(a);</li><li>D a.split(‘.’)[0];</li></ul><p>正确答案: AB</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><h3 id="Math的ceil-floor-round详解"><a href="#Math的ceil-floor-round详解" class="headerlink" title="Math的ceil floor round详解"></a>Math的ceil floor round详解</h3><ul><li>Math.ceil(); ceiling（天花板） 所以向上取整</li><li>Math.floor();floor（地板）所以向下取整</li><li>Math.round() <ul><li>对于正数是四舍五入，</li><li>对于负数,<ul><li>小数点后的数&lt;=5都是舍去，</li><li>而大于5是减一</li></ul></li></ul></li></ul><h3 id="关于java-10引入的var"><a href="#关于java-10引入的var" class="headerlink" title="关于java 10引入的var"></a>关于java 10引入的var</h3><p>2018年3月20日，Oracle发布java10。java10为java带来了很多新特性，其中包括var关键字的引入。<br>eg：<br>public class Example {<br>    public static void main(String[] args) {<br>        var eg = new Example;<br>        eg.emptyFunc();<br>    }<br>    public void emptyFunc() {}<br>}</p><h4 id="java对var的要求"><a href="#java对var的要求" class="headerlink" title="java对var的要求"></a>java对var的要求</h4><p>java在var上是有要求的。总结起来，有以下三点很重要：<br>（1）只能用于局部变量上；<br>（2）声明时必须初始化；<br>（3）不能用作方法参数。</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面关于面向对象的一些理解哪些是错误的(    )</p><ul><li>A 面向对象的最重要的特性是支持继承、封装和多态</li><li>B 系统设计应该遵循开闭原则，系统应该稳定不不可修改，但应支持通过继承、组合等方式进行扩展</li><li>C 函数式的语言必然是面向对象的语言</li><li>D 面向对象设计时，每个类的职责应该单一，不要再一个类中引入过多的接口</li><li>E 过程式语言和面向对象的语言各有其优势，过程式语言更加灵活，面向对象语言更加强调抽象和封装</li><li>F Java和C++都是静态类型的面向对象编程语言</li></ul><p>正确答案: C</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是动态类型语言"><a href="#什么是动态类型语言" class="headerlink" title="什么是动态类型语言"></a>什么是动态类型语言</h3><p>动态类型语言是指<strong>在运行期间才去做数据类型检查的语言</strong>，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。</p><h3 id="什么是静态类型语言"><a href="#什么是静态类型语言" class="headerlink" title="什么是静态类型语言"></a>什么是静态类型语言</h3><p>静态类型语言与动态类型语言刚好相反，它的<strong>数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型</strong>，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月4日 java 1</title>
      <link href="/exam//3c848182/"/>
      <url>/exam//3c848182/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3c848182/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/3c848182/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/3c848182/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/3c848182/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/3c848182/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/3c848182/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/3c848182/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/3c848182/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/3c848182/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/3c848182/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>在面向对象编程里，经常使用is-a来说明对象之间的继承关系，下列对象中不具备继承关系的是？（）</p><ul><li>A 手机与小米手机</li><li>B 企业家与雷军</li><li>C 编程语言与Java</li><li>D 中国与北京</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>is-a 的关系：<br>A：小米手机是一个手机，没毛病<br>B：雷军是一个企业家，没毛病<br>C：Java是一门编程语言，没毛病<br>D：北京是一个中国，不对</p><h3 id="use-a-has-a-is-a"><a href="#use-a-has-a-is-a" class="headerlink" title="use-a has-a is-a"></a>use-a has-a is-a</h3><p>类之间存在以下几种常见的关系</p><ul><li>use-a :是依赖关系</li><li>has-a :一般是组合关系</li><li>is-a : 一般是继承关系</li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面关于垃圾收集的描述哪个是错误的？</p><ul><li>A 使用垃圾收集的程序不需要明确释放对象</li><li>B 现代垃圾收集能够处理循环引用问题</li><li>C 垃圾收集能提高程序员效率</li><li>D 使用垃圾收集的语言没有内在泄漏问题</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露(Memory Leak)是指<strong>一个不再被使用的对象或者变量还在内存中占有存储空间</strong>。<br>在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。<br>在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。但是还是会存在内存泄露的问题。</p><h3 id="内存泄露主要有两种情况"><a href="#内存泄露主要有两种情况" class="headerlink" title="内存泄露主要有两种情况"></a>内存泄露主要有两种情况</h3><ol><li>在堆中申请的空间没有释放。</li><li>对象已不再被使用(注意：这里的不在被使用是指对程序来说没有用处，如数据库连接使用后没有关。但是还是存在着引用)，但是仍然在内存中保留着。GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。java语言中的内存泄露主要指第2种情况。</li></ol><h3 id="内存泄露的原因"><a href="#内存泄露的原因" class="headerlink" title="内存泄露的原因"></a>内存泄露的原因</h3><ol><li>静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。</li><li>各种连接，如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。</li><li>监听器，释放对象时往往没有相应的删除监听器，可能会导致内存泄露。</li></ol><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃这是结果描述。</p><p>内存泄露（Memory Leak）最终会导致内存溢出。</p><h3 id="Java的内存分配策略"><a href="#Java的内存分配策略" class="headerlink" title="Java的内存分配策略"></a>Java的内存分配策略</h3><p>Java 程序运行时的内存分配策略有三种,分别是<br><strong>静态分配</strong>,<strong>栈式分配</strong>,和<strong>堆式分配</strong>，对应的，<br>三种存储策略使用的内存空间主要分别是<strong>静态存储区</strong>（也称<strong>方法区</strong>）、<strong>栈区</strong>和<strong>堆区</strong>。</p><ul><li><strong>静态存储区（方法区）</strong>：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。</li><li><strong>栈区</strong>：当方法被执行时，方法体内的局部变量（其中包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li><li><strong>堆区</strong> ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存，也就是对象的实例（包括该对象其中的所有成员变量）。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。</li></ul><h3 id="Java中的内存管理"><a href="#Java中的内存管理" class="headerlink" title="Java中的内存管理"></a>Java中的内存管理</h3><p>Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。</p><h3 id="关于提高效率"><a href="#关于提高效率" class="headerlink" title="关于提高效率"></a>关于提高效率</h3><p>对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。</p><h3 id="关于消除循环引用"><a href="#关于消除循环引用" class="headerlink" title="关于消除循环引用"></a>关于消除循环引用</h3><p>Java使用<strong>有向图</strong>的方式进行内存管理，可以消除引用循环的问题。<br>例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。<br>另外一种常用的内存管理技术是使用<strong>计数器</strong>。具体如下：gc清理时的引用计数方式：<br>当引用连接至新对象时，引用计数+1；<br>当某个引用离开作用域或被设置为null时，引用计数-1，<br>GC发现这个计数为0时，就回收其占用的内存。这个开销会在引用程序的整个生命周期发生，并且不能处理循环引用的情况。所以这种方式只是用来说明GC的工作方式，而不会被任何一种Java虚拟机应用。例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。</p><h3 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h3><p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，</p><ul><li>首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；</li><li>其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</li></ul><p>有兴趣看引起内存泄漏的原因的可以参考这篇文章<a href="http://www.jb51.net/article/92311.htm" target="_blank" rel="noopener">http://www.jb51.net/article/92311.htm</a></p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面的输出结果是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    String str=<span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="string">"hello"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      System.out.println(<span class="string">"true"</span>);</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span>     &#123;</span><br><span class="line">      System.out.println(<span class="string">"false"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A true</li><li>B false</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>这种题烂大街</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>类方法中可以直接调用对象变量。（ ）</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="静态成员不能调用非静态成员"><a href="#静态成员不能调用非静态成员" class="headerlink" title="静态成员不能调用非静态成员"></a>静态成员不能调用非静态成员</h3><p>静态方法中不能调用对象的变量，因为静态方法在类加载时就初始化，对象变量需要在新建对象后才能使用</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下列java程序的输出结果为<em>__</em>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">    String str=<span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">char</span>[]ch=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Example ex=<span class="keyword">new</span> Example();</span><br><span class="line">        ex.change(ex.str,ex.ch);</span><br><span class="line">        System.out.print(ex.str+<span class="string">" and "</span>);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str,<span class="keyword">char</span> ch[])</span></span>&#123;</span><br><span class="line">        str=<span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>]=<span class="string">'c'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A hello and ab</li><li>B hello and cb</li><li>C hello and a</li><li>D test ok and ab</li><li>E test ok and cb</li><li>F test ok and c</li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>java中只有值传递，改变形参的地址不影响到实参</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>类Parent和Child定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">float</span>  <span class="title">aFun</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Child</span>  <span class="keyword">extends</span>  <span class="title">Parent</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将以下哪种方法插入行5是不合法的。（    ）</p><ul><li>A float aFun(float a, float b){ }</li><li>B public int aFun(int a, int b) { }</li><li>C public float aFun(float p, float q){ }</li><li>D private int aFun(int a, int b){ }</li></ul><p>正确答案: - A }<br>将以下哪种方法插入行5是不合法的。（    ）</p><ul><li>A float aFun(float a, float b){ }</li><li>B public int aFun(int a, int b) { }</li><li>C public float aFun(float p, float q){ }</li><li>D private int aFun(int a, int b){ }</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A.方法重写。子类方法不能缩小父类方法的访问权限，错误。<br>B.方法重载。参数列表不同，满足重载条件，正确。<br>C.方法重写。方法声明和父类相同，满足重写条件，正确。<br>D.方法重载。参数列表不同，满足重载条件，正确。</p><h3 id="方法重写-两同两小一大"><a href="#方法重写-两同两小一大" class="headerlink" title="方法重写 两同两小一大"></a>方法重写 两同两小一大</h3><p>方法重写要遵循“两同两小一大”规则，</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li><li>并且，覆盖方法和被覆盖方法要么都是类方法，要么都是实例方法，不能一个是类方法一个是实例方法。</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下面哪几个函数 public void example(){….} 的重载函数？（）</p><ul><li>A public void example(int m){…}</li><li>B public int example(){..}</li><li>C public void example2(){..}</li><li>D public int example(int m,float f){…}</li></ul><p>正确答案: AD</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="方法重载-两同一不同"><a href="#方法重载-两同一不同" class="headerlink" title="方法重载 两同一不同"></a>方法重载 两同一不同</h3><p>同一个类中，方法名相同，形参列表不同<br>方法重载只用关心两个点：<br>1.方法名相同<br>2.参数列表不同（个数不同、顺序不同、类型不同）</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>在Jdk1.7中，下述说法中抽象类与接口的区别与联系正确的有哪些？</p><ul><li>A 抽象类中可以有普通成员变量，接口中没有普通成员变量。</li><li>B 抽象类和接口中都可以包含静态成员常量。</li><li>C 一个类可以实现多个接口，但只能继承一个抽象类</li><li>D 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法。</li></ul><p>正确答案: ABCD</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">特点</th><th style="text-align:left">抽象类</th><th style="text-align:left">接口</th></tr></thead><tbody><tr><td style="text-align:left">构造方法</td><td style="text-align:left">有</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">普通成员变量</td><td style="text-align:left">有</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">普通方法</td><td style="text-align:left">可以有非抽象的</td><td style="text-align:left">必须是抽象的</td></tr><tr><td style="text-align:left">抽象方法的访问类型</td><td style="text-align:left">public、protected和默认</td><td style="text-align:left">只能是public的，默认public abstract</td></tr><tr><td style="text-align:left">静态方法</td><td style="text-align:left">可以有</td><td style="text-align:left">无</td></tr><tr><td style="text-align:left">静态成员变量</td><td style="text-align:left">有</td><td style="text-align:left">有 public static final的</td></tr><tr><td style="text-align:left">其他类</td><td style="text-align:left">只能继承一个抽象类</td><td style="text-align:left">可以实现多个接口</td></tr><tr><td style="text-align:left">应用场景</td><td style="text-align:left">模块之间通信契约</td><td style="text-align:left">代码重用</td></tr></tbody></table></div><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>jdk1.8中，下面有关java 抽象类和接口的区别，说法错误的是？</p><ul><li>A 抽象类可以有构造方法，接口中不能有构造方法</li><li>B 抽象类中可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象的普通方法</li><li>C 一个类可以实现多个接口，但只能继承一个抽象类</li><li>D 接口中可以有普通成员变量，抽象类中没有普通成员变量</li></ul><p>正确答案: BD</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>B 的后半句是错误的，java8在接口中允许有方法体，不过必须是静态方法；<br>接口中不能有普通成员变量，所以D错误</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>以下哪种JAVA得变量声明方式可以避免程序在多线程竞争情况下读到不正确的值(  )</p><ul><li>A volatile</li><li>B static volatile</li><li>C synchronized</li><li>D static</li></ul><p>正确答案: AB</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>synchronized不是修饰变量的 它修饰方法或代码块或对象</p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年11月2日 java 1</title>
      <link href="/exam//d4314bc1/"/>
      <url>/exam//d4314bc1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/d4314bc1/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/d4314bc1/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/d4314bc1/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/d4314bc1/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/d4314bc1/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/d4314bc1/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/d4314bc1/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/d4314bc1/#参考资料" class="header_1">参考资料</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>关于抽象类和接口叙述正确的是？ ( )</p><ul><li>A 抽象类和接口都能实例化的</li><li>B 抽象类不能实现接口</li><li>C 抽象类方法的访问权限默认都是public</li><li>D 接口方法的访问权限默认都是public</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类含有抽象方法那么这个类就是抽象类。<br>抽象类需要使用关键字abstract来声明。<br>抽象类中的抽象方法只需要声明，并不需要实现。<br>抽象类一定具有子类，并且子类必须覆写抽象类中的所有的抽象方法。<br>在使用abstract定义抽象方法时，抽象方法的权限不能为private，这是因为抽象方法必须被覆写，如果使用private来定义方法的权限，那么该方法无法被子类覆写，会出现错误</p><h3 id="普通通类和抽象类的区别"><a href="#普通通类和抽象类的区别" class="headerlink" title="普通通类和抽象类的区别"></a>普通通类和抽象类的区别</h3><p>实际上抽象类相比于普通类，只是在类定义的时候多定义了一个抽象方法，除了不能直接进行对象的实例化之外没有其它区别</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面属于java合法变量定义的是？</p><ul><li>A final</li><li>B 1var1</li><li>C _var2</li><li>D var3&amp;</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>标识符可以包括这4种字符：</p><ul><li>字母、数字，下划线、$、</li><li>开头不能是数字；</li><li>不能是关键字</li></ul><p>A.final 是关键字<br>B.不能以数字做首写<br>C.首写字母可以为下划线<br>D.符号只能使用美元符合下划线，不能使用&amp;</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>运行下面代码，输出的结果是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"class A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123; System.out.println(<span class="string">"I'm A class"</span>); &#125; </span><br><span class="line">    <span class="keyword">static</span> &#123; System.out.println(<span class="string">"class A static"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"class B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm B class"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">"class B static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> B(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">I&#39;m A class</span><br><span class="line">class A</span><br><span class="line">I&#39;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure><br>B<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">I&#39;m A class</span><br><span class="line">class A</span><br><span class="line">class B static</span><br><span class="line">I&#39;m B class</span><br><span class="line">class B</span><br></pre></td></tr></table></figure><br>C<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class B static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class</span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><br>D<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class A static</span><br><span class="line">class A</span><br><span class="line">I&#39;m A class</span><br><span class="line">class B static</span><br><span class="line">class B</span><br><span class="line">I&#39;m B class</span><br></pre></td></tr></table></figure><br>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>Java程序初始化顺序：</p><ol><li>父类的静态代码块</li><li>子类的静态代码块</li><li>父类的普通代码块</li><li>父类的构造方法</li><li>子类的普通代码块</li><li>子类的构造方法</li></ol><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>关于如下程序的描述哪个是正确的？（ ）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String a[])</span></span>&#123;</span><br><span class="line">        System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>A 编译将产生错误</li><li>B 编译时正确，但运行时将产生错误</li><li>C 正确，输出0</li><li>D 正确，输出 null</li></ul><p>正确答案: C</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="数组会自动初始化"><a href="#数组会自动初始化" class="headerlink" title="数组会自动初始化"></a>数组会自动初始化</h3><p><strong>数组</strong>无论是在定义为实例变量还是局部变量，若没有初始化，都<strong>会被自动初始化</strong></p><ul><li>Java中对于整型数组默认初始化0。</li><li>对字符数组初始化空格。</li><li>对对象数组初始化为null。</li></ul><h3 id="成员变量有默认值"><a href="#成员变量有默认值" class="headerlink" title="成员变量有默认值"></a>成员变量有默认值</h3><p>只有类的成员变量才有默认初始值。</p><h3 id="局部变量必须手动赋值"><a href="#局部变量必须手动赋值" class="headerlink" title="局部变量必须手动赋值"></a>局部变量必须手动赋值</h3><p>局部变量必须手动赋初值，否则编译报错</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>JSP分页代码中，哪个步骤次序是正确的？</p><ul><li>A 先取总记录数，得到总页数，最后显示本页的数据。</li><li>B 先取所有的记录，得到总页数，再取总记录数，最后显示本页的数据。</li><li>C 先取总页数，得到总记录数，再取所有的记录，最后显示本页的数据。</li><li>D 先取本页的数据，得到总页数，再取总记录数，最后显示所有的记录。</li></ul><p>正确答案: A</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>不足:JSP方面的我还不是很了解<br>先取总记录数，得到总页数，再取所有的记录，最后显示本页的数据</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下面关于程序编译说法正确的是（）</p><ul><li>A java语言是编译型语言，会把java程序编译成二进制机器指令直接运行</li><li>B java编译出来的目标文件与具体操作系统有关</li><li>C java在运行时才进行翻译指令</li><li>D java编译出来的目标文件，可以运行在任意jvm上</li></ul><p>正确答案: C</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A:java编译成的是字节码，再被各系统的jvm翻译成本系统可以识别的机器码，这就是java一次编程多平台应用的跨平台性<br>B:java源文件生成的是class文件，与系统无关<br>C:注意字节码和机器码不是一回事 java程序在运行时字节码才会被jvm翻译成机 器码，所以说java是解释性语言<br>D:注意jvm的版本，好比人穿裤子，一条裤子能被任何人穿上吗<br>低版本的jvm没有办法运行高版本的java代码</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下面说法正确的是？（）</p><ul><li>A 调用Thread的sleep()方法会释放锁，调用wait()方法不释放锁</li><li>B 一个线程调用yield方法，可以使具有相同优先级线程获得处理器</li><li>C 在Java中，高优先级的可运行的线程会抢占低优先级线程的资源</li><li>D java中，线程可以调用yield方法使比自己低优先级的线程运行</li></ul><p>正确答案: BC</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，<strong>使用yield()的目的是让具有<code>相同优先级</code>的线程之间能够适当的轮换执行</strong>。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://m.baidu.com/s?iscookie=1&amp;from=2001p&amp;wd=java%E6%8A%BD%E8%B1%A1%E7%B1%BB+%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">抽象类和接口的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年11月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月31日 加密和安全 1</title>
      <link href="/exam//9403006d/"/>
      <url>/exam//9403006d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/9403006d/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/9403006d/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/9403006d/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/9403006d/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/9403006d/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/9403006d/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下关于计算机病毒的说法，不正确的是（   ）。</p><ul><li>A 计算机病毒一般会寄生在其他程序中</li><li>B 计算机病毒一般会传染其他文件</li><li>C 计算机病毒一般会具有自愈性</li><li>D 计算机病毒一般会具有潜伏性</li></ul><p>正确答案: C</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>计算机病毒实质上是一种特殊的计算机程序，一般具有寄生性、破坏性、传染性、潜伏性和隐蔽性。故正确答案为C选项。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>计算机安全是指计算机资产安全，即（ ）</p><ul><li>A 计算机信息系统资源不受自然有害因素的威胁和危害</li><li>B 信息资源不受自然和人为有害因素的威胁和危害</li><li>C 计算机硬件系统不受人为有害因素的威胁和危害</li><li>D 计算机信息系统资源和信息资源不受自然和人为有害因素的威胁和危害</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>我国公安部计算机管理监察司的定义是计算机安全是指计算机资产安全，即<strong>计算机信息系统资源和信息资源不受自然和人为有害因素的威胁和危害</strong>。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>有一种木马程序，其感染机制与 U 盘病毒的传播机制完全一样，只是感染目标计算机后它会尽量隐藏自己的踪迹，它唯一的动作是扫描系统的文件，发现对其可能有用的敏感文件，就将其悄悄拷贝到 U 盘，一旦这个 U 盘插入到连接互联网的计算机，就会将这些敏感文件自动发送到互联网上指定的计算机中，从而达到窃取的目的。该木马叫做（ ）</p><ul><li>A 网游木马</li><li>B 网银木马</li><li>C 代理木马</li><li>D 摆渡木马</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h3 id="摆渡木马"><a href="#摆渡木马" class="headerlink" title="摆渡木马"></a>摆渡木马</h3><p>摆渡木马是一种特殊的木马，其感染机制与U盘病毒的传播机制完全一样，只是感染目标计算机后，它会尽量隐蔽自己的踪迹，不会出现普通U盘病毒感染后的症状，如更改盘符图标、破坏系统数据、在弹出菜单中添加选项等，它唯一的动作就是扫描系统中的文件数据，利用关键字匹配等手段将敏感文件悄悄写回U盘中，一旦这个U盘再插入到连接互联网的计算机上，就会将这些敏感文件自动发送到互联网上指定的计算机中。<br>摆渡木马是一种间谍人员定制的木马，隐蔽性、针对性很强，一般只感染特定的计算机，普通杀毒软件和木马查杀工具难以及时发现。故正确答案为D</p><h3 id="代理木马"><a href="#代理木马" class="headerlink" title="代理木马"></a>代理木马</h3><p>“代理木马”（Troj_Agent）具有自动下载木马病毒的功能，病毒可以根据病毒编者指定的网址下载木马病毒或其他恶意软件，还可以通过网络和移动存储介质传播。</p><h3 id="网络木马"><a href="#网络木马" class="headerlink" title="网络木马"></a>网络木马</h3><p>网络木马通常采用记录用户键盘输入、Hook游戏进程API函数等方法获取用户的密码和帐号。窃取的信息一般通过发送电子邮件或向远程脚本程序提交的方式发送给木马作者。</p><h3 id="网银木马"><a href="#网银木马" class="headerlink" title="网银木马"></a>网银木马</h3><p>网银木马是针对网上交易系统编写的木马病毒，其目的是盗取用户的卡号、密码，甚至安全证书。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列攻击方式中，哪种不是针对客户端的？</p><ul><li>A cross site script（跨站点脚本）</li><li>B cross site request（跨站点请求）</li><li>C ActiveX buffer overflow（控件缓冲溢出）</li><li>D sql injection（sql注入）</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>SQ LInjection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。所以SQL injection不是针对客户端的。<strong>SQL注入是针对服务器数据库的</strong>。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下说法不正确的是()</p><ul><li>A Hash算法主要被用来做数字签名、数据校验</li><li>B SHA-224、SHA-256、SHA-384和SHA-512并称为SHA-2</li><li>C 已知明文攻击对 AES算法无效</li><li>D 非对称加密算法，就是加密、解密的密钥分为两组，并且可以互相反推</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>非对称加密算法不可逆，不能反推<br>SHA-2可分为<strong>六</strong>个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>流量劫持是网络安全中常见的安全威胁，下列哪些情况可能会造成流量劫持?()</p><ul><li>A MAC地址欺骗</li><li>B DNS劫持</li><li>C 伪造的DHCP服务器</li><li>D 使用https协议</li></ul><p>正确答案: ABC</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>流量劫持：是利用各种恶意软件修改浏览器、锁定主页或不停弹出新窗口，强制用户访问某些网站，从而<strong>造成用户流量损失的情形</strong>。是一种古老的攻击方式，比如广告弹窗等。<br>常见的有</p><ul><li>Hub嗅探、</li><li>MAC欺骗、</li><li>MAC冲刷</li><li>ARP攻击、</li><li>DHCP钓鱼、</li><li>DNS劫持、</li><li>CDN入侵、</li><li>路由器弱口令、</li><li>路由器CSRF、</li><li>PPPoE钓鱼、</li><li>蜜罐代理、</li><li>Wifi弱口令、</li><li>伪热点、</li><li>强制断线、</li><li>WlAN基站钓鱼。</li></ul><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/9403006d/">2019年10月31日 加密和安全 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 加密和安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月31日 操作系统 1</title>
      <link href="/exam//c3120b4d/"/>
      <url>/exam//c3120b4d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c3120b4d/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/c3120b4d/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/c3120b4d/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/c3120b4d/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/c3120b4d/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/c3120b4d/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/c3120b4d/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/c3120b4d/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/c3120b4d/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/c3120b4d/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>虚拟存储器是利用操作系统产生的一个假想的特大存储器，是逻辑上扩充了内存容量，而物理内存的容量并未增加。</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>根据程序执行的互斥性和局部性两个特点，我们允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。好像计算机系统具有一个容量很大的主存储器，称为“虚拟存储器”。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>一个进程被唤醒意味着（）</p><ul><li>A 该进程一定马上占有</li><li>B 它的优先权变得最大</li><li>C 其PCB移至等待队列队首</li><li>D 进程变为就绪状态</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>进程和程序的最根本区别在于（ ）。</p><ul><li>A 对资源的占有类型和数量</li><li>B 进程是动态的，而程序是静态的</li><li>C 看它们是否能够并发地在处理机上运行</li><li>D 进程规模较小，程序规模较大</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>程序是静态的，进程是动态的，程序相当于一个乐谱，进程相当于一次演奏，程序可以查看，进程不能查看代码，进程可以被创建 运行 撤销</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>对进程和线程的描述，以下正确的是？</p><ul><li>A 父进程里的所有线程共享相同的地址空间，父进程的所有子进程共享相同的地址空间</li><li>B 改变进程里面主线程的状态会影响其他线程的行为，改变父进程的状态不会影响其他子进程</li><li>C 多线程会引起死锁，而多进程则不会</li><li>D 以上都不对</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>A错，进程拥有独立的地址空间；</li><li>B错，主线程和子线程是并行关系的时候，并没有依赖关系。父进程和子进程中，子进程是父进程的一个副本，创建子进程后，子进程会有自己的空间，然后把父进程的数据拷贝到子进程的空间里。运行时，谁先运行是不确定的，这由系统决定；</li><li>C错，多线程和多进程都会引起死锁，一般说的死锁指的是进程间的死锁。</li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>文件系统的主要目的是（  ）</p><ul><li>A 实现对文件的按名存取</li><li>B 实现虚拟存储</li><li>C 提高外存的读取速度</li><li>D 用于存储系统文件</li></ul><p>正确答案: A</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>文件系统是操作系统下用来对文件的命名以及逻辑操作的一些系统。在计算机中，文件系统（file system）是命名文件及放置文件的逻辑存储和恢复的系统。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>在计数器定时查询方式下，若每次计数都从 0 开始，则 （）</p><ul><li>A 设备号小的设备优先级高</li><li>B 设备号大的设备优先级高</li><li>C 每个设备的优先级均等</li><li>D 每个设备的优先级随机变化</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>两个进程合作完成一个任务。在并发执行中，一个进程要等待其合作伙伴发来消息，或者建立某个条件后再向前执行，这种制约性合作关系被称为进程的（ ）。</p><ul><li>A 互斥</li><li>B 同步</li><li>C 调度</li><li>D 伙伴</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>同步：进程按照一定规则顺序执行，互斥是同步特例</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>分层式 OS 结构是把 OS 的功能模块划分为若干层，每层之间的模块只能单向调用，这样的说法正确吗？</p><ul><li>A 正确</li><li>B 不正确</li></ul><p>正确答案: A</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>所谓的层次结构，就是把操作系统所有的功能模块按照功能调用次序分别排成若干层，<strong>各层之间的模块只有单向调用关系</strong>(例如，只允许上层或外层模块调用下层或内层模块)。<br>分层的优点是：<br> (1)把功能实现的无序性改成有序性，可显著提高设计的准确性。<br> (2)把模块问的复杂依赖关系改为简单的单向依赖关系，即高层软件依赖于低层软件。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>在操作系统的层次结构中，各层之间是（ ）</p><ul><li>A 互不相关</li><li>B 内外层相互依赖</li><li>C 内层依赖外层</li><li>D 外层依赖内层</li></ul><p>正确答案: D</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>linux 的索引节点中不包含的内容是（ ）</p><ul><li>A 文件名</li><li>B 文件物理地址</li><li>C 文件存取权限</li><li>D 文件创建时间</li></ul><p>正确答案: A</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>inode包含文件的元信息，具体来说有以下内容：</p><ul><li>文件的字节数</li><li>文件拥有者的User ID</li><li>文件的Group ID</li><li>文件的读、写、执行权限</li><li>文件的时间戳，共有三个：<ul><li>ctime指inode上一次变动的时间，</li><li>mtime指文件内容上一次变动的时间，</li><li>atime指文件上一次打开的时间。</li></ul></li><li>链接数，即有多少文件名指向这个inode</li><li>文件数据block的位置<br>至于为什么没有文件名，<strong>是因为由于inode号码与文件名分离</strong>，这种机制导致了一些Unix/Linux系统特有的现象。</li></ul><ol><li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li><li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li><li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li></ol><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/c3120b4d/">2019年10月31日 操作系统 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月31日 智力题1</title>
      <link href="/exam//b97b7079/"/>
      <url>/exam//b97b7079/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/b97b7079/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/b97b7079/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/b97b7079/#考点3-2-1-2-3-1-2" class="header_1">考点3 2,1,2/3,1/2,()</a>&nbsp;<br><a href="/exam/b97b7079/#考点4" class="header_1">考点4</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>水果店店长早晨通知店员，苹果应减10%,中午发现该减价是香蕉而非苹果，便又通知了香蕉减价10%,苹果提价10%,那么苹果是否恢复了原价?()</p><ul><li>A 不能确定</li><li>B 否</li><li>C 是</li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>原价x元，降价后y=x(1-10%)=0.9x，升价后z=y(1+10%)=1.1y=0.99x。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>如果6个苹果和4根香蕉的价钱是4.6元，7个苹果和9根香蕉的价钱是7.1元，那么一个苹果的价钱是（）元？</p><ul><li>A 0.3</li><li>B 0.4</li><li>C 0.5</li><li>D 0.6</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>假设苹果的价格为a,香蕉的价格为b，通过解方程得出苹果的价格为0.5<br>6a+4b=4.6<br>7a+9b=7.1</p><h1 id="考点3-2-1-2-3-1-2"><a href="#考点3-2-1-2-3-1-2" class="headerlink" title="考点3 2,1,2/3,1/2,()"></a>考点3 2,1,2/3,1/2,()</h1><p>2,1,2/3,1/2,()</p><ul><li>A 0.75</li><li>B 0.25</li><li>C 0.4</li><li>D 0.83</li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>2/1, 2/2, 2/3, 2/4, 2/5…</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>凯物喜欢 225，但不喜欢 224，喜欢 900，但不喜欢 800，喜欢 121，但不喜欢 120，那么请你猜一猜，他会喜欢下面哪个数字?</p><ul><li>A 401</li><li>B 400</li><li>C 501</li><li>D 500</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>B，225是25的平方，900是30的平分，121是11的平方，同理，400是20的平方，所以是B</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/b97b7079/">2019年10月31日 智力题1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 智力题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月31日 计算机网络 1</title>
      <link href="/exam//3fcd8c5a/"/>
      <url>/exam//3fcd8c5a/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/3fcd8c5a/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/3fcd8c5a/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>ARP 的功能是将IP地址解析为MAC地址。</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>ARP 协议（Address Resolution Protocol），或称地址解析协议。在以太网链路上仅仅知道某台主机的IP address，并不能立即将封包传送过去，必须先查明该主机的实体地址(Physical address/MAC address)才能真正发送出去，而ARP协议的功用就是在于将IP address转换成实体地址，查询目标设备的MAC地址，以保证通信的顺利进行。</p><p>并且只能在区域网路内使用，解析网路装置的MAC位址，ARP是TCP/IP设计者利用乙太网的广播性质，设计出来的位址解释协定；它的主要特性和优点是它的位址对应关系是动态的，它以查询的方式来获得IP位址和实体位</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>OSI七层模型中,物理层，数据链路层，网络层，传输层的单位是什么（）</p><ul><li>A 帧frame，包packet，段segment，比特bit</li><li>B 比特bit，帧frame，包packet，段segment</li><li>C 帧frame，比特bit，段segment，包packet</li><li>D 比特bit，包packet，帧frame，段segment</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>比特成帧，帧成报文，报文成包，包成段</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>The lower layers of the OSI model are in correct order ( )</p><ul><li>A physical,system,network,logical</li><li>B physical,logical,network,system</li><li>C physical,transport,network,datalink</li><li>D physical,datalink,network,transport</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>从下往上是：物理层，数据链路层，网络层，传输层</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>在 OSI 参考模型的物理层、数据链路层、网络层传送的数据单位分别为 （）。</p><ul><li>A 比特、帧、分组</li><li>B 比特、分组、帧</li><li>C 帧、分组、比特</li><li>D 分组、比特、帧</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>承载信息量的基本信号单位是 （） 。</p><ul><li>A 码元</li><li>B 比特</li><li>C 数据传输速率</li><li>D 误码率</li></ul><p>正确答案: A</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>帧中继网是一种（ ）。</p><ul><li>A 广域网</li><li>B 局域网</li><li>C ATM网</li><li>D 以太网</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>几种常用的广域网：<br>公用电话交换网（ P S T N）、<br>分组交换网（X . 2 5）、<br>数字数据网（ D D N）、<br>帧中继（ F R）、<br>交换式多兆位数据服务（ S M D S）和<br>异步传输模式（AT M）。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>在TCP/IP模型中，数据从应用层到网际接口层所经历的传输格式分别是(    )。</p><ul><li>A 报文或字节流—&gt;IP数据报—&gt;网络帧—&gt;传输协议分组</li><li>B 报文或字节流—&gt;传输协议分组—&gt;IP数据报—&gt;网络帧</li><li>C 传输协议分组—&gt;IP数据报—&gt;网络帧—&gt;报文或字节流</li><li>D IP数据报—&gt;报文或字节流—&gt;网络帧—&gt;传输协议分组</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>OSI:<br>物理层——比特流<br>数据链路层——帧<br>网络层——包<br>传输层——段/消息<br>表示层——字符或字<br>应用层——程序<br>TCP/IP为四层模型<br>应用层：报文<br>运输层：传输层协议<br>网际层：数据报<br>网络接口层：网络帧</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下列地址中哪些是私有地址</p><ul><li>A 172.32.0.1</li><li>B 172.0.0.1</li><li>C 172.16.0.255</li><li>D 172.15.255.255</li></ul><p>正确答案: C</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>私有地址如下：<br>A类：10.0.0.0到10.255.255.255<br>B类：172.16.0.0到172.31.255.255<br>C类：192.168.0.0到192.168.255.255</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>在某办公室内铺设一个小型局域网,总共有4台PC机需要通过一台集线器连接起来。采用的线缆类型为5类双绞线。则理论上任意两台PC机的最大间隔距离是()</p><ul><li>A 400米</li><li>B 100米</li><li>C 200米</li><li>D 500米</li></ul><p>正确答案: B</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>5类双绞线的最大传输距离为100，意思是两个节点之间的总距离应该在100以内，否则传输就会造成损耗。所以集线器节点-集线器-节点距离应为100米，集线器只是将线缆汇集的一个中心。</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>以下请求是一个订单提交的请求，请观察该请求包，说出你认为可能存在的安全风险点（）：<br>POST <a href="http://test.mi.cn/insert.html" target="_blank" rel="noopener">http://test.mi.cn/insert.html</a> HTTP/1.1<br>Host: test.mi.com<br>Referer: <a href="http://test.mi.cn/index.php?data=58" target="_blank" rel="noopener">http://test.mi.cn/index.php?data=58</a><br>Cookie: uid=1504174654; </p><p>addressid=1&amp;productid=123&amp;num=1&amp;price=120</p><ul><li>A CSRF</li><li>B 订单金额篡改</li><li>C 越权操作</li><li>D SQL 注入</li></ul><p>正确答案: ABCD</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>看不到这题什么意思</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/3fcd8c5a/">2019年10月31日 计算机网络 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月30日 java 5</title>
      <link href="/exam//f85a02e/"/>
      <url>/exam//f85a02e/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/f85a02e/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/f85a02e/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/f85a02e/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/f85a02e/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/f85a02e/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/f85a02e/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/f85a02e/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/f85a02e/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/f85a02e/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p><strong><em>_</em></strong>意味着一个操作在不同的类中可以有不同的实现方式。</p><ul><li>A 多态性</li><li>B 多继承</li><li>C 类的组合</li><li>D 类的复用</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>类的复用有两种方式：组成(has-a)和继承(is-a)<br>1）组成就是在新的类中直接创建旧类的对象，这里我们复用的只是代码的功能而不是它的形式。<br>2）继承是在原有的类的基础上建立一个新类，新类具有旧类的形式，但也加入了一些新的特性。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>指一个新的类继承原有类的基本特性，并增加了新的特性。（Java不允许多继承，而C++可以）</p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。<br>1）多态存在的三个必要条件<br>①要有继承 ②要有重写 ③父类引用指向子类对象（向上转型）<br>2）实现多态性的三种形式</p><ul><li>①方法的重载 </li><li>②通过继承机制而产生方法覆盖</li><li>③通过接口实现方法覆盖<br>3）多态的分类<br>多态分为编译时多态和运行时多态。其中<br>编译</li><li>时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。</li><li>而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们平常所说的多态性。</li></ul><p>多态的本质是：一个程序中同名的不同方法。在面向对象的程序设计中，多态主要有以下三种方式来实现。</p><ul><li>通过子类对父类方法的覆盖来实现多态。</li><li>通过一个类中方法的重载来实现多态。</li><li><p>通过将子类的对象作为父类的对象实现多态。</p><p>方法中的成员变量不具备多态性，因为变量不会被重写，在编译时有两块存储堆内存，并取决于编译时所声明变量类型。和运行时对象的变量不是一块内存区域。简洁得来说，<strong>不能重写就没法表现出多态。</strong></p></li></ul><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>以下关于java封装的描述中，正确的是：</p><ul><li>A 封装的主要作用在于对外隐藏内部实现细节，增强程序的安全性</li><li>B 封装的意义不大，因此在编码中尽量不要使用</li><li>C 如果子类继承父类，对于父类中进行封装的方法，子类仍然可以直接调用</li><li>D 只能对一个类中的方法进行封装，不能对属性进行封装</li></ul><p>正确答案: A</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h3 id="什么是封装"><a href="#什么是封装" class="headerlink" title="什么是封装"></a>什么是封装</h3><p><strong>封装就是将属性私有化，提供公有的方法访问私有属性</strong>。所以CD错误。</p><h3 id="如何实现封装"><a href="#如何实现封装" class="headerlink" title="如何实现封装"></a>如何实现封装</h3><p>做法就是：<br>修改属性的可见性来限制对属性的访问，<br>并为每个属性创建一对取值（getter）方法和赋值（setter）方法，用于对这些属性的访问。<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="为什么需要封装"><a href="#为什么需要封装" class="headerlink" title="为什么需要封装"></a>为什么需要封装</h3><p>通过封装，可以实现对属性的数据访问限制，同时增加了程序的可维护性。<br>由于取值方法和赋值方法隐藏了实现的变更，因此并不会影响读取或修改该属性的类，避免了大规模的修改，程序的可维护性增强</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>java 语言使用的字符码集是</p><ul><li>A ASCII</li><li>B BCD</li><li>C DCB</li><li>D Unicode</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>如果int x=20, y=5，则语句System.out.println(x+y +””+(x+y)+y);  的输出结果是（）</p><ul><li>A 2530</li><li>B 55</li><li>C 2052055</li><li>D 25255</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>1）不论有什么运算，<strong>小括号的优先级都是最高的</strong>，先计算小括号中的运算，得到x+y +””+25+y<br>2）任何字符与字符串相加都是字符串，但是是有顺序的，字符串前面的按原来的格式相加，字符串后面的都按字符串相加，得到25+””+25+5<br>3）上面的结果按字符串相加得到25255</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下哪一项正则能正确的匹配网址: <a href="http://www.bilibili.com/video/av21061574" target="_blank" rel="noopener">http://www.bilibili.com/video/av21061574</a> （）</p><ul><li>A <code>/^(https?:\/\/)?([a-zA-Z\d]+).bilibili.com\/?video\/av(\D{1,8})\/?$/</code></li><li>B <code>/^(http:\/\/)?(\w+)\.bilibili\.com\/?video\/av(\d{1,8})\/?$/</code></li><li>C <code>/^(https?:\/\/)?(\w+)\.bilibili\.com\/?\w*$/</code></li><li>D <code>/^(http:\/\/)?([a-zA-Z\d]+).bilibili.com\/?video\/av\w*\/+$/</code></li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列代码执行结果为（）<br>public static void main(String args[])throws InterruptedException{<br>            Thread t=new Thread(new Runnable() {<br>                public void run() {<br>                    try {<br>                        Thread.sleep(2000);<br>                    } catch (InterruptedException e) {<br>                        throw new RuntimeException(e);<br>                    }<br>                    System.out.print(“2”);<br>                }<br>            });<br>            t.start();</p><pre><code>        t.join();        System.out.print(&quot;1&quot;);    }</code></pre><ul><li>A 21</li><li>B 12</li><li>C 可能为12，也可能为21</li><li>D 以上答案都不对</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</p><p>join()可以理解为<strong>先执行</strong>，<code>t.join();</code>可以理解为先执行t线程。则main线程等待</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于继承的说法正确的是（）。</p><ul><li>A 子类将继承父类所有的数据域和方法。</li><li>B 子类将继承父类的其可见的数据域和方法。</li><li>C 子类只继承父类public方法和数据域</li><li>D 子类只继承父类的方法，而不继承数据域</li></ul><p>正确答案: A</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。<strong>可以继承，只是无法访问到而已</strong>。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>ArrayLists和LinkedList的区别，下述说法正确的有？</p><ul><li>A ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>B 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>C 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</li><li>D ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。</li></ul><p>正确答案: ABCD</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段，以下过程属于初始化阶段是（）。</p><ul><li>A 加载Servlet类及.class对应的数据</li><li>B 创建servletRequest和servletResponse对象</li><li>C 创建ServletConfig对象</li><li>D 创建Servlet对象</li></ul><p>正确答案: ACD</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>Servlet的生命周期一般可以用三个方法来表示：</p><ul><li>init()：仅执行一次，负责在装载Servlet时初始化Servlet对象</li><li>service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。</li><li>destory()：在停止并且卸载Servlet时执行，负责释放资源</li><li>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。所以选ACD。B是在调用service方法时才构造的</li></ul><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/f85a02e/">2019年10月30日 java 5</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月30日 java 4</title>
      <link href="/exam//788290b8/"/>
      <url>/exam//788290b8/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/788290b8/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/788290b8/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/788290b8/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/788290b8/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/788290b8/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/788290b8/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/788290b8/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/788290b8/#考点8" class="header_1">考点8</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下面的方法，当输入为2的时候返回值是多少？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        result = result + i;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        result = result + i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        result = result + i * <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 0</li><li>B 2</li><li>C 4</li><li>D 10</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>没有<code>break</code>，发生<code>case</code>穿透现象，程序会继续向下执行，直到遇到<code>break</code>或者结束<code>switch</code>语句的大括号为止。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面那些情况可以终止当前线程的运行？</p><ul><li>A 当一个优先级高的线程进入就绪状态时</li><li>B 抛出一个异常时</li><li>C 当该线程调用sleep()方法时</li><li>D 当创建一个新线程时</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li>当一个优先级高的线程进入就绪状态时，它只是有较高的概率能够抢到<code>CPU</code>的执行权，不是一定就能抢到执行权，所以A错</li><li>抛出一个例外时，该线程就终止了，所以B正确</li><li>当前线程调用<code>sleep()</code>方法或者<code>wait()</code>方法时，只是暂时停止了该线程的运行，不是终止线程，注意题目说的是“终止”，就是完全停止,所以C错误</li><li>当创建一个新的线程时，该线程也加入到了抢占<code>CPU</code>执行权的队伍中，但是是否能抢到，并不清楚，和A的思想一样，所以D错误</li></ul><p>线程结束的三个原因：</p><ul><li><code>run</code>方法执行完成，线程正常结束</li><li>线程抛出一个未捕获的<code>Exception</code>或者<code>Error</code></li><li>直接调用该线程的<code>Stop</code>方法结束线程（不建议使用，容易导致死锁）</li></ul><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列关于<code>java</code> 中的 <code>wait()</code>方法和 <code>sleep()</code>方法的区别描述错误的是？</p><ul><li>A <code>wait()</code>方法属于<code>Object</code>类，<code>sleep()</code>属于<code>Thread</code>类</li><li>B 调用<code>wait()</code>方法的时候，线程会放弃对象锁</li><li>C 调用<code>sleep()</code>方法的过程中，线程不会释放对象锁</li><li>D <code>sleep()</code>方法导致了程序暂停执行指定的时间，让出<code>cpu</code>给其他线程</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>sleep和wait的区别有：</p><ol><li>这两个方法来自不同的类分别是<code>Thread</code>和<code>Object</code></li><li>最主要是<strong><code>sleep</code>方法没有释放锁，而<code>wait</code>方法释放了锁</strong>，使得敏感词线程可以使用同步控制块或者方法。</li><li><strong><code>wait</code>，<code>notify</code>和<code>notifyAll</code>只能在同步控制方法或者同步控制块里面使用</strong>，而<code>sleep</code>可以在任何地方使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x)&#123;</span><br><span class="line">   x.notify()</span><br><span class="line">  <span class="comment">//或者wait()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>sleep</code>必须捕获异常，而<code>wait</code>，<code>notify</code>和<code>notifyAll</code>不需要捕获异常</li></ol><p>D是<strong>线程</strong>暂停执行指定时间而不是<strong>程序</strong>暂停执行指定的时间。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>执行以下程序后的输出结果是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuffer a = <span class="keyword">new</span> StringBuffer(<span class="string">"A"</span>); </span><br><span class="line">        StringBuffer b = <span class="keyword">new</span> StringBuffer(<span class="string">"B"</span>); </span><br><span class="line">        operator(a, b); </span><br><span class="line">        System.out.println(a + <span class="string">","</span> + b); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">(StringBuffer x, StringBuffer y)</span> </span>&#123; </span><br><span class="line">        x.append(y); y = x; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A A,A</li><li>B A,B</li><li>C B,B</li><li>D AB,B</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>关于<code>C++/JAVA</code>类中<code>static</code> 成员和对象成员的说法正确的是？</p><ul><li>A <code>static</code> 成员变量在对象构造时生成</li><li>B <code>static</code> 成员函数在对象成员函数中无法调用</li><li>C 虚成员函数不可能是<code>static</code> 成员函数</li><li>D <code>static</code> 成员函数不能访问<code>static</code> 成员变量</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p><code>C++</code>中<strong>虚函数</strong>类似<code>java</code>语言中的<strong>抽象方法</strong>，抽象方法中不能用<code>private</code>，<code>static</code>， <code>synchronized</code>，<code>native</code>等修饰词修饰。</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>给出下面的代码段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w, x, y ,z;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x=a; y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// assignment x=a, y=b</span></span><br><span class="line">        w=d;z=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在代码说明// assignment x=a, y=b处写入如下哪几个代码是正确的？（） </p><ul><li>A <code>Base(a,b);</code></li><li>B <code>x=a, y=b;</code></li><li>C <code>x=a; y=b;</code></li><li>D <code>this(a,b);</code></li></ul><p>正确答案: CD</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列哪些操作会使线程释放锁资源？</p><ul><li>A <code>sleep()</code></li><li>B <code>wait()</code></li><li>C <code>join()</code></li><li>D <code>yield()</code></li></ul><p>正确答案: BC</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>往OuterClass类的代码段中插入内部类声明, 哪一个是错误的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> f=<span class="number">1.0f</span>;</span><br><span class="line">    <span class="comment">//插入代码到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A class InnerClass{public static float func(){return f;} }</li><li>B abstract class InnerClass{ public abstract float func(){} }</li><li>C static class InnerClass{ protected static float func(){return f;} }</li><li>D public class InnerClass{ static float func(){return f;} }</li></ul><p>正确答案: ABCD</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>主要考核了这几个知识点：<br>1.<strong>静态内部类才可以声明静态方法</strong>,所以A错，D错<br>2.静态方法不可以使用非静态变量，所以C错误<br>3.抽象方法不可以有函数体，所以B错误</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/788290b8/">2019年10月30日 java 4</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月30日 java 1</title>
      <link href="/exam//8e86437/"/>
      <url>/exam//8e86437/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'8e86437'/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/'8e86437'/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/'8e86437'/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/'8e86437'/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/'8e86437'/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/'8e86437'/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/'8e86437'/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/'8e86437'/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/'8e86437'/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/'8e86437'/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>java中，用（ ）关键字定义常量？</p><ul><li>A final</li><li>B #define</li><li>C float</li><li>D const</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>final关键字可用于修饰类、变量和方法。final修饰变量时，表示该变量一旦获得了初始值就不可被改变，final既可以修饰成员变量也可以修饰局部变量、形参。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面关于hibernate核心接口说明错误的是？</p><ul><li>A Configuration 接口：配置Hibernate，根据其启动hibernate，创建SessionFactory 对象</li><li>B SessionFactory 接口：负责保存、更新、删除、加载和查询对象，是线程不安全的，避免多个线程共享同一个session，是轻量级、一级缓存</li><li>C Query 和Criteria 接口：执行数据库的查询</li><li>D Transaction 接口：管理事务</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>B选项中应该是Session接口而不是SessionFactory接口\<br>1，Configuration接口：配置Hibernate，根据其启动Hibernate，创建SessionFactory对象；<br>2，SessionFactory接口：初始化Hibernate，充当数据存储源的代理，创建session对象，SessionFactory是<br>线程安全的，意味着它的同一个实例可以被应用的多个线程共享，是重量级二级缓存；<br>3，session接口：负责保存、更新、删除、加载和查询对象，是一个非线程安全的，避免多个线程共享一个session，是轻量级，一级缓存。<br>4，Transaction接口：管理事务。可以对事务进行提交和回滚；<br>5，Query和Criteria接口：执行数据库的查询。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>执行如下代码段后，变量s1引用的字符串值是(    )。<br>String s1 = “ABCD”;<br>String s2 = “1234”;<br>System.out.println(s1 + s2);</p><ul><li>A ABCD</li><li>B 1234</li><li>C ABCD1234</li><li>D 1234ABCD</li></ul><p>正确答案: A</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>有以下类定义：<br>abstract class Animal{<br>    abstract void say();<br>}<br>public class Cat extends Animal{<br>    public Cat(){<br>        System.out.printf(“I am a cat”);<br>    }<br>    public static void main(String[] args) {<br>        Cat cat=new Cat();<br>    }<br>}<br>运行后：</p><ul><li>A I am a cat</li><li>B Animal能编译，Cat不能编译</li><li>C Animal不能编译，Cat能编译</li><li>D 编译能通过，但是没有输出结果</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>包含抽象方法的类称为抽象类，但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。注意， <strong>抽象类和普通类</strong> 的主要有三点区别：<br>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。<br>2）抽象类不能用来创建对象；<br>3） <strong>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法</strong> 。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。<br>在其他方面，抽象类和普通的类并没有区别。</p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>以下代码执行的结果显示是多少（）？<br>public class Demo{<br>    public static void main(String[] args){<br>        System.out.print(getNumber(0));<br>        System.out.print(getNumber(1));<br>        System.out.print(getNumber(2));<br>        System.out.print(getNumber(4));<br>    }</p><pre><code>public static int getNumber(int num){    try{        int result = 2 / num;        return result;    }catch (Exception exception){        return 0;    }finally{        if(num == 0){            return -1;        }        if(num == 1){            return 1;        }    }}</code></pre><p>}</p><ul><li>A 0110</li><li>B -1110</li><li>C 0211</li><li>D -1211</li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>finally中return语句会覆盖try-catch中的return语句</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>以下代码对其执行后，NumberList里的元素依次为：<br>List<Integer> NumberList = new ArrayList<Integer>();<br>NumberList.add(2);<br>NumberList.add(4);<br>NumberList.add(1);<br>NumberList.add(3);<br>NumberList.add(5);<br>for(int i =0;i&lt;NumberList.size();++i){<br>    int v = NumberList.get(i);<br>    if(v%2==0){<br>        NumberList.remove(v);<br>    }<br>}<br>System.out.println(NumberList);</p><ul><li>A 2,4,1,3,5</li><li>B 2,1,3,5</li><li>C 4,1,3,5</li><li>D 会出现越界情况</li></ul><p>正确答案: D</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>1.ArrayList删除元素后，剩余元素会依次向前移动，因此下标一直在变，size()也会减小；<br>2.这里的remove()方法调用的是remove(int index)，而不是remove(Object o)，因此删除的是index索引处的元素；<br>对于List而言，想要移除元素，要不然就用迭代器。要不然就从后往前删除。<br>万万不可从前往后删，会出现角标越界。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>String str1 = “abc”，“abc”分配在内存哪个区域？</p><ul><li>A 堆</li><li>B 栈</li><li>C 字符串常量区</li><li>D 寄存器</li></ul><p>正确答案: C</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>答案：C<br>用new创建的对象在堆区<br>函数中的临时变量在栈去<br>java中的字符串在字符串常量区</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>当编译并运行下面程序时会发生什么结果（）<br>public class Bground extends Thread{<br>    public static void main(String argv[]){<br>        Bground b = new Bground();<br>        b.run();<br>    }<br>    public void start(){<br>        for(int i=0;i&lt;10;i++){<br>            System.out.println(“Value of i = “+i);<br>        }<br>    }<br>}</p><ul><li>A 编译错误，指明run方法没有定义</li><li>B 运行错误，只鞥呢run方法没有定义</li><li>C 编译通过并输出0到9</li><li>D 编译通过，但无输出</li></ul><p>正确答案: D</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>对于线程而言，start是让线程从new变成runnable。run方法才是执行体的入口。<br>但是在Thread中，run方法是个空方法，没有具体实现。<br>Bground继承了Thread，但是没有重写run方法，那么调用run方法肯定是无输出。<br>首先继承Thread，然后调用run方法，bgroud并没有重写run方法，那么就是调用父类Thread的run方法。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>下面选项中,哪些是interface中合法方法定义?()</p><ul><li>A public void main(String [] args);</li><li>B private int getSum();</li><li>C boolean setFlag(Boolean [] test);</li><li>D public float get(int x);</li></ul><p>正确答案: ACD</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>在jdk8之前，interface之中可以定义变量和方法，变量必须是public、static、final的，方法必须是public、abstract的。<br>JDK8及以后，允许我们在接口中定义static方法和default方法。<br>静态方法，只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用。default方法，只能通过接口实现类的对象来调用。<br>当然如果接口中的默认方法不能满足某个实现类需要，那么实现类可以覆盖默认方法。<br>JDK 1.9时，接口中的方法可以是private的</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面哪些属于JSP内置对象及方法？</p><ul><li>A request</li><li>B out</li><li>C application</li><li>D config</li></ul><p>正确答案: ABCD</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>JSP内置对象有：<br>1.request对象<br>     客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是HttpServletRequest类的实例。<br>2.response对象<br>     response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>3.session对象<br>     session对象指的是客户端与服务器的一次会话，从客户连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例.<br>4.out对象<br>     out对象是JspWriter类的实例,是向客户端输出内容常用的对象<br>5.page对象<br>     page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例<br>6.application对象<br>     application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。<br>7.exception对象<br>   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象<br>8.pageContext对象<br>pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本 类名也叫pageContext。<br>9.config对象<br>config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数（通过属性名和属性值构成）以及服务器的有关信息（通过传递一个ServletContext对象）</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/8e86437/">2019年10月30日 java 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月29日 java 4</title>
      <link href="/exam//986ae252/"/>
      <url>/exam//986ae252/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/986ae252/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/986ae252/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/986ae252/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/986ae252/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/986ae252/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/986ae252/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/986ae252/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/986ae252/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/986ae252/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>在Java中，main()方法的返回值的类型是：</p><ul><li>A public</li><li>B static</li><li>C void</li><li>D String</li></ul><p>正确答案: C</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>main方法的格式讲解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><br>public:公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大。<br>static:静态的，不需要创建对象，通过类名就可以。方便jvm的调用。<br>void:方法的返回值是返回给调用者，而main方法是被jvm调用。你返回内容给jvm没有意义。<br>main:是一个常见的方法入口。我见过的语言都是以main作为入口。<br>String[] args:这是一个字符串数组。这个东西早期是为了接收键盘录入的数据的。</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>执行如下程序，输出结果是（ ）<br>class Test<br>{<br>     private int data;<br>     int result = 0;<br>     public void m()<br>     {<br>         result += 2;<br>         data += 2;<br>         System.out.print(result + “  “ + data);<br>     }<br> }<br> class ThreadExample extends Thread<br> {<br>     private Test mv;<br>     public ThreadExample(Test mv)<br>     {<br>         this.mv = mv;<br>     }<br>     public void run()<br>     {<br>         synchronized(mv)<br>         {<br>             mv.m();<br>         }<br>     }<br> }<br> class ThreadTest<br> {<br>     public static void main(String args[])<br>     {<br>         Test mv = new Test();<br>         Thread t1 = new ThreadExample(mv);<br>         Thread t2 = new ThreadExample(mv);<br>         Thread t3 = new ThreadExample(mv);<br>         t1.start();<br>         t2.start();<br>         t3.start();<br>     }<br> }</p><ul><li>A 0 22 44 6</li><li>B 2 42 42 4</li><li>C 2 24 46 6</li><li>D 4 44 46 6</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>只要注意这里锁住的是对象就可以了<br>这里只创建了一个对象Test mv = new Test();<br>如果换成synchronized(Test.class)锁住的就是这个类,执行的结果就不一样了<br>这里是同一个对象锁 所以一个线程执行完另一个线程才能访问<br>三个线程传输的是同一个mv,而且加了同步锁synchronized(mv)，所以执行的时候按照顺序执行即可</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下列哪个对访问修饰符作用范围由大到小排列是正确的？</p><ul><li>A private&gt;default&gt;protected&gt;public</li><li>B public&gt;default&gt;protected&gt;private</li><li>C private&gt;protected&gt;default&gt;public</li><li>D public&gt;protected&gt;default&gt;private</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下面哪个修饰符修饰的变量是所有同一个类生成的对象共享的（ ）</p><ul><li>A public</li><li>B private</li><li>C static</li><li>D final</li></ul><p>正确答案: C</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>Integer i = 42;<br>Long l = 42l;<br>Double d = 42.0;<br>下面为true的是</p><ul><li>A (i == l)</li><li>B (i == d)</li><li>C (l == d)</li><li>D i.equals(d)</li><li>E d.equals(l)</li><li>F i.equals(l)</li><li>G l.equals(42L)</li></ul><p>正确答案: G</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>设m和都是int类型,那么以下for循环语句的执行情况是( )<br>for (m = 0, n = -1; n = 0; m++, n++)<br>n++;</p><ul><li>A 循环体一次也不执行 循环体执行一次 是无限循环 有限次循环 循环结束判断条件不合法 运行出错</li><li>B 循环体执行一次 是无限循环</li><li>C 有限次循环</li><li>D 循环结束判断条件不合法</li></ul><p>正确答案: D</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>循环条件:n = 0是int类型，不是boolean型的。<br>所以语法错误<br>for(初始化语句；判断条件语句；控制条件语句){<br>循环体语句；<br>}</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>String s = new String(“xyz”);创建了几个StringObject？</p><ul><li>A 两个或一个都有可能</li><li>B 两个</li><li>C 一个</li><li>D 三个</li></ul><p>正确答案: A</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>如果在常量池中已经存在“xyz”，那么只创建一个new String(“xyz”)的对象。<br>如果常量池中没有“xyz”，则会创建两个对象，一个是常量池中的对象“xyz”，一个是new String(“xyz”)的对象。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>java中下面哪些是Object类的方法（）</p><ul><li>A notify()</li><li>B notifyAll()</li><li>C sleep()</li><li>D wait()</li></ul><p>正确答案: ABD</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>java中关于继承的描述正确的是（）</p><ul><li>A 一个子类只能继承一个父类</li><li>B 子类可以继承父类的构造方法</li><li>C 继承具有传递性</li><li>D 父类一般具有通用性，子类更具体</li></ul><p>正确答案: ACD</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>子类不可以继承父类的构造方法，只可以调用父类的构造方法。</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/986ae252/">2019年10月29日 java 4</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月29日 java 3</title>
      <link href="/exam//60e77f1/"/>
      <url>/exam//60e77f1/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/60e77f1/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/60e77f1/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/60e77f1/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/60e77f1/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/60e77f1/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/60e77f1/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/60e77f1/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/60e77f1/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/60e77f1/#考点9" class="header_1">考点9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>要使对象具有序列化能力，则其类应该实现如下哪个接口(    )。</p><ul><li>A java.io.Serializable</li><li>B java.lang.Cloneable,</li><li>C java.lang.CharSequence</li><li>D java.lang.Comparable</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>java.io.Serializable接口是一个标志性接口，在接口内部没有定义任何属性与方法。只是用于标志此接口的实现类可以被序列化与反序列化。<br>java.lang.Cloneable接口是一个标志性接口，在接口内部没有定义任何属性与方法。以指示Object.clone()方法可以合法地对该类实例进行按字段复制。<br>java.lang.CharSequence接口对许多不同种类的char序列提供统一的只读访问接口。CharSequence是char值的一个可读序列。<br>java.lang.Comparable接口，此接口强制对实现它的每个类的对象进行整体排序，此序列被称为该类的自然排序</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>子类要调用继承自父类的方法，必须使用super关键字。</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: B</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>1、子类构造函数调用父类构造函数用super<br>2、子类重写父类方法后，若想调用父类中被重写的方法，用super<br>3、未被重写的方法可以直接调用。</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下说法错误的是（）</p><ul><li>A 虚拟机中没有泛型，只有普通类和普通方法</li><li>B 所有泛型类的类型参数在编译时都会被擦除</li><li>C 创建泛型对象时请指明类型，让编译器尽早的做参数检查</li><li>D 泛型的类型擦除机制意味着不能在运行时动态获取List<T>中T的实际类型</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li>Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此List<String>和List<Integer>在运行时实际上是相同的类型。这两种类型都被擦除成它们的“原生”类型，即List。</li><li>因此， <strong>虚拟机中没有泛型，只有普通类和普通方法</strong> 。</li><li>不过还是可以通过反射获得泛型类T的实际类型</li></ul><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>以下代码执行的结果显示是多少（ ）？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; <span class="class"><span class="keyword">class</span> <span class="title">Super</span></span>&#123;  <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">         Super()&#123;</span><br><span class="line">             test();</span><br><span class="line">         &#125;  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Super.test() flag="</span>+flag);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span></span>&#123;</span><br><span class="line">        Sub(<span class="keyword">int</span> i)&#123;  flag=i;</span><br><span class="line">            System.out.println(<span class="string">"Sub.Sub()flag="</span>+flag);</span><br><span class="line">        &#125;  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Sub.test()flag="</span>+flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  <span class="keyword">new</span> Demo().<span class="keyword">new</span> Sub(<span class="number">5</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A Sub.test() flag=1 Sub.Sub() flag=5</li><li>B Sub.Sub() flag=5 Sub.test() flag=5</li><li>C Sub.test() flag=0 Sub.Sub() flag=5</li><li>D Super.test() flag=1 Sub.Sub() flag=5</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>在只想new Sub(5)的时候，父类先初始化了 int flag = 1，然后执行父类的构造函数Super（），父类构造函数中执行的test（）方法，因子类是重写了test（）方法的，因此父类构造函数中的test（）方法实际执行的是子类的test（）方法，所以输出为Sub.test() flag=1，接着执行子类构造函数Sub(5) 将flag赋值为5，因此输出结果Sub.Sub() flag=5</p><p> <strong>重点在于要时刻记得子类重写父类方法，实例化子类对象，调用时会调用子类重写之后的方法</strong> </p><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>运行代码，输出的结果是（）<br>public class P {<br>public static int abc = 123;<br>static{<br>System.out.println(“P is init”);<br>}<br>}<br>public class S extends P {<br>static{<br>System.out.println(“S is init”);<br>}<br>}<br>public class Test {<br>public static void main(String[] args) {<br>System.out.println(S.abc);<br>}<br>}</p><ul><li>A P is init<br />123</li><li>B S is init<br />P is init<br />123</li><li>C P is init<br />S is init<br />123</li><li>D S is init<br />123</li></ul><p>正确答案: A</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>静态代码块在 <strong>类初始化的时候</strong> 执行<br>属于 <strong>被动引用</strong> 不会出发子类初始化<br> 1.子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化<br> 2.通过数组定义来引用类，不会触发子类的初始化<br> 3.常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。<br> 参考：《深入理解Java虚拟机》<br>这里有类主动引用和被动引用的demo：<a href="https://www.jianshu.com/p/3afa5d24bf71" target="_blank" rel="noopener">https://www.jianshu.com/p/3afa5d24bf71</a></p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>关于下面的一段代码，以下哪些说法是正确的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="keyword">new</span> String(<span class="string">"myString"</span>);</span><br><span class="line">    String b = <span class="string">"myString"</span>;</span><br><span class="line">    String c = <span class="string">"my"</span> + <span class="string">"String"</span>;</span><br><span class="line">    String d = c;</span><br><span class="line">    System.out.print(a == b);</span><br><span class="line">    System.out.print(a == c);</span><br><span class="line">    System.out.print(b == c);</span><br><span class="line">    System.out.print(b == d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A System.out.print(a == b)打印出来的是false</li><li>B System.out.print(a == c)打印出来的是true</li><li>C System.out.print(b == c)打印出来的是false</li><li>D System.out.print(b == d)打印出来的是true</li></ul><p>正确答案: AD</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>a是运行时动态加载的，此时会在堆内存中生成一个myString字符串，指向堆内存字符串地址<br>b是编译时静态加载的，此时会在常量池中存放一个myString字符串，指向常量池字符串地址<br>A：a指向堆内存，b指向常量池，因此地址不相等，false<br>B：java有常量优化机制，c也指向常量池，且与b指向同一个，则a与c地址不相等,false；<br>C：b与c地址相等，true<br>D：d是c的副本，地址相同，所以b与d地址相等，true</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>下列关于系列化和反序列化描述正确的是：</p><ul><li>A 序列化是将数据转为n个 byte序列的过程</li><li>B 反序列化是将n个 byte转换为数据的过程</li><li>C 将类型int转换为4 byte是反序列化过程</li><li>D 将8个字节转换为long类型的数据为序列化过程</li></ul><p>正确答案: AB</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>序列化：将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。<br>反序列化：与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>下列哪些操作会使线程释放锁资源？</p><ul><li>A sleep()</li><li>B wait()</li><li>C join()</li><li>D yield()</li></ul><p>正确答案: BC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>1.sleep会使当前线程睡眠指定时间，不释放锁<br>2.yield会使当前线程重回到可执行状态，等待cpu的调度，不释放锁<br>3.wait会使当前线程回到线程池中等待，释放锁，当被其他线程使用notify，notifyAll唤醒时进入可执行状态<br>4.当前线程调用 某线程.join（）时会使当前线程等待某线程执行完毕再结束，底层调用了wait()方法的，wait()释放锁资源，故join也释放锁资源</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>关于Java中的ClassLoader下面的哪些描述是错误的：(         )</p><ul><li>A 默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System</li><li>B 一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的</li><li>C 类装载器需要保证类装载过程的线程安全</li><li>D ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null</li><li>E ClassLoader的父子结构中，默认装载采用了父优先</li><li>F 所有ClassLoader装载的类都来自CLASSPATH环境指定的路径</li></ul><p>正确答案: BDF</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>A、java中类的加载有5个过程，加载、验证、准备、解析、初始化；这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。A正确<br>B、一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。所以B前面部分是正确的，后面接口的部分真的没有尝试过，等一个大佬的讲解吧；<br>C、类加载器是肯定要保证线程安全的；C正确<br>D、装载一个不存在的类的时候，因为采用的双亲加载模式，所以强制加载会直接报错，D错误<br>java.lang.SecurityException: Prohibited package name: java.lang<br>E、双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，所以默认是父装载，E正确<br>F、自定义类加载器实现 继承ClassLoader后重写了findClass方法加载指定路径上的class，F错误</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/60e77f1/">2019年10月29日 java 3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月30日 java 3</title>
      <link href="/exam//e6e6051b/"/>
      <url>/exam//e6e6051b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/e6e6051b/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/e6e6051b/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/e6e6051b/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/e6e6051b/#考点4" class="header_1">考点4</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>以下代码执行后输出结果为（ ）<br>public class ClassTest{<br>     String str = new String(“hello”);<br>     char[] ch = {‘a’,’b’,’c’};<br>     public void fun(String str, char ch[]){<br>     str=”world”;<br>     ch[0]=’d’;<br> }<br> public static void main(String[] args) {<br>     ClassTest test1 = new ClassTest();<br>     test1.fun(test1.str,test1.ch);<br>     System.out.print(test1.str + “ and “);<br>     System.out.print(test1.ch);<br>     }<br> }</p><ul><li>A hello and dbc</li><li>B world and abc</li><li>C hello and abc</li><li>D world and dbc</li></ul><p>正确答案: A</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>ArrayList list = new ArrayList(20);中的list扩充几次</p><ul><li>A 0</li><li>B 1</li><li>C 2</li><li>D 3</li></ul><p>正确答案: A</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>ArrayList list=new ArrayList(); 这种是默认创建大小为10的数组，每次扩容大小为1.5倍<br> ArrayList list=new ArrayList(20); 这种是指定数组大小的创建，创建时直接分配其大小，没有扩充。 所以，扩充为0次</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>下面程序的输出结果是？<br>package algorithms.com.guan.javajicu;<br>public class TestDemo {<br>    public static String output =””;<br>    public static void foo(int i){<br>       try{<br>           if(i == 1){<br>              throw new Exception();<br>           }<br>       }catch(Exception e){<br>           output += “2”;<br>           return ;<br>       }finally{<br>           output += “3”;<br>       }<br>       output += “4”;<br>    }  </p><pre><code>public static void main(String[] args) {     foo(0);     foo(1);     System.out.println(output); }  </code></pre><p>}  </p><ul><li>A 出错</li><li>B 342</li><li>C 34234</li><li>D 3423</li></ul><p>正确答案: D</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>下列哪个选项是合法的标识符？（）</p><ul><li>A 123</li><li>B _name</li><li>C class</li><li>D first</li></ul><p>正确答案: BD</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>Java标识符由数字、字母、下划线(_)、美元符号($)组成，首位不能是数字。并且Java关键字不能作为标识符</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/e6e6051b/">2019年10月30日 java 3</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月30日 java 2</title>
      <link href="/exam//91e1358d/"/>
      <url>/exam//91e1358d/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/91e1358d/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/91e1358d/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/91e1358d/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/91e1358d/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/91e1358d/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/91e1358d/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/91e1358d/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/91e1358d/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/91e1358d/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/91e1358d/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>下列叙述错误的是( )</p><ul><li>A java提供了丰富的类库</li><li>B java很好的利用了网络资源</li><li>C java支持多线程</li><li>D java不支持TCP/IP协议</li></ul><p>正确答案: D</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>对于java类型变量char c,short s,float f,double d,表达式c*s+f+d的结果类型为（）</p><ul><li>A float</li><li>B char</li><li>C short</li><li>D double</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>自动类型转换遵循下面的规则：<br>1.若参与运算的数据类型不同，则先转换成同一类型，然后进行运算。<br>2.转换按数据长度增加的方向进行，以保证精度不降低。例如int型和long型运算时，先把int量转成long型后再进行运算。<br>3.所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。<br>4.char型和short型参与运算时，必须先转换成int型。<br>5.在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型将转换为左边变量的类型。如果右边表达式的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度。<br>byte-&gt;short-&gt;int<br>char -&gt; int -&gt; long<br>float -&gt; double<br>int -&gt; float-&gt;double<br>long -&gt; double</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>以下程序的运行结果是（）<br>public class Increment<br>{<br>    public static void main(String args[])<br>    {<br>        int a;<br>        a = 6;<br>        System.out.print(a);<br>        System.out.print(a++);<br>        System.out.print(a);<br>    }<br>}</p><ul><li>A 666</li><li>B 667</li><li>C 677</li><li>D 676</li></ul><p>正确答案: B</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>a++表示先用后+，<br>而++a表示先+后用</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>BufferedReader的父类是以下哪个？</p><ul><li>A FilterReader</li><li>B InputStreamReader</li><li>C PipedReader</li><li>D Reader</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>枚举（enum）属于原始数据类型（primitive type）。</p><ul><li>A 正确</li><li>B 错误</li></ul><p>正确答案: B</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>这里的原始数据类型就是基本数据类型<br>byte,short,int,long,float,double,boolean,char.<br>枚举类是一种特殊对的类，既然是类。那他就不是原始数据类型了</p><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>public class contained in a Java program file must have the same name as the file, except for the extension “.java”.</p><ul><li>A FALSE</li><li>B TRUE</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>1、java文件中类型为public的类有两种，一种是外部类，一种是内部类；<br>2、当外部类的类型为public时，文件名需要与其相同；<br>3、当内部类的类型为public时，而外部类不是public类型的，则文件名可随意，但需要满足命名规范（以字母或下划线开头）。</p><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>关于java编译和运行命令叙述不正确的是？  ( )</p><ul><li>A 运行“java Scut.class”</li><li>B 运行“java Scut”</li><li>C 运行“javac Scut.java”的输出文件是Scut.class</li><li>D java这个命令的运行对象是Scut.class</li></ul><p>正确答案: A</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>先编译：javac scut.java.产生字节码文件(scut.class).<br>再运行字节码文件:java scut.此时不需要加后缀</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>在java中重写方法应遵循规则的包括（）</p><ul><li>A 访问修饰符的限制一定要大于被重写方法的访问修饰符</li><li>B 可以有不同的访问修饰符</li><li>C 参数列表必须完全与被重写的方法相同</li><li>D 必须具有不同的参数列表</li></ul><p>正确答案: BC</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>两同两小一大原则：<br>两同：方法名和参数列表相同<br>两小：返回值或声明异常比父类小（或相同）<br>一大：访问修饰符比父类的大（或相同）<br>访问权限可以相同，所以A不对。<br>访问权限可以更大，则不同，所以B对</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>以下程序执行后，错误的结果是（）<br>public class Test {<br>    private String name = “abc”;<br>    public static void main(String[] args) {<br>        Test test = new Test();<br>        Test testB = new Test();<br>        String result = test.equals(testB) + “,”;<br>        result += test.name.equals(testB.name) + “,”;<br>        result += test.name == testB.name;<br>        System.out.println(result);<br>    }<br>}</p><ul><li>A true,true,true</li><li>B true,false,false</li><li>C false,true,false</li><li>D false,true,true</li></ul><p>正确答案: ABC</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>Test重写equals方法。比较的是地址。所以test.equals(testB) 返回false。<br>String重写了equals方法,比较的是内容，所以，test.name.equals(testB.name)返回true。<br>String name = “abc”，name引用的是字符串直接量，字符串直接量放在常量区，只创建一次，所以是同一对象，所以test.name == testB.name返回true<br>也就是false,true,true</p><p>但是题目要你选错误的</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>下面有关java的引用类型，说法正确的有？</p><ul><li>A 对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中</li><li>B 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</li><li>C 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存</li><li>D 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间</li></ul><p>正确答案: ABCD</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><p>1、强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。<br>2、软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。<br>3、弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。<br>4、虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/91e1358d/">2019年10月30日 java 2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月29日 java 5</title>
      <link href="/exam//ef6dd2c4/"/>
      <url>/exam//ef6dd2c4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/ef6dd2c4/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/ef6dd2c4/#考点10" class="header_1">考点10</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>现有一变量声明为 boolean aa; 下面赋值语句中正确的是 （ ）</p><ul><li>A aa=false;</li><li>B aa=False;</li><li>C aa=”true”;</li><li>D aa=0;</li></ul><p>正确答案:</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>下面有关重载函数的说法中正确的是</p><ul><li>A 重载函数必须具有不同的返回值类型</li><li>B 重载函数形参个数必须不同</li><li>C 重载函数必须有不同的形参列表</li><li>D 重载函数名可以不同</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于String、StringBuffer、StringBuilder以下说法错误的是</p><ul><li>A StringBuilder运行速度最快</li><li>B StringBuffer是线程安全的</li><li>C String的值是可变的</li><li>D StringBuffer运行速度比String快</li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>String的值一旦确认了就不可变，每次的变化实际上都创建了一个新的String，所以有多次变化时最好还是用StringBuffer更好<br>速度：string&lt; stringbuffer &lt;stringbuilder</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>客户端要获取一个socket对象通过实例化，而服务器获得一个socket对象则通过什么方法的返回值？</p><ul><li>A getRemoteSocketAddress()</li><li>B getInputStream()</li><li>C getOutputStream()</li></ul><p>正确答案: A</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面关于垃圾收集的说法正确的是</p><ul><li>A 一旦一个对象成为垃圾，就立刻被收集掉。</li><li>B 对象空间被收集掉之后，会执行该对象的finalize方法</li><li>C finalize方法和C++的析构函数是完全一回事情</li><li>D 一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</li></ul><p>正确答案: D</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>A,B其实是一个知识点，既一个对象到GC Roots没有任何引用链相连时就是一个可回收对象，可回收对象在被回收之前，JVM会判断是否有finalize方法，如果有则会调用finalize方法，在这个方法里面对象可以自救的。<br>C 肯定不对啦<br>1.与C++的析构函数不同，析构函数调用确定，而finalize()方法是不确定的，因为finalize()方法在对象被GC回收时调用。<br>2.JVM将重写了finalize方法的对象放置于F-Queue队列，稍后会被一个优先级很低的Finalizer线程执行。Finalizer线程随时会终止，为了防止对象的finalize方法执行缓慢，或者发生死循环。</p><ol><li><strong>finaliz的设计目的是保证对象在被垃圾收集前完成特定资源的回收或给予对象最后一次重生机会等</strong> 。 <ol><li>finalize是个不太可控的方法因此并不常用，并且在JDK9+版本被标注为过时方法。</li></ol></li></ol><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>选项中哪一行代码可以替换 //add code here 而不产生编译错误</p><p>public abstract class MyClass {<br>     public int constInt = 5;<br>     //add code here<br>     public void method() {<br>     }<br>} </p><ul><li>A public abstract void method(int a);</li><li>B consInt=constInt+5;</li><li>C public int method();</li><li>D public abstract void anotherMethod(){}</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A是抽象方法，抽象类可以包含抽象方法，也可以不包含，抽象方法可以重载。正确<br>B 在类中不能constInt = constInt +5这样的运算。错误<br>C 返回值不能作为重载的依据，错误<br>D 有方法体的不能作为抽象函数，错误</p><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>在Web应用程序中，(    )负责将HTTP请求转换为HttpServletRequest对象</p><ul><li>A Servlet对象</li><li>B HTTP服务器</li><li>C Web容器</li><li>D JSP网页</li></ul><p>正确答案: C</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>web容器是一种服务程序，在服务器一个端口就有一个提供相应服务的程序，而这个程序就是处理从客户端发出的请求，如JAVA中的Tomcat容器，ASP的IIS或PWS都是这样的容器。一个服务器可以多个容器。</p><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>如何放掉一个指定占据的内存空间？（）</p><ul><li>A 调用free()方法</li><li>B 代用system.gc()方法</li><li>C 赋值给该项对象的引用为null</li><li>D 程序员无法明确强制垃圾回收器运行</li></ul><p>正确答案: D</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>如果希望监听TCP端口9000，服务器端应该怎样创建socket?</p><ul><li>A new Socket(“localhost”,9000);</li><li>B new ServerSocket(9000);</li><li>C new Socket(9000);</li><li>D new ServerSocket(“localhost”,9000);</li></ul><p>正确答案: B</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>new Socket(“localhost”,9000);　//客户端连接端口<br>new ServerSocket(9000);　//服务器端监听端口</p><ul><li>服务端：ServerSocket(port)，因为服务器知道自己的IP所以不需要输入IP</li><li>客户端：Socket(host,port)，因为客户端不知道连接哪条IP所以需要输入IP</li></ul><p>服务器端创建监听：<br>ServerSocket ss = new ServerSocket(int port)<br>客户端创建监听：<br>Socket s = new Socket(InetAddress address, int port)</p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/ef6dd2c4/">2019年10月29日 java 5</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月29日 Java 1</title>
      <link href="/exam//efac13eb/"/>
      <url>/exam//efac13eb/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/efac13eb/#考点" class="header_1">考点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><p>关于构造 器 的说法哪个正确？（ ）</p><ul><li>A 一个类只能有一个构造器</li><li>B 一个类可以有多个不同名的构造器</li><li>C 构造器与类同名</li><li>D 构造器必须自己定义，不能使用父类的构造器</li></ul><p>正确答案: C</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>选C<br>A、构造器可以重载<br>B、构造器必须与类同名<br>D、构造器可以调用父类的。</p><h1 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h1><p>Java 中的集合类包括 ArrayList 、 LinkedList 、 HashMap 等，下列关于集合类描述错误的是？</p><ul><li>A ArrayList和LinkedList均实现了List接口</li><li>B ArrayList访问速度比LinkedList快</li><li>C 随机添加和删除元素时，ArrayList的表现更加快速</li><li>D HashMap实现Map接口，它允许任何类型的键和值对象，并允许将NULL用作键或值</li></ul><p>正确答案: C</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li>ArrayList和LinkedList都是List的子接口，A正确；</li><li>ArrayList由数组实现，LinkedList由链表实现，数组的访问速度比链表快，B正确；</li><li>随机添加删除元素时，链表的效率要高于数组，C错误；</li><li>HashMap允许将null用作键或值，D正确</li></ul><p>所以选C</p><h1 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h1><p>下列关于Java语言中String和char的说法，正确的是（）</p><ul><li>A String是Java定义的一种基本数据类型。</li><li>B <code>String</code>是以”<code>\0</code>“结尾的<code>char</code>类型的数组<code>char[]</code>。</li><li>C 使用equals()方法比较两个String是否内容一样（即字符串中的各个字符都一样）。</li><li>D Char类型在Java语言里面存储的是ASCII码。</li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li>A 基本数据类型包括byte，short，int，long，float，double，char，boolean，所以A错。</li><li>B 错误，在C语言当中是这样，java不是， String内部是用char[]数组实现的，不过结尾不用<code>\0</code>。</li><li>C 正确，字符串内容比较用equals方法。</li><li>D char存储的 <strong>unicode码</strong> ，不进可以存储ascII码，汉字也可以。</li></ul><h1 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h1><p>下列关于一个类的静态成员的描述中，不正确的是</p><ul><li>A 该类的对象共享其静态成员变量的值</li><li>B 静态成员变量可被该类的所有方法访问</li><li>C 该类的静态方法能访问该类的静态成员变量</li><li>D 该类的静态数据成员变量的值不可修改</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>类的静态成员与类直接相关，与对象无关，在一个类的所有实例之间共享同一个静态成员，A正确</li><li>静态成员函数中不能调用非静态成员，C正确</li><li>非静态成员函数中可以调用静态成员，B正确</li><li>常量成员才不能修改，静态成员变量必须初始化，但可以修改（例如我们常利用静态成员变量统计某个函数的调用次数），D错误</li></ul><h1 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h1><p>下面代码运行结果是（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">         <span class="keyword">try</span> &#123;    </span><br><span class="line">             <span class="keyword">return</span> a+b;        </span><br><span class="line">         &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;    </span><br><span class="line">            System.out.println(<span class="string">"catch语句块"</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">finally</span>&#123;    </span><br><span class="line">             System.out.println(<span class="string">"finally语句块"</span>);    </span><br><span class="line">         &#125;    </span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    &#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123; </span><br><span class="line">         Test test =<span class="keyword">new</span> Test(); </span><br><span class="line">         System.out.println(<span class="string">"和是："</span>+test.add(<span class="number">9</span>, <span class="number">34</span>)); </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A catch语句块 和是：43</li><li>B 编译异常</li><li>C finally语句块 和是：43</li><li>D 和是：43 finally语句块</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ol><li>finally{}代码块比return先执行。</li><li>多个return是按顺序执行的的，多个return执行了一个后，后面的return就不会执行了。</li><li>记住一点，不管有不有异常抛出，<br>finally都会在return返回前执行。</li></ol><h1 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h1><p>下面这三条语句<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(“is ”+ <span class="number">100</span> + <span class="number">5</span>)；</span><br><span class="line">System.out.println(<span class="number">100</span> + <span class="number">5</span> +“ is”)；</span><br><span class="line">System.out.println(“is ”+ (<span class="number">100</span> + <span class="number">5</span>))；</span><br></pre></td></tr></table></figure><br>的输出结果分别是？ ( )</p><ul><li>A is 1005, 1005 is, is 1005</li><li>B is 105, 105 is, is 105</li><li>C is 1005, 1005 is, is 105</li><li>D is 1005, 105 is, is 105</li></ul><p>正确答案: D</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>关键看顺序</p><ul><li>String先出现，则其后的int统一当作String来拼接,”is”说明后面的内容都会被强制转换为string，所以是最后结果是拼接起来的</li><li>若两个int先出现，则int会先执行运算,100+5先得到105，然后与is拼接</li><li>如果有括号，括号优先级高于连接运算符,先算括号内的</li></ul><h1 id="考点-6"><a href="#考点-6" class="headerlink" title="考点"></a>考点</h1><p>下面程序执行的结果为（      ）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> ch1,ch2;</span><br><span class="line">    ch1 =<span class="string">'D'</span>+<span class="string">'8'</span>－<span class="string">'3'</span>;</span><br><span class="line">    ch2 =<span class="string">'9'</span>－<span class="string">'1'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,ch1,ch2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A <code>I &#39;8&#39;</code></li><li>B <code>I 8</code></li><li>C <code>G &#39;8&#39;</code></li><li>D 其他几项都不对</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>先看清楚代码，这是c语言的考点，<code>ASCII</code>值的运算，<code>A=65,0=48</code>（以此类推）。<code>ch1=68+56-51=73</code>然后以<code>char</code>类型输出所以是<code>I</code>，<br><code>ch2=57-49=8</code>以整型输出所以是8</p><h1 id="考点-7"><a href="#考点-7" class="headerlink" title="考点"></a>考点</h1><p>在创建派生类对象，构造函数的执行顺序（）</p><ul><li>A 基类构造函数，派生类对象成员构造函数，派生类本身的构造函数</li><li>B 派生类本身的构造函数，基类构造函数，对象成员构造函数</li><li>C 基类构造函数，派生类本身的构造函数，派生类对象成员构造函数</li><li>D 对象成员构造函数，基类构造函数，派生类本身的构造函数</li></ul><p>正确答案: A</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p>考点有问题，对象成员构造函数其实是对象初始化块</p><ul><li>先基类，后子类</li><li>先静态初始化块，再对象初始化块，再构造器。</li></ul><h1 id="考点-8"><a href="#考点-8" class="headerlink" title="考点"></a>考点</h1><p>java 8中，下面哪个类用到了解决哈希冲突的开放定址法</p><ul><li>A LinkedHashSet</li><li>B HashMap</li><li>C ThreadLocal</li><li>D TreeMap</li></ul><p>正确答案: C</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p>ThreadLocal 使用开放地址法 - 线性探测法：当前哈希槽有其他对象占了，顺着数组索引寻找下一个，直到找到为止<br>HashsSet 中调用HashMap来存储数据的，HashMap采用的链地址法：当哈希槽中有其他对象了，使用链表的方式连接到那个对象上</p><h1 id="考点-9"><a href="#考点-9" class="headerlink" title="考点"></a>考点</h1><p>Java网络程序设计中,下列正确的描述是（）</p><ul><li>A Java网络编程API建立在Socket基础之上</li><li>B Java网络接口只支持TCP以及其上层协议</li><li>C Java网络接口只支持UDP以及其上层协议</li><li>D Java网络接口支持IP以上的所有高层协议</li></ul><p>正确答案: AD</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/efac13eb/">2019年10月29日 Java 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月29日 java 2</title>
      <link href="/exam//71094767/"/>
      <url>/exam//71094767/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br><a href="/exam/'71094767'/#考点" class="header_1">考点</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><p>编译<code>java</code>程序的命令文件是( )</p><ul><li>A <code>java.exe</code></li><li>B <code>javac.exe</code></li><li>C <code>applet.exe</code></li></ul><p>正确答案: B</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><code>javac.exe</code>是编译功能<code>javaCompiler</code></li><li><code>java.exe</code>是执行程序，用于执行编译好的.<code>class</code>文件</li><li><code>javadoc.exe</code>用来制作<code>java</code>文档</li><li><code>jdb.exe</code>是<code>java</code>的调试器</li><li><code>javaprof.exe</code>是剖析工具</li></ul><h1 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h1><p>以下代码的循环次数是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(--i);</span><br><span class="line">            --i;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 0</li><li>B 1</li><li>C 7</li><li>D 无限次</li></ul><p>正确答案: D</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>每次循环都是减去2，7-2n恒不等于0，所以循环一直持续下去</p><h1 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h1><p><code>int a[]= {1,2,3,4,5}</code>, <code>int *p = a</code>,  下列表达式与 <code>++*p</code> 相同的是（）</p><ul><li>A <code>*++p</code></li><li>B <code>a[0]</code></li><li>C <code>++a[0]</code></li><li>D <code>*p++</code></li></ul><p>正确答案: C</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>为什么<code>java</code>的题中老是出现C语言的题<br><code>*p</code>指针指向第一位，也就是<code>a[0]</code>，<br><code>++*p</code>就是<code>++a[0]</code>。</p><h1 id="考点-3"><a href="#考点-3" class="headerlink" title="考点"></a>考点</h1><p>以下代码段执行后的输出结果为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = -<span class="number">12</span>;</span><br><span class="line">        System.out.println(y % x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A -1</li><li>B 2</li><li>C 1</li><li>D -2</li></ul><p>正确答案: D</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>求余（取模运算）结果与被除数符号相同</li><li>取余模运算都属于除法，除法就可看作减法，-12-(-5)-(-5)</li></ul><h1 id="考点-4"><a href="#考点-4" class="headerlink" title="考点"></a>考点</h1><p>尝试编译以下程序会产生怎么样的结果？（）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">var</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">long</span> param)</span> </span>&#123; <span class="keyword">var</span> = param; &#125;<span class="comment">//(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClass a, b;</span><br><span class="line">        a =<span class="keyword">new</span> MyClass();<span class="comment">//(2)</span></span><br><span class="line">        b =<span class="keyword">new</span> MyClass(<span class="number">5</span>);<span class="comment">//(3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>A 编译错误将发生在（1），因为构造函数不能指定返回值</li><li>B 编译错误将发生在（2），因为该类没有默认构造函数</li><li>C 编译错误将在（3）处发生，因为该类没有构造函数，该构造函数接受一个int类型的参数</li><li>D 该程序将正确编译和执行</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>（1）处代码，虽然方法名和类名相同，不过由于void的修饰，所以它并不是一个构造方法，只是一个普通方法。<br>因此这个类仍然只有默认的无参构造器，所以(2)处代码正确<br>（3）处代码，没有带参数构造器 所以错误。</p><h1 id="考点-5"><a href="#考点-5" class="headerlink" title="考点"></a>考点</h1><p>以下代码执行后输出结果为（ ）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(<span class="string">"blockA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"blockB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>A blockAblockBblockA</li><li>B blockAblockAblockB</li><li>C blockBblockBblockA</li><li>D blockBblockAblockB</li></ul><p>正确答案: A</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ul><li>静态块：用<code>static</code>申明，<code>JVM</code>加载类时执行，仅执行一次 </li><li>构造块：类中直接用{}定义，每一次创建对象时执行 </li><li>执行顺序优先级：静态块&gt;main()&gt;构造块&gt;构造方法 </li><li>静态块按照声明的顺序执行，先执行<code>Test t1 = new Test()</code>;所以先输出<code>blockA</code>，</li><li>然后执行静态块，输出<code>blockB</code>，</li><li>最后执行<code>main</code>方法中的<code>Test t2 = new Test()</code>;输出<code>blockA</code>。</li></ul><h1 id="考点-6"><a href="#考点-6" class="headerlink" title="考点"></a>考点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">""</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">","</span>).length);</span><br></pre></td></tr></table></figure><p>输出结果为：</p><ul><li>A 0</li><li>B 1</li><li>C 出现异常</li></ul><p>正确答案: B</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p>就是单纯的分片成列表，因为不含有’<code>,</code>‘,所以就成为<code>[&quot;&quot;]</code>这样的列表</p><h1 id="考点-7"><a href="#考点-7" class="headerlink" title="考点"></a>考点</h1><p>以下哪些继承自Collection接口（）</p><ul><li>A List</li><li>B Set</li><li>C Map</li><li>D Array</li></ul><p>正确答案: AB</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h1 id="考点-8"><a href="#考点-8" class="headerlink" title="考点"></a>考点</h1><p>下列可作为java语言标识符的是（）</p><ul><li>A <code>a1</code></li><li>B <code>$1</code></li><li>C <code>_1</code></li><li>D <code>11</code></li></ul><p>正确答案: ABC</p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p><code>java</code>中标识符由</p><ul><li>字母，数字，下划线, 美元符组成</li><li>首位不能为数字</li><li><code>Java</code>关键字不能当作<code>Java</code>标识符</li></ul><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/71094767/">2019年10月29日 java 2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月28日 java 2</title>
      <link href="/exam//b08798a7/"/>
      <url>/exam//b08798a7/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/b08798a7/#考点1" class="header_1">考点1</a>&nbsp;<br><a href="/exam/b08798a7/#考点2" class="header_1">考点2</a>&nbsp;<br><a href="/exam/b08798a7/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/b08798a7/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/b08798a7/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/b08798a7/#考点6" class="header_1">考点6</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="考点1"><a href="#考点1" class="headerlink" title="考点1"></a>考点1</h1><p>题目省略</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>反射</strong> 破坏代码的 <strong>封装性</strong> ，破坏原有的访问修饰符访问限制</p><h1 id="考点2"><a href="#考点2" class="headerlink" title="考点2"></a>考点2</h1><p>假如某个JAVA进程的JVM参数配置如下：<br><code>-Xms1G</code><br><code>-Xmx2G</code><br><code>-Xmn500M</code><br><code>-XX:MaxPermSize=64M</code><br><code>-XX:+UseConcMarkSweepGC</code><br><code>-XX:SurvivorRatio=3</code><br>请问eden区最终分配的大小是多少？</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p><code>-Xmx2G</code>：设置<code>JVM</code>最大可用内存为<code>2G</code>。<br><code>-Xms1G</code>：设置<code>JVM</code>促使内存为<code>1G</code>。此值可以设置与<code>-Xmx</code>相同，以避免每次垃圾回收完成后<code>JVM</code>重新分配内存。<br><code>-Xmn500M</code>：设置年轻代大小为<code>500M</code>。</p><p>整个<code>JVM</code>内存大小=年轻代大小+年老代大小 + 持久代大小。</p><p>新生代中又会划分为 <code>Eden</code> 区，<code>from Survivor</code>区、<code>to Survivor</code> 区。</p><p>其中 <code>Eden</code> 和 <code>Survivor</code> 区的比例默认是 <code>8:1:1</code>，当然也支持参数调整<br><code>-XX:SurvivorRatio=3</code>的话就是<code>3:1:1</code>。</p><p>故该题为<code>500*(3/5)=300M</code>.</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>关于多线程和多进程，下面描述正确的是（）：</p><ul><li>A 多进程里，子进程可获得父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。</li><li>B 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。</li><li>C 线程的通信速度更快，切换更快，因为他们在同一地址空间内。</li><li>D 一个线程可以属于多个进程。</li></ul><p>正确答案: AC</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>1、 <strong>一个线程只能属于一个进程</strong> ，而一个进程可以有多个线程，但至少有一个线程（通常说的主线程）。<br>2、 <strong>资源分配给进程</strong> ，同一进程的所有线程共享该进程的所有资源。<br>3、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br>5、线程是指进程内的一个执行单元，也是进程内的可调度实体。<br>6、同一个进程下的多个线程之间可以共享数据，因此 <strong>开销较小</strong> 。</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p><code>java</code>有8种基本类型，请问<code>byte</code>、<code>int</code>、<code>long</code>、<code>char</code>、<code>float</code>、<code>double</code>、<code>boolean</code>各占多少个字节？</p><p>正确答案: <code>1 4 8 2 4 8 1</code></p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">基本数据类型</th><th style="text-align:left">占用空间</th></tr></thead><tbody><tr><td style="text-align:left"><code>byte</code></td><td style="text-align:left">占一个字节</td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left">占两个字节</td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left">占四个字节</td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left">占八个字节</td></tr><tr><td style="text-align:left"><code>float</code></td><td style="text-align:left">占四个字节</td></tr><tr><td style="text-align:left"><code>double</code></td><td style="text-align:left">占八个字节</td></tr><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left">占两个字节</td></tr><tr><td style="text-align:left"><code>boolean</code></td><td style="text-align:left">占一个字节</td></tr></tbody></table></div><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>表达式<code>(short)10/10.2*2</code>运算后结果是什么类型？</p><ul><li>A short</li><li>B int</li><li>C double</li><li>D float</li></ul><p>正确答案: C</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul><li>强制类型转换运算符的优先级比算数运算符要高,所以先进行强制类型转换，也就是<code>(short)</code>只对最近的10有转换效果。</li><li>浮点数默认数据类型为double</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><p>下列哪些情况下会导致线程中断或停止运行（      ）</p><ul><li>A <code>InterruptedException</code>异常被捕获</li><li>B 线程调用了<code>wait</code>方法</li><li>C 当前线程创建了一个新的线程</li><li>D 高优先级线程进入就绪状态</li></ul><p>正确答案: AB</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>A选项正确，<code>Java</code>中一般通过<code>interrupt</code>方法中断线程<br>B选项正确，线程使用了<code>wait</code>方法，会强行打断当前操作，进入阻塞（暂停）状态，然后需要<code>notify</code>方法或<code>notifyAll</code>方法才能进入就绪状态<br>C选项错误，新创建的线程不会抢占时间片，只有等当前线程把时间片用完，其他线程才有资格拿到时间片去执行。<br>D选项错误，调度算法未必是剥夺式的，而准备就绪但是还没有获得<code>CPU</code>，它的权限更高只能说明它获得<code>CPU</code>被执行的几率更大而已</p><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/b08798a7/">2019年10月28日 java 2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月28日 java 1</title>
      <link href="/exam//cbbb206b/"/>
      <url>/exam//cbbb206b/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/cbbb206b/#考点1-Integer与int的区别" class="header_1">考点1 Integer与int的区别</a>&nbsp;<br><a href="/exam/cbbb206b/#考点2-赋值运算符" class="header_1">考点2 赋值运算符</a>&nbsp;<br><a href="/exam/cbbb206b/#考点3" class="header_1">考点3</a>&nbsp;<br><a href="/exam/cbbb206b/#考点4" class="header_1">考点4</a>&nbsp;<br><a href="/exam/cbbb206b/#考点5" class="header_1">考点5</a>&nbsp;<br><a href="/exam/cbbb206b/#考点6" class="header_1">考点6</a>&nbsp;<br><a href="/exam/cbbb206b/#考点7" class="header_1">考点7</a>&nbsp;<br><a href="/exam/cbbb206b/#考点8" class="header_1">考点8</a>&nbsp;<br><a href="/exam/cbbb206b/#考点9" class="header_1">考点9</a>&nbsp;<br><a href="/exam/cbbb206b/#考点10" class="header_1">考点10</a>&nbsp;<br><a href="/exam/cbbb206b/#考点11" class="header_1">考点11</a>&nbsp;<br><a href="/exam/cbbb206b/#问题12" class="header_1">问题12</a>&nbsp;<br><a href="/exam/cbbb206b/#考点13" class="header_1">考点13</a>&nbsp;<br><a href="/exam/cbbb206b/#考点14" class="header_1">考点14</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="考点1-Integer与int的区别"><a href="#考点1-Integer与int的区别" class="headerlink" title="考点1 Integer与int的区别"></a>考点1 Integer与int的区别</h1><p><code>Integer</code>与<code>int</code>的区别</p><ul><li><code>int</code>是<code>java</code>提供的8种原始数据类型之一</li><li><code>Integer</code>是<code>java</code>为<code>int</code>提供的封装类</li><li><code>int</code>的默认值为0</li><li><code>Integer</code>的默认值为<code>null</code></li></ul><h1 id="考点2-赋值运算符"><a href="#考点2-赋值运算符" class="headerlink" title="考点2 赋值运算符"></a>考点2 赋值运算符</h1><p>判断题<br><code>Java</code> 程序中使用赋值运算符进行对象赋值时，可以得到两个完全相同的对象?<br>答:错误</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>址指向了B对象的地址，所以其实对象只有一个</p><h1 id="考点3"><a href="#考点3" class="headerlink" title="考点3"></a>考点3</h1><p>题目省略<br>定义一维数组的语句</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>Java一维数组有两种初始化方法<br>1、静态初始化<br><code>int array[] = new int[]{1,2,3,4,5};</code><br>或者<br> <code>int array[] = {1,2,3,4,5}</code><br>需要注意的是，写成如下形式也是错误的<br> <code>int array[] = new int[5]{1,2,3,4,5}</code><br>2、动态初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><br>静态与动态初始化的区别就在于，前者是声明的时候就初始化，后者是先声明，再动态初始化。</p><p>声明的时候不能初始化容量,只有new的时候才可以。<br>也就是说<br> <code>int a [10]</code><br> 这种写法是错误的</p><h1 id="考点4"><a href="#考点4" class="headerlink" title="考点4"></a>考点4</h1><p>以下哪个I/O类可以附加或更新文件</p><ul><li>A RandomAccessFile()</li><li>B OutputStream()</li><li>C DataOutputStream()</li><li>D None of the above</li></ul><p>正确答按:RandomAccessFile</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li><code>OutputStream()</code>和<code>DataOutputStream()</code>类 都需要实例化<code>FileOutputStream()</code>对象，并在参数里加<code>true</code>后才能对文件追加内容；</li><li>而<code>RandomAccessFile()</code>可以通过文件指针向文件末尾追加内容。 </li></ul><h1 id="考点5"><a href="#考点5" class="headerlink" title="考点5"></a>考点5</h1><p>下面有关<code>WebService</code>的描述，错误的是？</p><ul><li><code>A WebService</code>是跨平台，跨语言的远程调用技术</li><li><code>B WebService</code>通信机制实质就是<code>JSON</code>数据交换</li><li><code>C WebService</code>采用了<code>SOAP</code>协议（简单对象协议）进行通信</li><li><code>D WSDL</code>是用于描述 <code>Web Services</code> 以及如何对它们进行访问</li></ul><p>正确答案: B</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li><code>Webservice</code>是跨平台，跨语言的远程调用技术;</li><li>它的通信机制实质就是<code>xml</code>数据交换;<ul><li><code>JSON</code>是轻量级的</li><li><code>XML</code>是重量级的。<code>XML</code>具有跨平台，适合大量解析数据，目前<code>webService</code>主流是<code>XML</code></li></ul></li><li>它采用了<code>soap</code>协议（简单对象协议）进行通信</li><li><code>WSDL</code> 指网络服务描述语言 (<code>Web Services Description Language</code>)。<code>WSDL</code> 是一种使用 <code>XML</code> 编写的文档。这种文档可描述某个 <code>Web service</code>。它可规定服务的位置，以及此服务提供的操作（或方法）</li></ul><h1 id="考点6"><a href="#考点6" class="headerlink" title="考点6"></a>考点6</h1><ul><li><code>A final</code>是<code>java</code>中的修饰符，可以修饰类、接口、抽象类、方法和属性</li><li><code>B final</code>修饰的类肯定不能被继承</li><li><code>C final</code>修饰的方法不能被重载</li><li><code>D final</code>修饰的变量不允许被再次赋值</li></ul><p>正确答案: <code>AC</code></p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><ul><li><code>final</code>修饰的类不能被继承或者实现,抽象类用于给子类继承的，接口是用来给实现类实现的。<ul><li>所以<code>final</code>不可以修饰抽象类，不能修饰接口</li></ul></li><li><code>final</code>修饰的方法不能被子类重写，但是可以重载。</li><li><code>final</code>修饰的变量只能赋值一次</li></ul><h1 id="考点7"><a href="#考点7" class="headerlink" title="考点7"></a>考点7</h1><p>题目省略</p><ul><li>抽象类可以没有抽象方法，</li><li>但是包含抽象方法的类必须是抽象类。</li></ul><h1 id="考点8"><a href="#考点8" class="headerlink" title="考点8"></a>考点8</h1><p>判断题:<br>面向对象程序设计语言的三个基本特征是 <strong>封装</strong> 、 <strong>继承</strong> 、 <strong>多态</strong> 。<br>答:正确</p><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><ul><li>这里说的是 <code>三个</code> 基本特征。所以是封装，继承，多态。</li><li>如果说的是 <code>4个</code> 基本特征。就是封装，继承，多态，抽象。</li></ul><h1 id="考点9"><a href="#考点9" class="headerlink" title="考点9"></a>考点9</h1><p>阅读代码题，题目省略</p><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><p><code>finally</code>语句块是在<code>try</code>或者<code>catch</code> 中的<code>return</code> 语句 <strong>之前</strong> 执行的。</p><h1 id="考点10"><a href="#考点10" class="headerlink" title="考点10"></a>考点10</h1><p>判断题<br>捕获到的异常只能在当前方法中处理，不能在其他方法中处理<br>答:错误</p><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><p> <strong>捕获到的异常</strong> 不仅可以在当前方法中处理，还 <strong>可以将该异常抛给调用它的上一级方法来处理</strong> 。</p><h1 id="考点11"><a href="#考点11" class="headerlink" title="考点11"></a>考点11</h1><p>哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？<br>正确答案: <strong>无修饰符</strong></p><h2 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h2><p> <strong>私有</strong> 只能在当前类内访问。<br> <strong>默认</strong> 可以在当前类内，或者相同包内访问到<br> <strong>保护</strong> 可以在当前类内，相同包内，子类访问到。<br> <strong>公共</strong>,可以在任意地方访问到</p><h1 id="问题12"><a href="#问题12" class="headerlink" title="问题12"></a>问题12</h1><p>题目省略</p><h2 id="解析-9"><a href="#解析-9" class="headerlink" title="解析"></a>解析</h2><ul><li>接口中的变量默认是<code>public static final</code>修饰的，</li><li>接口中的方法默认是<code>public abstract</code>修饰的</li></ul><h1 id="考点13"><a href="#考点13" class="headerlink" title="考点13"></a>考点13</h1><p>关于运行时常量池，下列哪个说法是正确的</p><ul><li>A 运行时常量池大小受栈区大小的影响</li><li>B  <strong>运行时常量池大小受方法区大小的影响</strong> </li><li>C  <strong>存放了编译时期生成的各种字面量</strong> </li><li>D  <strong>存放编译时期生成的符号引用</strong> </li></ul><p>正确答案: BCD</p><h2 id="解析-10"><a href="#解析-10" class="headerlink" title="解析"></a>解析</h2><p>运行时常量池（<code>Runtime Constant Pool</code>）是 <strong>方法区的<code>一部分</code></strong> 。所以，<strong>运行时常量池受方法区大小的影响</strong>。<br><code>Class</code>文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(<code>Constant Pool Table</code>）， <strong>常量池用于存放编译器生成的各种字面量和符号引用</strong> ，常量池中的内容将在<code>类加载后</code>存放到<code>方法区</code>的<code>运行时常量池</code>中。</p><h1 id="考点14"><a href="#考点14" class="headerlink" title="考点14"></a>考点14</h1><p>题目省略<br>结论：</p><ol><li>值传递不可以改变原变量的内容和地址；</li><li>引用传递不可以改变原变量的地址，但可以改变原变量的内容</li></ol><p>java中只有值传递,没有引用传递。</p><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/cbbb206b/">2019年10月28日 java 1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Java </category>
          
          <category> 2019年10月 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月28日Linux专项练习</title>
      <link href="/exam//3e93982/"/>
      <url>/exam//3e93982/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/'3e93982'/#2019年10月28日Linux专项练习" class="header_1">2019年10月28日Linux专项练习</a>&nbsp;<br><a href="/exam/'3e93982'/#考点1-Linux给文件添加执行权限的命令" class="header_1">考点1:Linux给文件添加执行权限的命令</a>&nbsp;<br><a href="/exam/'3e93982'/#考点2-Linux-crontab" class="header_1">考点2:Linux crontab</a>&nbsp;<br><a href="/exam/'3e93982'/#考点3-arp协议" class="header_1">考点3:arp协议</a>&nbsp;<br><a href="/exam/'3e93982'/#考点4-kill命令" class="header_1">考点4:kill命令</a>&nbsp;<br><a href="/exam/'3e93982'/#考点5-shell脚本的命令行参数" class="header_1">考点5:shell脚本的命令行参数</a>&nbsp;<br><a href="/exam/'3e93982'/#考点6-clone和fork的区别" class="header_1">考点6:clone和fork的区别</a>&nbsp;<br><a href="/exam/'3e93982'/#考点7-tar打包命令" class="header_1">考点7:tar打包命令</a>&nbsp;<br><a href="/exam/'3e93982'/#考点8-进程间通信的方式" class="header_1">考点8:进程间通信的方式</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="2019年10月28日Linux专项练习"><a href="#2019年10月28日Linux专项练习" class="headerlink" title="2019年10月28日Linux专项练习"></a>2019年10月28日Linux专项练习</h1><h1 id="考点1-Linux给文件添加执行权限的命令"><a href="#考点1-Linux给文件添加执行权限的命令" class="headerlink" title="考点1:Linux给文件添加执行权限的命令"></a>考点1:Linux给文件添加执行权限的命令</h1><p>为脚本程序指定执行权限命令的参数为</p><ul><li>A <code>chmod +x filename.sh</code></li><li>B <code>chown +x filename.sh</code></li><li>C <code>chmod +w filename.sh</code></li><li>D <code>chown +r filename.sh</code></li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><code>chmod</code>拆开是<code>change modify</code>是<code>修改</code>之意，</li><li><code>chown</code>拆开是<code>change own</code>是<code>修改拥有者</code>之意</li></ul><h1 id="考点2-Linux-crontab"><a href="#考点2-Linux-crontab" class="headerlink" title="考点2:Linux crontab"></a>考点2:Linux crontab</h1><p><code>Linux crontab</code>中<code>*****/usr/local/run.sh</code>这句话5个<code>*</code>号分别代表什么？</p><ul><li>A 分钟 小时 日 月 星期</li><li>B 秒 分钟 小时 日 月</li><li>C 秒 分钟 小时 日 星期</li><li>D 分钟 小时 日 月 年</li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p><code>crontab</code>是<code>Unix</code>和<code>Linux</code>用于 <strong>设置周期性被执行的指令</strong> ，是互联网很常用的技术，很多任务都会设置在<code>crontab</code>循环执行，如果不使用<code>crontab</code>，那么任务就是常驻程序</p><h3 id="分时日月周-分食日月粥"><a href="#分时日月周-分食日月粥" class="headerlink" title="分时日月周(分食日月粥)"></a>分时日月周(分食日月粥)</h3><p><code>crontab</code>基本格式 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br></pre></td></tr></table></figure></p><p><code>第1列</code>表示分钟1～59 每分钟用<em>或者 </em>/1表示<br><code>第2列</code>表示小时1～23（0表示0点）<br><code>第3列</code>表示日期1～31<br><code>第4列</code>表示月份1～12<br><code>第5列</code>标识号星期0～6（0表示星期天）<br><code>第6列</code>要运行的命令</p><h3 id="查看crontab-cat-etc-crontab"><a href="#查看crontab-cat-etc-crontab" class="headerlink" title="查看crontab cat /etc/crontab"></a>查看crontab cat /etc/crontab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat &#x2F;etc&#x2F;crontab</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</span><br><span class="line">MAILTO&#x3D;root</span><br><span class="line"></span><br><span class="line">&amp;#35; For details see man 4 crontabs</span><br><span class="line"></span><br><span class="line">&amp;#35; Example of job definition:</span><br><span class="line">&amp;#35; .---------------- minute (0 - 59)</span><br><span class="line">&amp;#35; |  .------------- hour (0 - 23)</span><br><span class="line">&amp;#35; |  |  .---------- day of month (1 - 31)</span><br><span class="line">&amp;#35; |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line">&amp;#35; |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line">&amp;#35; |  |  |  |  |</span><br><span class="line">&amp;#35; *  *  *  *  * user-name  command to be executed</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h1 id="考点3-arp协议"><a href="#考点3-arp协议" class="headerlink" title="考点3:arp协议"></a>考点3:arp协议</h1><p>arp协议用了()</p><ul><li>A broadcast</li><li>B multicast</li><li>C unicast</li><li>D 以上选项都不正确</li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><ul><li><code>arp(address resolution protocol)</code>是地址解析协议，<code>arp</code>协议发的都是广播包</li><li><code>unicast</code>：单播，</li><li><code>multicast</code>：多播，</li><li><code>broadcast</code>：广播。</li></ul><h1 id="考点4-kill命令"><a href="#考点4-kill命令" class="headerlink" title="考点4:kill命令"></a>考点4:kill命令</h1><p>你尝试登出时收到一个错误消息，显示你还有任务未完成，你需要使用下面哪个命令？</p><ul><li>A kill PID-of-the-process</li><li>B kill job-number-of-process</li><li>C kill</li><li>D kill PID-of-the-last-command</li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><ul><li>kill pid 让进程正常退出</li><li>kill %job number 直接杀掉进程</li></ul><h1 id="考点5-shell脚本的命令行参数"><a href="#考点5-shell脚本的命令行参数" class="headerlink" title="考点5:shell脚本的命令行参数"></a>考点5:shell脚本的命令行参数</h1><p>如何获取上一条命令执行的返回码</p><ul><li>A <code>$!</code></li><li>B <code>$0</code></li><li>C <code>$?</code></li><li>D <code>$#</code></li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>$0</code></td><td style="text-align:left">脚本启动名(包括路径)</td></tr><tr><td style="text-align:left"><code>$n</code></td><td style="text-align:left">第n个参数,n=1,2,…9</td></tr><tr><td style="text-align:left"><code>$*</code></td><td style="text-align:left">所有参数列表(不包括脚本本身)</td></tr><tr><td style="text-align:left"><code>$@</code></td><td style="text-align:left">所有参数列表(独立字符串)</td></tr><tr><td style="text-align:left"><code>$#</code></td><td style="text-align:left">参数个数(不包括脚本本身)</td></tr><tr><td style="text-align:left"><code>$$</code></td><td style="text-align:left">当前程式的PID</td></tr><tr><td style="text-align:left"><code>$!</code></td><td style="text-align:left">执行上一个指令的PID</td></tr><tr><td style="text-align:left"><code>$?</code></td><td style="text-align:left">执行上一个指令的返回值</td></tr></tbody></table></div><h1 id="考点6-clone和fork的区别"><a href="#考点6-clone和fork的区别" class="headerlink" title="考点6:clone和fork的区别"></a>考点6:clone和fork的区别</h1><p>下列关于 clone 和 fork 的区别描述正确的有？</p><ul><li>A clone和fork最大不同在于fork不再复制父进程的栈空间，而是自己创建一个新的。</li><li>B clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。</li><li>C clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li><li>D fork是clone的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等</li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: C</details><h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>fork()函数复制时将父进程的所有资源都通过复制数据结构进行了复制，然后传递给子进程，所以fork()函数不带参数；<br>clone()函数则是将部分父进程的资源的数据结构进行复制， <strong>复制哪些资源是可选择的</strong> ，这个可以通过参数设定，所以clone()函数带参数，没有复制的资源可以通过指针共享给子进程。</p><ul><li>fork()是全部复制</li><li>vfork()是共享内存</li><li>clone()是可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid。</li></ul><h1 id="考点7-tar打包命令"><a href="#考点7-tar打包命令" class="headerlink" title="考点7:tar打包命令"></a>考点7:tar打包命令</h1><p>在linux中用使用tar命令将文件aaa打包为bak.tar。</p><ul><li>A <code>tar -cf bak.tar aaa</code></li><li>B <code>tar -xf bak.tar aaa</code></li><li>C <code>tar -czf bak.tar aaa</code></li><li>D <code>tar -rf bak.tar aaa</code></li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: A</details><h2 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h2><h3 id="tar解压缩命令"><a href="#tar解压缩命令" class="headerlink" title="tar解压缩命令"></a>tar解压缩命令</h3><p>语法：<code>tar [主选项+辅选项]</code>文件或者目录<br>使用该命令时，主选项是必须要有的，它告诉tar要做什么事情，辅选项是辅助使用的，可以选用。</p><h4 id="主选项"><a href="#主选项" class="headerlink" title="主选项"></a>主选项</h4><div class="table-container"><table><thead><tr><th style="text-align:left">主选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-c</code></td><td style="text-align:left">创建的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。</td></tr><tr><td style="text-align:left"><code>-x</code></td><td style="text-align:left">从档案文件中释放文件。相当于拆包。</td></tr><tr><td style="text-align:left"><code>-t</code></td><td style="text-align:left">列出档案文件的内容，查看已经备份了哪些文件。</td></tr></tbody></table></div><p>特别注意，主选项c,x,t仅能存在一个！不可同时存在！因为<strong>不可能同时压缩与解压缩</strong>。</p><h4 id="辅助选项"><a href="#辅助选项" class="headerlink" title="辅助选项"></a>辅助选项</h4><div class="table-container"><table><thead><tr><th style="text-align:left">辅助选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>-z</code></td><td style="text-align:left">是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？一般格式为xx.tar.gz或xx. tgz</td></tr><tr><td style="text-align:left"><code>-j</code></td><td style="text-align:left">是否同时具有 bzip2 的属性？亦即是否需要用 bzip2压缩或解压？一般格式为xx.tar.bz2</td></tr><tr><td style="text-align:left"><code>-v</code></td><td style="text-align:left">压缩的过程中显示文件！这个常用</td></tr><tr><td style="text-align:left"><code>-f</code></td><td style="text-align:left">使用档名，请留意，在<strong>f之后要立即接档名</strong>喔！不要再加其他参数！</td></tr><tr><td style="text-align:left"><code>-p</code></td><td style="text-align:left">使用原文件的原来属性（属性不会依据使用者而变）</td></tr></tbody></table></div><h1 id="考点8-进程间通信的方式"><a href="#考点8-进程间通信的方式" class="headerlink" title="考点8:进程间通信的方式"></a>考点8:进程间通信的方式</h1><p>Unix系统中，哪些可以用于进程间的通信？（）</p><ul><li>A Socket</li><li>B 共享内存</li><li>C 消息队列</li><li>D 信号量</li></ul><details><summary>显示答案/隐藏答案</summary>正确答案: ABCD</details><h2 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h2><h3 id="Linux进程间通信"><a href="#Linux进程间通信" class="headerlink" title="Linux进程间通信"></a>Linux进程间通信</h3><ul><li>管道、</li><li>信号、</li><li>消息队列、</li><li>共享内存、</li><li>信号量、</li><li>套接字(<code>socket</code>)</li></ul><h3 id="Windows进程间通信"><a href="#Windows进程间通信" class="headerlink" title="Windows进程间通信"></a>Windows进程间通信</h3><ul><li>管道、</li><li>消息队列、</li><li>共享内存、</li><li>信号量(<code>semaphore</code>)、</li><li>套接字(<code>socket</code>)</li></ul><h3 id="Linux线程间通信"><a href="#Linux线程间通信" class="headerlink" title="Linux线程间通信"></a>Linux线程间通信</h3><ul><li>互斥量(<code>mutex</code>),</li><li>信号量,</li><li><strong>条件变量</strong></li></ul><h3 id="Windows线程间通信"><a href="#Windows线程间通信" class="headerlink" title="Windows线程间通信"></a>Windows线程间通信</h3><ul><li>互斥量(<code>mutex</code>),</li><li>信号量(<code>semaphore</code>)、</li><li><strong>临界区</strong>(<code>critical section</code>)、</li><li><strong>事件</strong>(<code>event</code>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> Linux </category>
          
          <category> 2019年 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月27日 数据库刷题笔记</title>
      <link href="/exam//66d50c96/"/>
      <url>/exam//66d50c96/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/66d50c96/#题目1" class="header_1">题目1</a>&nbsp;<br><a href="/exam/66d50c96/#题目2" class="header_1">题目2</a>&nbsp;<br><a href="/exam/66d50c96/#题目3" class="header_1">题目3</a>&nbsp;<br><a href="/exam/66d50c96/#题目4" class="header_1">题目4</a>&nbsp;<br><a href="/exam/66d50c96/#题目5" class="header_1">题目5</a>&nbsp;<br><a href="/exam/66d50c96/#题目6" class="header_1">题目6</a>&nbsp;<br><a href="/exam/66d50c96/#题目7" class="header_1">题目7</a>&nbsp;<br><a href="/exam/66d50c96/#题目8" class="header_1">题目8</a>&nbsp;<br><a href="/exam/66d50c96/#题目9" class="header_1">题目9</a>&nbsp;<br><a href="/exam/66d50c96/#题目10" class="header_1">题目10</a>&nbsp;<br><a href="/exam/66d50c96/#题目11" class="header_1">题目11</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><p>数据库的基本特点是:</p><ol><li>数据结构化</li><li>数据的共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由<code>DBMS</code>统一管理和控制</li></ol><h1 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h1><p>在课程表中要查找课程名称中包含“计算机”课程，对应“课程名称”字段的正确准则表达式是什么。<br>答:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">like "%计算机%";</span><br></pre></td></tr></table></figure></p><h1 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h1><p>在<code>E-R</code>图中，联系用什么符号表示<br>答:<strong>菱形</strong></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><code>E-R</code>图中</p><ul><li>用<strong>矩形</strong>表示<strong>实体型</strong>；</li><li>用<strong>椭圆</strong>表示实体的属性；</li><li>用<strong>菱形</strong>表示实体型之间的联系</li></ul><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><p>实体是信息世界中的术语，与之对应的数据库术语是什么<br>答:记录</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li>一个实体对应一条记录，或一个元组；</li><li>一个属性对应一个数据项，或一个字段</li></ul><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><p>当局部<code>E-R</code>图合并成全局<code>E-R</code>图时可能出现那些冲突<br>答:局部E-R图之间的冲突主要有三类：</p><ul><li>属性冲突、</li><li>命名冲突,</li><li>结构冲突。</li></ul><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><p><code>SQL</code> 基本表的创建中是通过哪个子句实现实体完整性规则的<br>答:主键子句</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>实体完整性是对关系中的记录唯一性，准确来说<strong>实体完整性是指关系中的主属性值不能为Null且不能有相同值</strong> 。<br> 定义表中的所有行能唯一的标识,一般用主键子句</p><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><p>数据库管理系统(<code>DBMS</code>)是哪一个级别的软件。<br>答:系统软件</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>系统软件是和硬件直接相关联的，没有系统软件，计算机就没有办法正常运行。包括：</p><ul><li>操作系统、</li><li>语言处理程序、</li><li>标准库程序、</li><li>服务型程序、</li><li>数据库管理系统、</li><li>计算机网络软件</li></ul><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>从关系中挑选出指定的元组组成新关系的运算叫什么<br>答:”选取”运算</p><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><p>省略<br>外键的取值只允许等于所参照关系中某个主键值或者为空</p><h1 id="题目10"><a href="#题目10" class="headerlink" title="题目10"></a>题目10</h1><p>授权语句格式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 权限 on 表 to 用户</span><br></pre></td></tr></table></figure></p><h1 id="题目11"><a href="#题目11" class="headerlink" title="题目11"></a>题目11</h1><p>题目略</p><h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p><strong>实体完整性</strong>和<strong>参照完整性</strong>适用于任何关系型数据库系统,它主要是针对关系的主关键字和外部关键字取值必须有效而做出的约束。<br><strong>用户定义完整性</strong> (<code>user defined integrity</code>)则是根据应用环境的要求和实际的需要,对某一具体应用所涉及的数据提出约束性条件。这一约束机制一般不应由应用程序提供,而应有由关系模型提供定义并检验<br><strong>用户定义完整性</strong>主要包括<strong>字段有效性约束</strong>和 <strong>记录有效性</strong> 。<br><!--SSTStop--></p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/66d50c96/">2019年10月27日 数据库刷题笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月26日 数据库刷题笔记</title>
      <link href="/exam//c25e9737/"/>
      <url>/exam//c25e9737/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/c25e9737/#问题1" class="header_1">问题1</a>&nbsp;<br><a href="/exam/c25e9737/#问题2" class="header_1">问题2</a>&nbsp;<br><a href="/exam/c25e9737/#问题3" class="header_1">问题3</a>&nbsp;<br><a href="/exam/c25e9737/#问题3" class="header_1">问题3</a>&nbsp;<br><a href="/exam/c25e9737/#题目4" class="header_1">题目4</a>&nbsp;<br><a href="/exam/c25e9737/#题目5" class="header_1">题目5</a>&nbsp;<br><a href="/exam/c25e9737/#题目6" class="header_1">题目6</a>&nbsp;<br><a href="/exam/c25e9737/#题目7" class="header_1">题目7</a>&nbsp;<br><a href="/exam/c25e9737/#题目8" class="header_1">题目8</a>&nbsp;<br><a href="/exam/c25e9737/#题目9" class="header_1">题目9</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>在一个关系R中，若每个数据项都是不可再分割的，那么R一定属于<br>答案:<strong>第一范式</strong></p><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>在SQL语言中的视图VIEW是数据库的<br><strong>外模式</strong></p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>SQL语言的功能有</p><ol><li>数据定义、</li><li>数据操纵、</li><li>数据控制</li></ol><h1 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h1><p>设关系R和S的属性个数分别为r和s,则(<code>R×S</code>)操作结果的属性个数是什么<br>答案:<code>x+y</code></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析:"></a>解析:</h2><p>笛卡尔乘积X×Y结果的属性个数等于<code>x+y</code>，结果的元组个数等于<code>x*y</code>.</p><h1 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h1><p><code>SQL</code>基本表的创建中是通过哪个子句实现参照完整性规则的</p><ul><li>主键 实现 实体完整性约束</li><li>外键 实现 参照完整性约束</li></ul><h1 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h1><p>题目省略<br>答:<code>SQL</code>是非过程化的语言</p><h1 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h1><p><code>SQL</code>语言具有两种使用方式，一个称为交互式<code>SQL</code> ，还有一个是什么<br>答:嵌入式<code>SQL</code></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ul><li><strong>交互式</strong>是通过命令行或者客户端工具操作数据库的方式。</li><li><strong>嵌入式</strong>是高级语言操作数据库的方式，高级语言编程时使用。</li></ul><h1 id="题目7"><a href="#题目7" class="headerlink" title="题目7"></a>题目7</h1><p>下列回收授权的语句正确的是:</p><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>回收授权语句格式如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> 表 <span class="keyword">from</span> 用户</span><br></pre></td></tr></table></figure><br>再结合题意即可得到正确的回收授权语句</p><h1 id="题目8"><a href="#题目8" class="headerlink" title="题目8"></a>题目8</h1><p>题目略，</p><h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h2 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h2><ul><li><strong>第一范式</strong>，关系模式的所有属性均为简单属性，即<strong>属性不可再分</strong>。</li><li><strong>第二范式</strong>，若关系模式属于第一范式，并且每个非主属性都完全依赖于关系模式的码。即<strong>消除<code>非主属性</code>对<code>码</code>的<code>部分依赖</code></strong>。</li><li><strong>第三范式</strong>，若关系模式属于第二范式，并且<strong>每个<code>非主属性</code>都不<code>传递依赖</code>于候选码</strong>。即<strong>消除非主属性对码的传递依赖</strong></li></ul><h1 id="题目9"><a href="#题目9" class="headerlink" title="题目9"></a>题目9</h1><p>在<code>SQL</code>中，删除视图用什么命令<br>答:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名;</span><br></pre></td></tr></table></figure><br><!--SSTStop--></p><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/c25e9737/">2019年10月26日 数据库刷题笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月18日 数据库刷题笔记</title>
      <link href="/exam//ecbe9f3/"/>
      <url>/exam//ecbe9f3/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a><code>ACID</code></h1><h2 id="原子性Atomicity"><a href="#原子性Atomicity" class="headerlink" title="原子性Atomicity"></a>原子性<code>Atomicity</code></h2><p>事务的原子性是指事务中包括的所有操作<strong>要么都做，要么都不做</strong></p><h2 id="一致性Consistency"><a href="#一致性Consistency" class="headerlink" title="一致性Consistency"></a>一致性Consistency</h2><p>事务前后数据的完整性必须保持一致。事务必须是使数据库从一个一致性状态变到另一个一致性状态</p><h2 id="隔离性Isolation"><a href="#隔离性Isolation" class="headerlink" title="隔离性Isolation"></a>隔离性Isolation</h2><p>一个事务内部的操作及使用的数据对并发的其他事务是隔离的</p><h2 id="持久性Durability"><a href="#持久性Durability" class="headerlink" title="持久性Durability"></a>持久性Durability</h2><p><strong>事务一旦提交,对数据库的改变是永久的</strong>,接下来即使数据库发生故障也不应该对其有任何影响</p><h1 id="like模式匹配的通配符"><a href="#like模式匹配的通配符" class="headerlink" title="like模式匹配的通配符"></a>like模式匹配的通配符</h1><ul><li>通配符<code>%</code>匹配的是任意字符,也就是<strong>0个或者0个以上的字符</strong></li><li>通配符<code>_</code>匹配的是任意<code>一个</code>字符。</li></ul><h1 id="在关系模型中-起导航数据作用的是"><a href="#在关系模型中-起导航数据作用的是" class="headerlink" title="在关系模型中 起导航数据作用的是"></a>在关系模型中 起导航数据作用的是</h1><p>答案: 关键码</p><h1 id="自然连接的条件"><a href="#自然连接的条件" class="headerlink" title="自然连接的条件"></a>自然连接的条件</h1><p>关系R和S进行自然连接时，要求R和S含有一个或多个公共的<strong>属性</strong></p><h1 id="DTS-数据转换服务-Data-Transformation-Services-介绍"><a href="#DTS-数据转换服务-Data-Transformation-Services-介绍" class="headerlink" title="DTS 数据转换服务 Data Transformation Services 介绍"></a>DTS 数据转换服务 Data Transformation Services 介绍</h1><p><code>DTS</code> 是一组数据转换工具，您可以用来在一个或多个<code>数据源</code>之间进行不同类型数据的导入、导出和转换。<br>这里的数据源数据库或类似数据库的东西,例如(<code>Microsoft SQL Server</code>,<code>Microsoft Excel</code>,<code>Microsoft Access</code>,<code>MySQL</code>,<code>Oracle</code>).</p><h1 id="数据库的数据项之间和记录之间都存在联系"><a href="#数据库的数据项之间和记录之间都存在联系" class="headerlink" title="数据库的数据项之间和记录之间都存在联系"></a>数据库的<code>数据项</code>之间和<code>记录</code>之间都存在联系</h1><h1 id="范式相关的东西我还不知道"><a href="#范式相关的东西我还不知道" class="headerlink" title="范式相关的东西我还不知道"></a>范式相关的东西我还不知道</h1><h1 id="SQL查询中的where子句中不能有聚集函数"><a href="#SQL查询中的where子句中不能有聚集函数" class="headerlink" title="SQL查询中的where子句中不能有聚集函数"></a>SQL查询中的where子句中不能有聚集函数</h1><ul><li><code>where</code>子句用于选出满足条件的行.</li><li><code>having</code>子句用于选出满足条件的列。</li><li><code>聚集函数</code>用于统计结果<code>表中的所有的列</code>上的数据,这要求先要确定表中有多少行,<ul><li>也就是聚集函数需要放在<code>where</code>子句之后,聚集函数不能放在<code>where</code>子句之中.</li><li>聚集函数可以用在<code>having</code>子句中,也可以放在<code>select</code>子句之中.</li></ul></li></ul><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/ecbe9f3/">2019年10月18日 数据库刷题笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2019年10月16日 数据库刷题笔记</title>
      <link href="/exam//e973c4f4/"/>
      <url>/exam//e973c4f4/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><!--SSTStart--><h2 id="数据库系统的独立性是指"><a href="#数据库系统的独立性是指" class="headerlink" title="数据库系统的独立性是指"></a>数据库系统的独立性是指</h2><p>不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序</p><h2 id="数据库恢复的基础是利用转储的冗余数据-这些转储的冗余数据包括"><a href="#数据库恢复的基础是利用转储的冗余数据-这些转储的冗余数据包括" class="headerlink" title="数据库恢复的基础是利用转储的冗余数据 这些转储的冗余数据包括"></a>数据库恢复的基础是利用转储的冗余数据 这些转储的冗余数据包括</h2><p>日志文件、数据库后备副本</p><h2 id="问题-下列关于数据库设计的叙述中-正确的是"><a href="#问题-下列关于数据库设计的叙述中-正确的是" class="headerlink" title="问题: 下列关于数据库设计的叙述中 正确的是"></a>问题: 下列关于数据库设计的叙述中 正确的是</h2><p><strong>在需求分析阶段建立数据字典</strong></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>数据字典是在<strong>需求分析阶段建立</strong>，在数据库设计过程中不断修改、充实和完善的。</p><h3 id="完整的数据库设计步骤"><a href="#完整的数据库设计步骤" class="headerlink" title="完整的数据库设计步骤"></a>完整的数据库设计步骤</h3><p>按照规范的设计方法，一个完整的数据库设计一般分为以下六个阶段：<br>⑴<strong>需求分析</strong>：分析用户的需求，包括数据、功能和性能需求；<br>⑵<strong>概念结构设计</strong>：主要采用<code>E-R</code>模型进行设计，包括画<code>E-R</code>图；<br>⑶<strong>逻辑结构设计</strong>：通过将<code>E-R</code>图转换成表，实现从<code>E-R</code>模型到关系模型的转换；<br>⑷<strong>数据库物理设计</strong>：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸<strong>数据库的实施</strong>：包括编程、测试和试运行；<br>⑹<strong>数据库运行与维护</strong>：系统的运行与数据库的日常维护。</p><h2 id="事务的隔离性是指"><a href="#事务的隔离性是指" class="headerlink" title="事务的隔离性是指"></a>事务的隔离性是指</h2><p>一个事务内部的操作及使用的数据对并发的其他事务是隔离的</p><h2 id="对关系模型叙述正确的是"><a href="#对关系模型叙述正确的是" class="headerlink" title="对关系模型叙述正确的是"></a>对关系模型叙述正确的是</h2><ul><li>关系模型建立在严格的<code>数学理论</code>、<code>集合论</code>和<code>谓词演算公式</code>的基础之上</li><li>微机<code>DBMS</code>绝大部分采取关系数据模型</li><li>用二维表表示关系模型是其一大特点</li></ul><h2 id="全局E-R模型的设计，需要消除属性冲突、命名冲突和"><a href="#全局E-R模型的设计，需要消除属性冲突、命名冲突和" class="headerlink" title="全局E-R模型的设计，需要消除属性冲突、命名冲突和"></a>全局E-R模型的设计，需要消除属性冲突、命名冲突和</h2><p>结构冲突</p><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p> 当将局部的<code>E-R</code>图集成为全局<code>E-R</code>图时，可能存在3类冲突。</p><ol><li><strong>属性冲突</strong>：包括类型、取值范围、取值单位的冲突；</li><li><strong>结构冲突</strong>：例如同一对象在一个局部<code>E-R</code>图中作为实体，而在另一个局部<code>E-R</code>图中作为属性，同一实体在不同的<code>E-R</code>图中的属性个数和类型不同等；</li><li><strong>命名冲突</strong>：包括实体类型名、联系类型名之间异名同义，或同名异义等</li></ol><h2 id="group-by中的all关键字说明"><a href="#group-by中的all关键字说明" class="headerlink" title="group by中的all关键字说明"></a>group by中的all关键字说明</h2><p><code>Transact-SQL</code> 在 <code>group by</code> 子句中提供 <code>all</code> 关键字。</p><h3 id="必须有where子句才能在group-by子句中使用all关键字"><a href="#必须有where子句才能在group-by子句中使用all关键字" class="headerlink" title="必须有where子句才能在group by子句中使用all关键字"></a>必须有where子句才能在group by子句中使用all关键字</h3><p>只有在<code>select</code>语句还包括<code>where</code>子句时,<code>all</code> 关键字才有意义。</p><h3 id="添加all时where则不起作用"><a href="#添加all时where则不起作用" class="headerlink" title="添加all时where则不起作用"></a>添加all时where则不起作用</h3><p>如果使用<code>all</code>关键字，那么查询结果将包括由<code>group by</code>子句产生的<code>所有组</code>，即使某些组没有符合<code>where</code>的条件</p><h3 id="没有all时where起作用"><a href="#没有all时where起作用" class="headerlink" title="没有all时where起作用"></a>没有all时where起作用</h3><p>没有<code>all</code>关键字，包含<code>group by</code>子句的<code>select</code>语句将不显示没有符合条件的行的组。</p><!--SSTStop--><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/e973c4f4/">2019年10月16日 数据库刷题笔记</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 牛客网 </category>
          
          <category> 专项练习 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题 [9] 回文数</title>
      <link href="/exam//2877c0a6/"/>
      <url>/exam//2877c0a6/</url>
      
        <content type="html"><![CDATA[<p><div id='my_toc'><a href="/exam/2877c0a6/#LeetCode刷题-9-回文数" class="header_1">LeetCode刷题 [9] 回文数</a>&nbsp;<br><a href="/exam/2877c0a6/#解法2-使用StringBuilder的reverse方法逆序" class="header_2">解法2: 使用StringBuilder的reverse方法逆序</a>&nbsp;<br><a href="/exam/2877c0a6/#解法3-通过数学运算逆序" class="header_2">解法3: 通过数学运算逆序</a>&nbsp;<br></div></p><p><style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style><br><a id="more"></a></p><script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script><!--end--><h1 id="LeetCode刷题-9-回文数"><a href="#LeetCode刷题-9-回文数" class="headerlink" title="LeetCode刷题 [9] 回文数"></a>LeetCode刷题 [9] 回文数</h1><p><strong>思路:逆序这个整数,然后和该整数比较</strong></p><h2 id="解法2-使用StringBuilder的reverse方法逆序"><a href="#解法2-使用StringBuilder的reverse方法逆序" class="headerlink" title="解法2: 使用StringBuilder的reverse方法逆序"></a>解法2: 使用StringBuilder的reverse方法逆序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode1_10;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> francis</span></span><br><span class="line"><span class="comment"> * create at 2019/9/17-19:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode9_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转成字符串</span></span><br><span class="line">        String xStr = String.valueOf(x);</span><br><span class="line">        <span class="comment">// 逆序字符串</span></span><br><span class="line">        String reverseStr = <span class="keyword">new</span> StringBuilder(String.valueOf(x)).reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> xStr.equals(reverseStr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] testArr = &#123;<span class="number">123</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">1000</span>, <span class="number">12321</span>, <span class="number">2332</span>&#125;;</span><br><span class="line">        LeetCode9_2 leetCode9_2=<span class="keyword">new</span> LeetCode9_2();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            System.out.println(testArr[i]+<span class="string">" 是回文数:"</span>+leetCode9_2.isPalindrome(testArr[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点:代码量少</strong></p><h2 id="解法3-通过数学运算逆序"><a href="#解法3-通过数学运算逆序" class="headerlink" title="解法3: 通过数学运算逆序"></a>解法3: 通过数学运算逆序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=9 lang=java</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [9] 回文数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否是回文数.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 一个整数.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是小数,则不是回文数</span></span><br><span class="line">        <span class="comment">// 如果是10的倍数,也不是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> &amp;&amp; (x % <span class="number">10</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆序这个正整数</span></span><br><span class="line">        <span class="keyword">int</span> reverse = getReverse(x);</span><br><span class="line">        <span class="comment">// 如果逆序后还和原来的数相等的话就是回文数</span></span><br><span class="line">        <span class="keyword">return</span> reverse == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逆序正整数.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> positiveInteger 正整数.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 该正整数逆序后的结果.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReverse</span><span class="params">(<span class="keyword">int</span> positiveInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> reverseInteger = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (positiveInteger &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前数字左移一位,然后加上个位数</span></span><br><span class="line">            reverseInteger = reverseInteger * <span class="number">10</span> + positiveInteger % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 右移删除掉当前的个位数</span></span><br><span class="line">            positiveInteger = positiveInteger / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseInteger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原文链接: <a href="https://lanlan2017.github.io/blog/2877c0a6/">LeetCode刷题 [9] 回文数</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 简单 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
